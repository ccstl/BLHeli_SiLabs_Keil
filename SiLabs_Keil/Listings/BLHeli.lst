A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE     1


MACRO ASSEMBLER A51 V8.2.7.0
OBJECT MODULE PLACED IN .\Objects\BLHeli.obj
ASSEMBLER INVOKED BY: D:\Keil_v5\C51\BIN\A51.EXE BLHeli.asm SET(SMALL) DEBUG PRINT(.\Listings\BLHeli.lst) OBJECT(.\Objec
                      ts\BLHeli.obj) EP

LOC  OBJ            LINE     SOURCE

                       1     $nomod51 
                       2     ;**** **** **** **** ****
                       3     ;
                       4     ; BLHeli program for controlling brushless motors in helicopters and multirotors
                       5     ;
                       6     ; Copyright 2011, 2012 Steffen Skaug
                       7     ; This program is distributed under the terms of the GNU General Public License
                       8     ;
                       9     ; This file is part of BLHeli.
                      10     ;
                      11     ; BLHeli is free software: you can redistribute it and/or modify
                      12     ; it under the terms of the GNU General Public License as published by
                      13     ; the Free Software Foundation, either version 3 of the License, or
                      14     ; (at your option) any later version.
                      15     ;
                      16     ; BLHeli is distributed in the hope that it will be useful,
                      17     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                      18     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                      19     ; GNU General Public License for more details.
                      20     ;
                      21     ; You should have received a copy of the GNU General Public License
                      22     ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                      23     ;
                      24     ;**** **** **** **** ****
                      25     ;
                      26     ; The software was initially designed for use with Eflite mCP X, but is now adapted to copt
                             ers/planes in general
                      27     ;
                      28     ; The software was inspired by and started from from Bernard Konze's BLMC: http://home.vers
                             anet.de/~bkonze/blc_6a/blc_6a.htm
                      29     ; And also Simon Kirby's TGY: https://github.com/sim-/tgy
                      30     ;
                      31     ; This file is best viewed with tab width set to 5
                      32     ;
                      33     ; The input signal can be positive 1kHz, 2kHz, 4kHz, 8kHz or 12kHz PWM (e.g. taken from the
                              "resistor tap" on mCPx)
                      34     ; And the input signal can be PPM (1-2ms) or OneShot125 (125-250us) at rates up to several 
                             hundred Hz.
                      35     ; The code autodetects the various input modes/frequencies
                      36     ; The code can also be programmed to accept inverted input signal.
                      37     ;
                      38     ; The first lines of the software must be modified according to the chosen environment:
                      39     ; Uncomment the selected ESC and main/tail/multi mode
                      40     ; BESCNO EQU "ESC"_"mode"                                               
                      41     ; 
                      42     ;**** **** **** **** ****
                      43     ; Revision history:
                      44     ;
                      45     ;**** **** **** **** ****
                      46     ; Up to 8K Bytes of In-System Self-Programmable Flash
                      47     ; Up to 768 Bytes Internal SRAM
                      48     ;
                      49     ;**** **** **** **** ****
                      50     ; Master clock is internal 24MHz oscillator (or 48MHz, for which the times below are halved)
                      51     ; Timer 0 (167/500ns counts) always counts up and is used for
                      52     ; - PWM generation
                      53     ; Timer 2 (500ns counts) always counts up and is used for
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE     2

                      54     ; - RC pulse timeout/skip counts and commutation times
                      55     ; Timer 3 (500ns counts) always counts up and is used for
                      56     ; - Commutation timeouts
                      57     ; PCA0 (500ns counts) always counts up and is used for
                      58     ; - RC pulse measurement
                      59     ;
                      60     ;**** **** **** **** ****
                      61     ; Interrupt handling
                      62     ; The C8051 does not disable interrupts when entering an interrupt routine.
                      63     ; Also some interrupt flags need to be cleared by software
                      64     ; The code disables interrupts in interrupt routines, in order to avoid too nested interrup
                             ts
                      65     ; - Interrupts are disabled during beeps, to avoid audible interference from interrupts
                      66     ; - RC pulse interrupts are periodically disabled in order to reduce interference with pwm 
                             interrupts.
                      67     ;
                      68     ;**** **** **** **** ****
                      69     ; Motor control:
                      70     ; - Brushless motor control with 6 states for each electrical 360 degrees
                      71     ; - An advance timing of 0deg has zero cross 30deg after one commutation and 30deg before t
                             he next
                      72     ; - Timing advance in this implementation is set to 15deg nominally
                      73     ; - "Damped" commutation schemes are available, where more than one pfet is on when pwm is 
                             off. This will absorb energy from bemf and make step settling more damped.
                      74     ; Motor sequence starting from zero crossing:
                      75     ; - Timer wait: Wt_Comm                 15deg   ; Time to wait from zero cross to actual co
                             mmutation
                      76     ; - Timer wait: Wt_Advance              15deg   ; Time to wait for timing advance. Nominal 
                             commutation point is after this
                      77     ; - Timer wait: Wt_Zc_Scan              7.5deg  ; Time to wait before looking for zero cross
                      78     ; - Scan for zero cross                 22.5deg , Nominal, with some motor variations
                      79     ;
                      80     ; Motor startup:
                      81     ; There is a startup phase and an initial run phase, before normal bemf commutation run beg
                             ins.
                      82     ;
                      83     ;**** **** **** **** ****
                      84     ; List of enumerated supported ESCs and modes  (main, tail or multi)
  00CA                85     Flycolor_Fairy_6A_Main                  EQU 202
  00CB                86     Flycolor_Fairy_6A_Tail                  EQU 203
  00CC                87     Flycolor_Fairy_6A_Multi                 EQU 204
  00CD                88     Flycolor_Fairy_30A_Main                 EQU 205
  00CE                89     Flycolor_Fairy_30A_Tail                 EQU 206
  00CF                90     Flycolor_Fairy_30A_Multi                EQU 207
  00D0                91     Flycolor_Fairy_V2_30A_Main              EQU 208
  00D1                92     Flycolor_Fairy_V2_30A_Tail              EQU 209
  00D2                93     Flycolor_Fairy_V2_30A_Multi     EQU 210
                      94       
                      95     ;**** **** **** **** ****
                      96     ; Select the ESC and mode to use (or unselect all for use with external batch compile file)
                      97     ;BESCNO EQU Flycolor_Fairy_6A_Main
                      98     ;BESCNO EQU Flycolor_Fairy_6A_Tail
                      99     ;BESCNO EQU Flycolor_Fairy_6A_Multi
  00CD               100     BESCNO EQU Flycolor_Fairy_30A_Main
                     101     ;BESCNO EQU Flycolor_Fairy_30A_Tail
                     102     ;BESCNO EQU Flycolor_Fairy_30A_Multi
                     103     ;BESCNO EQU Flycolor_Fairy_V2_30A_Main
                     104     ;BESCNO EQU Flycolor_Fairy_V2_30A_Tail
                     105     ;BESCNO EQU Flycolor_Fairy_V2_30A_Multi 
                     106     
                     107     
                     108     ;**** **** **** **** ****
                     109     ; ESC selection statements
                     110     
                     111     IF BESCNO == Flycolor_Fairy_6A_Main
                             MODE    EQU     0                               ; Choose mode. Set to 0 for main motor
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE     3

                             ;$include (Flycolor_Fairy_6A.inc) ; Select Flycolor Fairy 6A pinout
                +1           ;**** **** **** **** ****
                +1           ;
                +1           ; BLHeli program for controlling brushless motors in helicopters and multirotors
                +1           ;
                +1           ; Copyright 2011, 2012 Steffen Skaug
                +1           ; This program is distributed under the terms of the GNU General Public License
                +1           ;
                +1           ; This file is part of BLHeli.
                +1           ;
                +1           ; BLHeli is free software: you can redistribute it and/or modify
                +1           ; it under the terms of the GNU General Public License as published by
                +1           ; the Free Software Foundation, either version 3 of the License, or
                +1           ; (at your option) any later version.
                +1           ;
                +1           ; BLHeli is distributed in the hope that it will be useful,
                +1           ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                +1           ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                +1           ; GNU General Public License for more details.
                +1           ;
                +1           ; You should have received a copy of the GNU General Public License
                +1           ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                +1           ;
                +1           ;**** **** **** **** ****
                +1           ;
                +1           ; Flycolor Fairy 6A hardware definition file
                +1           ;
                +1           ;**** **** **** **** ****
                +1           
                +1           
                +1           
                +1           ;*********************
                +1           ; Device SiLabs F850
                +1           ;*********************
                +1           ;$include (c8051f850.inc)
                +2           ; PAGE DEFINITIONS
                +2           ACTIVE_PAGE          EQU 000H
                +2           DEBUG_PAGE           EQU 001H
                +2           
                +2           ; SFR ADDRESSES BEGIN
                +2           ADC0AC               DATA 0B3H ; ACTIVE
                +2           ADC0CF               DATA 0BCH ; ACTIVE
                +2           ADC0CN0              DATA 0E8H ; ACTIVE
                +2           ADC0CN1              DATA 0B2H ; ACTIVE
                +2           ADC0GTH              DATA 0C4H ; ACTIVE
                +2           ADC0GTL              DATA 0C3H ; ACTIVE
                +2           ADC0H                DATA 0BEH ; ACTIVE
                +2           ADC0L                DATA 0BDH ; ACTIVE
                +2           ADC0LTH              DATA 0C6H ; ACTIVE
                +2           ADC0LTL              DATA 0C5H ; ACTIVE
                +2           ADC0MX               DATA 0BBH ; ACTIVE
                +2           ADC0PWR              DATA 0DFH ; ACTIVE
                +2           ADC0TK               DATA 0B9H ; ACTIVE
                +2           ACC                  DATA 0E0H ;
                +2           B                    DATA 0F0H ;
                +2           DPH                  DATA 083H ;
                +2           DPL                  DATA 082H ;
                +2           PCON                 DATA 087H ;
                +2           PSW                  DATA 0D0H ;
                +2           SP                   DATA 081H ;
                +2           CRC0AUTO             DATA 0D2H ; ACTIVE
                +2           CRC0CN               DATA 0CEH ; ACTIVE
                +2           CRC0CNT              DATA 0D3H ; ACTIVE
                +2           CRC0DAT              DATA 0DEH ; ACTIVE
                +2           CRC0FLIP             DATA 0CFH ; ACTIVE
                +2           CRC0IN               DATA 0DDH ; ACTIVE
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE     4

                +2           CPT0CN               DATA 09BH ; ACTIVE
                +2           CPT0MD               DATA 09DH ; ACTIVE
                +2           CPT0MX               DATA 09FH ; ACTIVE
                +2           CPT1CN               DATA 0BFH ; ACTIVE
                +2           CPT1MD               DATA 0ABH ; ACTIVE
                +2           CPT1MX               DATA 0AAH ; ACTIVE
                +2           DERIVID              DATA 0ADH ; ACTIVE
                +2           DEVICEID             DATA 0B5H ; ACTIVE
                +2           FLSCL                DATA 09AH ; ACTIVE
                +2           REVID                DATA 0B6H ; ACTIVE
                +2           FLKEY                DATA 0B7H ;
                +2           PSCTL                DATA 08FH ;
                +2           EIE1                 DATA 0E6H ;
                +2           EIP1                 DATA 0F3H ; ACTIVE
                +2           IE                   DATA 0A8H ;
                +2           IP                   DATA 0B8H ;
                +2           IT01CF               DATA 0E4H ; ACTIVE
                +2           CKCON                DATA 08EH ; ACTIVE
                +2           CLKSEL               DATA 0A9H ;
                +2           OSCLCN               DATA 0B1H ; ACTIVE
                +2           OSCICL               DATA 0C7H ; ACTIVE
                +2           PCA0CENT             DATA 09EH ; ACTIVE
                +2           PCA0CLR              DATA 09CH ; ACTIVE
                +2           PCA0CN               DATA 0D8H ; ACTIVE
                +2           PCA0CPH0             DATA 0FCH ; ACTIVE
                +2           PCA0CPH1             DATA 0EAH ; ACTIVE
                +2           PCA0CPH2             DATA 0ECH ; ACTIVE
                +2           PCA0CPL0             DATA 0FBH ; ACTIVE
                +2           PCA0CPL1             DATA 0E9H ; ACTIVE
                +2           PCA0CPL2             DATA 0EBH ; ACTIVE
                +2           PCA0CPM0             DATA 0DAH ; ACTIVE
                +2           PCA0CPM1             DATA 0DBH ; ACTIVE
                +2           PCA0CPM2             DATA 0DCH ; ACTIVE
                +2           PCA0H                DATA 0FAH ; ACTIVE
                +2           PCA0L                DATA 0F9H ; ACTIVE
                +2           PCA0MD               DATA 0D9H ; ACTIVE
                +2           PCA0POL              DATA 096H ; ACTIVE
                +2           PCA0PWM              DATA 0F7H ; ACTIVE
                +2           P0                   DATA 080H ;
                +2           P0MASK               DATA 0FEH ; ACTIVE
                +2           P0MAT                DATA 0FDH ; ACTIVE
                +2           P0MDIN               DATA 0F1H ; ACTIVE
                +2           P0MDOUT              DATA 0A4H ; ACTIVE
                +2           P0SKIP               DATA 0D4H ; ACTIVE
                +2           P1                   DATA 090H ; ACTIVE
                +2           P1MASK               DATA 0EEH ; ACTIVE
                +2           P1MAT                DATA 0EDH ; ACTIVE
                +2           P1MDIN               DATA 0F2H ; ACTIVE
                +2           P1MDOUT              DATA 0A5H ; ACTIVE
                +2           P1SKIP               DATA 0D5H ; ACTIVE
                +2           P2                   DATA 0A0H ;
                +2           P2MDOUT              DATA 0A6H ; ACTIVE
                +2           PRTDRV               DATA 0F6H ; ACTIVE
                +2           XBR0                 DATA 0E1H ; ACTIVE
                +2           XBR1                 DATA 0E2H ; ACTIVE
                +2           XBR2                 DATA 0E3H ; ACTIVE
                +2           RSTSRC               DATA 0EFH ; ACTIVE
                +2           SMB0ADM              DATA 0D6H ; ACTIVE
                +2           SMB0ADR              DATA 0D7H ; ACTIVE
                +2           SMB0CF               DATA 0C1H ; ACTIVE
                +2           SMB0CN               DATA 0C0H ; ACTIVE
                +2           SMB0DAT              DATA 0C2H ; ACTIVE
                +2           SMB0TC               DATA 0ACH ; ACTIVE
                +2           SPI0CFG              DATA 0A1H ; ACTIVE
                +2           SPI0CKR              DATA 0A2H ; ACTIVE
                +2           SPI0CN               DATA 0F8H ; ACTIVE
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE     5

                +2           SPI0DAT              DATA 0A3H ; ACTIVE
                +2           TCON                 DATA 088H ; ACTIVE
                +2           TH0                  DATA 08CH ; ACTIVE
                +2           TH1                  DATA 08DH ; ACTIVE
                +2           TL0                  DATA 08AH ; ACTIVE
                +2           TL1                  DATA 08BH ; ACTIVE
                +2           TMOD                 DATA 089H ; ACTIVE
                +2           TMR2CN               DATA 0C8H ;
                +2           TMR2H                DATA 0CDH ; ACTIVE
                +2           TMR2L                DATA 0CCH ; ACTIVE
                +2           TMR2RLH              DATA 0CBH ; ACTIVE
                +2           TMR2RLL              DATA 0CAH ; ACTIVE
                +2           TMR3CN               DATA 091H ; ACTIVE
                +2           TMR3H                DATA 095H ; ACTIVE
                +2           TMR3L                DATA 094H ; ACTIVE
                +2           TMR3RLH              DATA 093H ; ACTIVE
                +2           TMR3RLL              DATA 092H ; ACTIVE
                +2           SBUF0                DATA 099H ; ACTIVE
                +2           SCON0                DATA 098H ;
                +2           REF0CN               DATA 0D1H ; ACTIVE
                +2           REG0CN               DATA 0C9H ; ACTIVE
                +2           VDM0CN               DATA 0FFH ; ACTIVE
                +2           WDTCN                DATA 097H ;
                +2           ; SFR ADDRESSES END
                +2           
                +2           ; BIT DEFINITIONS
                +2           
                +2           ; ADC0CN0 0xE8
                +2           AD0EN                BIT  ADC0CN0.7   ;
                +2           BURSTEN              BIT  ADC0CN0.6   ;
                +2           AD0INT               BIT  ADC0CN0.5   ;
                +2           AD0BUSY              BIT  ADC0CN0.4   ;
                +2           AD0WINT              BIT  ADC0CN0.3   ;
                +2           ADC0M2               BIT  ADC0CN0.2   ;
                +2           ADC0M1               BIT  ADC0CN0.1   ;
                +2           ADC0M0               BIT  ADC0CN0.0   ;
                +2           
                +2           ; IE 0xA8
                +2           EA                   BIT  IE.7        ; Global Interrupt Enable
                +2           ESPI0                BIT  IE.6        ; Serial Peripheral Interface Enable
                +2           ET2                  BIT  IE.5        ; Timer 2 Interrupt Enable
                +2           ES0                  BIT  IE.4        ; Serial Port Interrupt Enable
                +2           ET1                  BIT  IE.3        ; Timer 1 Interrupt Enable
                +2           EX1                  BIT  IE.2        ; External Interrupt Enable
                +2           ET0                  BIT  IE.1        ; Timer 0 Interrupt Enable
                +2           EX0                  BIT  IE.0        ; External Interrupt 0 Enable
                +2           
                +2           ; IP 0xB8
                +2                                                 ; bit 7 UNUSED
                +2           PSPI0                BIT  IP.6        ; Serial Peripheral Interface Priority
                +2           PT2                  BIT  IP.5        ; Timer 2 Priority
                +2           PS0                  BIT  IP.4        ; Serial Port Priority
                +2           PT1                  BIT  IP.3        ; Timer 1 Priority
                +2           PX1                  BIT  IP.2        ; External Interrupt 1 Priority
                +2           PT0                  BIT  IP.1        ; Timer 0 Priority
                +2           PX0                  BIT  IP.0        ; External Interrupt 0 Priority
                +2           
                +2           ; PCA0CN 0xD8
                +2           CF                   BIT  PCA0CN.7    ; PCA 0 Counter Overflow Flag
                +2           CR                   BIT  PCA0CN.6    ; PCA 0 Counter Run Control Bit
                +2                                                 ; bit 5 UNUSED
                +2                                                 ; bit 4 UNUSED
                +2                                                 ; bit 3 UNUSED
                +2           CCF2                 BIT  PCA0CN.2    ; PCA 0 Module 2 Interrupt Flag
                +2           CCF1                 BIT  PCA0CN.1    ; PCA 0 Module 1 Interrupt Flag
                +2           CCF0                 BIT  PCA0CN.0    ; PCA 0 Module 0 Interrupt Flag
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE     6

                +2           
                +2           ; PSW 0xD0
                +2           CY                   BIT  PSW.7       ; Carry Flag
                +2           AC                   BIT  PSW.6       ; Auxiliary Carry Flag
                +2           F0                   BIT  PSW.5       ; User Flag 0
                +2           RS1                  BIT  PSW.4       ; Register Bank Select 1
                +2           RS0                  BIT  PSW.3       ; Register Bank Select 0
                +2           OV                   BIT  PSW.2       ; Overflow Flag
                +2           F1                   BIT  PSW.1       ; User Flag 1
                +2           P                    BIT  PSW.0       ; Accumulator Parity Flag
                +2           
                +2           ; SCON0 0x98
                +2           S0MODE               BIT  SCON0.7     ; Serial Mode Control Bit 0
                +2                                                 ; bit 6 UNUSED
                +2           MCE0                 BIT  SCON0.5     ; Multiprocessor Communication Enable
                +2           REN0                 BIT  SCON0.4     ; Receive Enable
                +2           TB80                 BIT  SCON0.3     ; Transmit Bit 8
                +2           RB80                 BIT  SCON0.2     ; Receive Bit 8
                +2           TI0                  BIT  SCON0.1     ; Transmit Interrupt Flag
                +2           RI0                  BIT  SCON0.0     ; Receive Interrupt Flag
                +2           
                +2           ; SMB0CN 0xC0
                +2           MASTER0              BIT  SMB0CN.7    ; SMBus Master/Slave Indicator
                +2           TXMODE0              BIT  SMB0CN.6    ; SMBus Transmit Mode Indicator
                +2           STA0                 BIT  SMB0CN.5    ; SMBus Start Flag
                +2           STO0                 BIT  SMB0CN.4    ; SMBus Stop Flag
                +2           ACKRQ0               BIT  SMB0CN.3    ; SMBus Acknowledge Request
                +2           ARBLOST0             BIT  SMB0CN.2    ; SMBus Arbitration Lost Indicator
                +2           ACK0                 BIT  SMB0CN.1    ; SMBus Acknowledge
                +2           SI0                  BIT  SMB0CN.0    ; SMBus Interrupt
                +2           
                +2           ; SPI0CN 0xF8
                +2           SPIF                 BIT  SPI0CN.7    ; SPI 0 Interrupt Flag
                +2           WCOL                 BIT  SPI0CN.6    ; SPI 0 Write Collision Flag
                +2           MODF                 BIT  SPI0CN.5    ; SPI 0 Mode Fault Flag
                +2           RXOVRN               BIT  SPI0CN.4    ; SPI 0 RX Overrun Flag
                +2           NSSMD1               BIT  SPI0CN.3    ; SPI 0 NSS Mode Bit 1
                +2           NSSMD0               BIT  SPI0CN.2    ; SPI 0 NSS Mode Bit 0
                +2           TXBMT                BIT  SPI0CN.1    ; SPI 0 Transmit Buffer Empty Flag
                +2           SPIEN                BIT  SPI0CN.0    ; SPI 0 SPI Enable
                +2           
                +2           ; TCON 0x88
                +2           TF1                  BIT  TCON.7      ; Timer 1 Overflow Flag
                +2           TR1                  BIT  TCON.6      ; Timer 1 On/Off Control
                +2           TF0                  BIT  TCON.5      ; Timer 0 Overflow Flag
                +2           TR0                  BIT  TCON.4      ; Timer 0 On/Off Control
                +2           IE1                  BIT  TCON.3      ; Ext. Interrupt 1 Edge Flag
                +2           IT1                  BIT  TCON.2      ; Ext. Interrupt 1 Type
                +2           IE0                  BIT  TCON.1      ; Ext. Interrupt 0 Edge Flag
                +2           IT0                  BIT  TCON.0      ; Ext. Interrupt 0 Type
                +2           
                +2           ; TMR2CN 0xC8
                +2           TF2H                 BIT  TMR2CN.7    ; T2 High-Byte Overflow Flag
                +2           TF2L                 BIT  TMR2CN.6    ; T2 Low-Byte Overflow Flag
                +2           TF2LEN               BIT  TMR2CN.5    ; T2 Low Byte Interrupt Enable
                +2           TF2CEN               BIT  TMR2CN.4    ; T2 Input Capture Enable
                +2           T2SPLIT              BIT  TMR2CN.3    ; T2 Split-Mode Enable
                +2           TR2                  BIT  TMR2CN.2    ; Timer 2 On/Off Control
                +2                                                 ; bit 1 UNUSED
                +2           T2XCLK               BIT  TMR2CN.0    ; T2 External Clock Select
                +1           
                +1           
                +1           ;**** **** **** **** ****
                +1           ; Uses internal calibrated oscillator set to 24Mhz
                +1           ;**** **** **** **** ****
                +1           
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE     7

                +1           ;**** **** **** **** ****
                +1           ; Constant definitions
                +1           ;**** **** **** **** ****
                +1           CSEG AT 1A40h
                +1           Eep_ESC_Layout:                 DB      "#FC_Fairy_6A#   "      ; ESC layout tag
                +1           CSEG AT 1A50h
                +1           Eep_ESC_MCU:                    DB      "#BLHELI#F850#   "      ; Project and MCU tag (16 B
                             ytes)
                +1           
                +1           MCU_48MHZ                               EQU     0       ; Set to 1 if MCU can run at 48MHz
                +1           ONE_S_CAPABLE                   EQU     0       ; Set to 1 if ESC can operate at 1S
                +1           PORT3_EXIST                             EQU     0       ; Set to 1 if MCU has port3
                +1           COMP1_USED                              EQU     0       ; Set to 1 if MCU has comparator 1 
                             and it is being used
                +1           LOCK_BYTE_ADDRESS_16K   EQU     3FFFh   ; Address of lock byte if 16k flash size
                +1           LOCK_BYTE_ADDRESS_8K    EQU     1FFFh   ; Address of lock byte if 8k flash size
                +1           HIGH_BEC_VOLTAGE                EQU     0       ; Set to 1 or more if high BEC voltage is s
                             upported
                +1           DAMPED_MODE_ENABLE              EQU     0       ; Damped mode disabled
                +1           NFETON_DELAY                    EQU     6       ; Wait delay from pfets off to nfets on
                +1           PFETON_DELAY                    EQU     35      ; Wait delay from nfets off to pfets on
                +1           ADC_LIMIT_L                             EQU 85  ; Power supply measurement ADC value for wh
                             ich main motor power is limited (low byte)
                +1           ADC_LIMIT_H                             EQU     0       ; Power supply measurement ADC valu
                             e for which main motor power is limited (2 MSBs)
                +1           TEMP_LIMIT                              EQU 103 ; Temperature measurement ADC value for whi
                             ch main motor power is limited (low byte, assuming high byte is 1)
                +1           TEMP_LIMIT_STEP                 EQU     4       ; Temperature measurement ADC value increme
                             nt for which main motor power is further limited
                +1           
                +1           ;**** **** **** **** ****
                +1           ; ESC specific defaults
                +1           ;**** **** **** **** ****
                +1           DEFAULT_PGM_MAIN_SPOOLUP_TIME           EQU 7   ; Main motor spoolup time
                +1           DEFAULT_PGM_MAIN_STARTUP_PWR            EQU 11  ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           DEFAULT_PGM_TAIL_STARTUP_PWR            EQU 11  ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           DEFAULT_PGM_MULTI_STARTUP_PWR           EQU 11  ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           
                +1           ;**** **** **** **** ****
                +1           ; Bootloader definitions
                +1           ;**** **** **** **** ****
                +1           RTX_PORT                                EQU P0          ; Receive/Transmit port
                +1           RTX_MDOUT                               EQU     P0MDOUT ; Set to 1 for PUSHPULL            
                                          
                +1           RTX_MDIN                                EQU     P0MDIN  ; Set to 1 for DIGITAL             
                                          
                +1           RTX_SKIP                                EQU     P0SKIP  ; Set to 1 for SKIP                
                                          
                +1           RTX_PIN                                 EQU 5           ; RTX pin
                +1           
                +1           SIGNATURE_001                   EQU     0f8h    ; Device signature
                +1           SIGNATURE_002                   EQU     050h
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 0 definitions *
                +1           ;*********************  
                +1           ;                       EQU     7       ;i (Temp)
                +1           Adc_Ip          EQU     6       ;i
                +1           Rcp_In          EQU     5       ;i
                +1           ;                       EQU     4       ;i (Rcp 1k)
                +1           Mux_C           EQU     3       ;i
                +1           Mux_B           EQU     2       ;i
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE     8

                +1           Mux_A           EQU     1       ;i
                +1           Comp_Com        EQU     0       ;i
                +1           
                +1           P0_DIGITAL      EQU     NOT((1 SHL Mux_A)+(1 SHL Mux_B)+(1 SHL Mux_C)+(1 SHL Comp_Com)+(1 S
                             HL Adc_Ip))
                +1           P0_INIT         EQU     0FFh
                +1           P0_PUSHPULL     EQU     0
                +1           P0_SKIP         EQU     NOT(1 SHL Rcp_In) AND 0FFh
                +1           
                +1           Get_Rcp_Capture_Values MACRO
                +1                   mov     Temp1, PCA0CPL0                 ; Get PCA capture values
                +1                   mov     Temp2, PCA0CPH0
                +1           ENDM
                +1           Read_Rcp_Int MACRO
                +1                   mov     A, P0
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+4)   ; Is pwm polarity negative?
                +1                   cpl     A                                               ; Yes - invert
                +1           ENDM
                +1           Rcp_Int_Enable MACRO
                +1                   orl     PCA0CPM0, #01h                          ; Interrupt enabled
                +1           ENDM
                +1           Rcp_Int_Disable MACRO
                +1                   anl     PCA0CPM0, #0FEh                 ; Interrupt disabled
                +1           ENDM
                +1           Rcp_Int_First MACRO
                +1                   anl     PCA0CPM0, #0CFh                 
                +1                   jb      Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity positive?
                +1                   orl     PCA0CPM0, #20h                          ; Capture rising edge
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity negative?
                +1                   orl     PCA0CPM0, #10h                          ; Capture falling edge
                +1           ENDM
                +1           Rcp_Int_Second MACRO
                +1                   anl     PCA0CPM0, #0CFh                 
                +1                   jb      Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity positive?
                +1                   orl     PCA0CPM0, #10h                          ; Capture falling edge
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity negative?
                +1                   orl     PCA0CPM0, #20h                          ; Capture rising edge
                +1           ENDM
                +1           Rcp_Clear_Int_Flag MACRO
                +1                   clr     CCF0                                            ; Clear interrupt flag
                +1           ENDM            
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 1 definitions *
                +1           ;*********************
                +1           ;                       EQU     7       ;i
                +1           ;                       EQU     6       ;i
                +1           CnFET           EQU     5       ;o
                +1           CpFET           EQU     4       ;o
                +1           BnFET           EQU     3       ;o
                +1           BpFET           EQU     2       ;o
                +1           AnFET           EQU     1       ;o
                +1           ApFET           EQU     0       ;o
                +1           
                +1           P1_DIGITAL      EQU     (1 SHL AnFET)+(1 SHL BnFET)+(1 SHL CnFET)+(1 SHL ApFET)+(1 SHL BpFE
                             T)+(1 SHL CpFET)
                +1           P1_INIT         EQU 0           
                +1           P1_PUSHPULL     EQU     (1 SHL AnFET)+(1 SHL BnFET)+(1 SHL CnFET)+(1 SHL ApFET)+(1 SHL BpFE
                             T)+(1 SHL CpFET)
                +1           P1_SKIP         EQU     0
                +1           
                +1           AnFET_on MACRO
                +1                   setb    P1.AnFET
                +1           ENDM
                +1           AnFET_off MACRO
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE     9

                +1                   clr     P1.AnFET
                +1           ENDM
                +1           BnFET_on MACRO
                +1                   setb    P1.BnFET
                +1           ENDM
                +1           BnFET_off MACRO
                +1                   clr     P1.BnFET
                +1           ENDM
                +1           CnFET_on MACRO
                +1                   setb    P1.CnFET
                +1           ENDM
                +1           CnFET_off MACRO
                +1                   clr     P1.CnFET
                +1           ENDM
                +1           All_nFETs_Off MACRO
                +1                   clr     P1.AnFET
                +1                   clr     P1.BnFET
                +1                   clr     P1.CnFET
                +1           ENDM
                +1           
                +1           ApFET_on MACRO
                +1                   setb    P1.ApFET
                +1           ENDM
                +1           ApFET_off MACRO
                +1                   clr     P1.ApFET
                +1           ENDM
                +1           BpFET_on MACRO
                +1                   setb    P1.BpFET
                +1           ENDM
                +1           BpFET_off MACRO
                +1                   clr     P1.BpFET
                +1           ENDM
                +1           CpFET_on MACRO
                +1                   setb    P1.CpFET
                +1           ENDM
                +1           CpFET_off MACRO
                +1                   clr     P1.CpFET
                +1           ENDM
                +1           All_pFETs_Off MACRO
                +1                   clr     P1.ApFET
                +1                   clr     P1.BpFET
                +1                   clr     P1.CpFET
                +1           ENDM
                +1           
                +1           Brake_FETs_On MACRO
                +1                   AnFET_on
                +1                   BnFET_on
                +1                   CnFET_on
                +1           ENDM
                +1           Damping_FET_On MACRO
                +1                   mov     A, DampingFET
                +1                   orl     P1, A
                +1           ENDM
                +1           
                +1           Set_Comp_Phase_A MACRO
                +1                   mov     CPT0MX, #01h    ; Set comparator multiplexer to phase A
                +1           ENDM
                +1           Set_Comp_Phase_B MACRO
                +1                   mov     CPT0MX, #02h    ; Set comparator multiplexer to phase B
                +1           ENDM
                +1           Set_Comp_Phase_C MACRO
                +1                   mov     CPT0MX, #03h    ; Set comparator multiplexer to phase C
                +1           ENDM
                +1           Read_Comp_Out MACRO
                +1                   mov     A, CPT0CN               ; Read comparator output
                +1           ENDM
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    10

                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 2 definitions *
                +1           ;*********************
                +1           DebugPin                EQU     0       ;o
                +1           
                +1           P2_PUSHPULL     EQU     (1 SHL DebugPin)
                +1           
                +1           
                +1           ;**********************
                +1           ; MCU specific s *
                +1           ;**********************
                +1           Interrupt_Table_Definition MACRO
                +1           CSEG AT 0                               ; Code segment start
                +1                   jmp reset
                +1           CSEG AT 0Bh                     ; Timer0 interrupt      
                +1                   jmp     t0_int  
                +1           CSEG AT 2Bh                     ; Timer2 interrupt      
                +1                   jmp     t2_int  
                +1           CSEG AT 5Bh                     ; PCA interrupt 
                +1                   jmp     pca_int 
                +1           CSEG AT 73h                     ; Timer3 interrupt      
                +1                   jmp     t3_int  
                +1           ENDM
                +1           
                +1           Initialize_Xbar MACRO
                +1                   mov     XBR2, #40h      ; Xbar enabled                  
                +1                   mov     XBR1, #01h      ; CEX0 routed to pin Rcp_In                     
                +1           ENDM
                +1           
                +1           Initialize_Adc MACRO
                +1                   mov     REF0CN, #0Ch    ; Set vdd (3.3V) as reference. Enable temp sensor and bias
                +1                   mov     ADC0CF, #59h    ; ADC clock 2MHz, PGA gain 1
                +1                   mov     ADC0MX, #Adc_Ip; Select ADC input
                +1                   mov     ADC0CN0, #80h   ; ADC enabled 
                +1                   mov     ADC0CN1, #01h   ; Common mode buffer enabled
                +1           ENDM
                +1           Set_Adc_Ip_Volt MACRO
                +1                   mov     ADC0MX, #Adc_Ip; Select ADC input
                +1           ENDM
                +1           Set_Adc_Ip_Temp MACRO
                +1                   mov     ADC0MX, #10h    ; Select temp sensor input
                +1           ENDM
                +1           Start_Adc MACRO
                +1                   mov     ADC0CN0, #90h   ; ADC start
                +1           ENDM
                +1           Read_Adc_Result MACRO
                +1                   mov     Temp1, ADC0L
                +1                   mov     Temp2, ADC0H
                +1           ENDM
                +1           Stop_Adc MACRO
                +1           ENDM
                +1           Set_RPM_Out MACRO
                +1           ENDM
                +1           Clear_RPM_Out MACRO
                +1           ENDM
                +1           Set_MCU_Clk_24MHz MACRO
                +1           ENDM
                +1           Set_MCU_Clk_48MHz MACRO
                +1           ENDM
                             ENDIF
                     621     
                     622     IF BESCNO == Flycolor_Fairy_6A_Tail
                             MODE    EQU     1                               ; Choose mode. Set to 1 for tail motor
                             ;$include (Flycolor_Fairy_6A.inc) ; Select Flycolor Fairy 6A pinout
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    11

                +1           ;**** **** **** **** ****
                +1           ;
                +1           ; BLHeli program for controlling brushless motors in helicopters and multirotors
                +1           ;
                +1           ; Copyright 2011, 2012 Steffen Skaug
                +1           ; This program is distributed under the terms of the GNU General Public License
                +1           ;
                +1           ; This file is part of BLHeli.
                +1           ;
                +1           ; BLHeli is free software: you can redistribute it and/or modify
                +1           ; it under the terms of the GNU General Public License as published by
                +1           ; the Free Software Foundation, either version 3 of the License, or
                +1           ; (at your option) any later version.
                +1           ;
                +1           ; BLHeli is distributed in the hope that it will be useful,
                +1           ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                +1           ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                +1           ; GNU General Public License for more details.
                +1           ;
                +1           ; You should have received a copy of the GNU General Public License
                +1           ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                +1           ;
                +1           ;**** **** **** **** ****
                +1           ;
                +1           ; Flycolor Fairy 6A hardware definition file
                +1           ;
                +1           ;**** **** **** **** ****
                +1           
                +1           
                +1           
                +1           ;*********************
                +1           ; Device SiLabs F850
                +1           ;*********************
                +1           ;$include (c8051f850.inc)
                +2           ; PAGE DEFINITIONS
                +2           ACTIVE_PAGE          EQU 000H
                +2           DEBUG_PAGE           EQU 001H
                +2           
                +2           ; SFR ADDRESSES BEGIN
                +2           ADC0AC               DATA 0B3H ; ACTIVE
                +2           ADC0CF               DATA 0BCH ; ACTIVE
                +2           ADC0CN0              DATA 0E8H ; ACTIVE
                +2           ADC0CN1              DATA 0B2H ; ACTIVE
                +2           ADC0GTH              DATA 0C4H ; ACTIVE
                +2           ADC0GTL              DATA 0C3H ; ACTIVE
                +2           ADC0H                DATA 0BEH ; ACTIVE
                +2           ADC0L                DATA 0BDH ; ACTIVE
                +2           ADC0LTH              DATA 0C6H ; ACTIVE
                +2           ADC0LTL              DATA 0C5H ; ACTIVE
                +2           ADC0MX               DATA 0BBH ; ACTIVE
                +2           ADC0PWR              DATA 0DFH ; ACTIVE
                +2           ADC0TK               DATA 0B9H ; ACTIVE
                +2           ACC                  DATA 0E0H ;
                +2           B                    DATA 0F0H ;
                +2           DPH                  DATA 083H ;
                +2           DPL                  DATA 082H ;
                +2           PCON                 DATA 087H ;
                +2           PSW                  DATA 0D0H ;
                +2           SP                   DATA 081H ;
                +2           CRC0AUTO             DATA 0D2H ; ACTIVE
                +2           CRC0CN               DATA 0CEH ; ACTIVE
                +2           CRC0CNT              DATA 0D3H ; ACTIVE
                +2           CRC0DAT              DATA 0DEH ; ACTIVE
                +2           CRC0FLIP             DATA 0CFH ; ACTIVE
                +2           CRC0IN               DATA 0DDH ; ACTIVE
                +2           CPT0CN               DATA 09BH ; ACTIVE
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    12

                +2           CPT0MD               DATA 09DH ; ACTIVE
                +2           CPT0MX               DATA 09FH ; ACTIVE
                +2           CPT1CN               DATA 0BFH ; ACTIVE
                +2           CPT1MD               DATA 0ABH ; ACTIVE
                +2           CPT1MX               DATA 0AAH ; ACTIVE
                +2           DERIVID              DATA 0ADH ; ACTIVE
                +2           DEVICEID             DATA 0B5H ; ACTIVE
                +2           FLSCL                DATA 09AH ; ACTIVE
                +2           REVID                DATA 0B6H ; ACTIVE
                +2           FLKEY                DATA 0B7H ;
                +2           PSCTL                DATA 08FH ;
                +2           EIE1                 DATA 0E6H ;
                +2           EIP1                 DATA 0F3H ; ACTIVE
                +2           IE                   DATA 0A8H ;
                +2           IP                   DATA 0B8H ;
                +2           IT01CF               DATA 0E4H ; ACTIVE
                +2           CKCON                DATA 08EH ; ACTIVE
                +2           CLKSEL               DATA 0A9H ;
                +2           OSCLCN               DATA 0B1H ; ACTIVE
                +2           OSCICL               DATA 0C7H ; ACTIVE
                +2           PCA0CENT             DATA 09EH ; ACTIVE
                +2           PCA0CLR              DATA 09CH ; ACTIVE
                +2           PCA0CN               DATA 0D8H ; ACTIVE
                +2           PCA0CPH0             DATA 0FCH ; ACTIVE
                +2           PCA0CPH1             DATA 0EAH ; ACTIVE
                +2           PCA0CPH2             DATA 0ECH ; ACTIVE
                +2           PCA0CPL0             DATA 0FBH ; ACTIVE
                +2           PCA0CPL1             DATA 0E9H ; ACTIVE
                +2           PCA0CPL2             DATA 0EBH ; ACTIVE
                +2           PCA0CPM0             DATA 0DAH ; ACTIVE
                +2           PCA0CPM1             DATA 0DBH ; ACTIVE
                +2           PCA0CPM2             DATA 0DCH ; ACTIVE
                +2           PCA0H                DATA 0FAH ; ACTIVE
                +2           PCA0L                DATA 0F9H ; ACTIVE
                +2           PCA0MD               DATA 0D9H ; ACTIVE
                +2           PCA0POL              DATA 096H ; ACTIVE
                +2           PCA0PWM              DATA 0F7H ; ACTIVE
                +2           P0                   DATA 080H ;
                +2           P0MASK               DATA 0FEH ; ACTIVE
                +2           P0MAT                DATA 0FDH ; ACTIVE
                +2           P0MDIN               DATA 0F1H ; ACTIVE
                +2           P0MDOUT              DATA 0A4H ; ACTIVE
                +2           P0SKIP               DATA 0D4H ; ACTIVE
                +2           P1                   DATA 090H ; ACTIVE
                +2           P1MASK               DATA 0EEH ; ACTIVE
                +2           P1MAT                DATA 0EDH ; ACTIVE
                +2           P1MDIN               DATA 0F2H ; ACTIVE
                +2           P1MDOUT              DATA 0A5H ; ACTIVE
                +2           P1SKIP               DATA 0D5H ; ACTIVE
                +2           P2                   DATA 0A0H ;
                +2           P2MDOUT              DATA 0A6H ; ACTIVE
                +2           PRTDRV               DATA 0F6H ; ACTIVE
                +2           XBR0                 DATA 0E1H ; ACTIVE
                +2           XBR1                 DATA 0E2H ; ACTIVE
                +2           XBR2                 DATA 0E3H ; ACTIVE
                +2           RSTSRC               DATA 0EFH ; ACTIVE
                +2           SMB0ADM              DATA 0D6H ; ACTIVE
                +2           SMB0ADR              DATA 0D7H ; ACTIVE
                +2           SMB0CF               DATA 0C1H ; ACTIVE
                +2           SMB0CN               DATA 0C0H ; ACTIVE
                +2           SMB0DAT              DATA 0C2H ; ACTIVE
                +2           SMB0TC               DATA 0ACH ; ACTIVE
                +2           SPI0CFG              DATA 0A1H ; ACTIVE
                +2           SPI0CKR              DATA 0A2H ; ACTIVE
                +2           SPI0CN               DATA 0F8H ; ACTIVE
                +2           SPI0DAT              DATA 0A3H ; ACTIVE
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    13

                +2           TCON                 DATA 088H ; ACTIVE
                +2           TH0                  DATA 08CH ; ACTIVE
                +2           TH1                  DATA 08DH ; ACTIVE
                +2           TL0                  DATA 08AH ; ACTIVE
                +2           TL1                  DATA 08BH ; ACTIVE
                +2           TMOD                 DATA 089H ; ACTIVE
                +2           TMR2CN               DATA 0C8H ;
                +2           TMR2H                DATA 0CDH ; ACTIVE
                +2           TMR2L                DATA 0CCH ; ACTIVE
                +2           TMR2RLH              DATA 0CBH ; ACTIVE
                +2           TMR2RLL              DATA 0CAH ; ACTIVE
                +2           TMR3CN               DATA 091H ; ACTIVE
                +2           TMR3H                DATA 095H ; ACTIVE
                +2           TMR3L                DATA 094H ; ACTIVE
                +2           TMR3RLH              DATA 093H ; ACTIVE
                +2           TMR3RLL              DATA 092H ; ACTIVE
                +2           SBUF0                DATA 099H ; ACTIVE
                +2           SCON0                DATA 098H ;
                +2           REF0CN               DATA 0D1H ; ACTIVE
                +2           REG0CN               DATA 0C9H ; ACTIVE
                +2           VDM0CN               DATA 0FFH ; ACTIVE
                +2           WDTCN                DATA 097H ;
                +2           ; SFR ADDRESSES END
                +2           
                +2           ; BIT DEFINITIONS
                +2           
                +2           ; ADC0CN0 0xE8
                +2           AD0EN                BIT  ADC0CN0.7   ;
                +2           BURSTEN              BIT  ADC0CN0.6   ;
                +2           AD0INT               BIT  ADC0CN0.5   ;
                +2           AD0BUSY              BIT  ADC0CN0.4   ;
                +2           AD0WINT              BIT  ADC0CN0.3   ;
                +2           ADC0M2               BIT  ADC0CN0.2   ;
                +2           ADC0M1               BIT  ADC0CN0.1   ;
                +2           ADC0M0               BIT  ADC0CN0.0   ;
                +2           
                +2           ; IE 0xA8
                +2           EA                   BIT  IE.7        ; Global Interrupt Enable
                +2           ESPI0                BIT  IE.6        ; Serial Peripheral Interface Enable
                +2           ET2                  BIT  IE.5        ; Timer 2 Interrupt Enable
                +2           ES0                  BIT  IE.4        ; Serial Port Interrupt Enable
                +2           ET1                  BIT  IE.3        ; Timer 1 Interrupt Enable
                +2           EX1                  BIT  IE.2        ; External Interrupt Enable
                +2           ET0                  BIT  IE.1        ; Timer 0 Interrupt Enable
                +2           EX0                  BIT  IE.0        ; External Interrupt 0 Enable
                +2           
                +2           ; IP 0xB8
                +2                                                 ; bit 7 UNUSED
                +2           PSPI0                BIT  IP.6        ; Serial Peripheral Interface Priority
                +2           PT2                  BIT  IP.5        ; Timer 2 Priority
                +2           PS0                  BIT  IP.4        ; Serial Port Priority
                +2           PT1                  BIT  IP.3        ; Timer 1 Priority
                +2           PX1                  BIT  IP.2        ; External Interrupt 1 Priority
                +2           PT0                  BIT  IP.1        ; Timer 0 Priority
                +2           PX0                  BIT  IP.0        ; External Interrupt 0 Priority
                +2           
                +2           ; PCA0CN 0xD8
                +2           CF                   BIT  PCA0CN.7    ; PCA 0 Counter Overflow Flag
                +2           CR                   BIT  PCA0CN.6    ; PCA 0 Counter Run Control Bit
                +2                                                 ; bit 5 UNUSED
                +2                                                 ; bit 4 UNUSED
                +2                                                 ; bit 3 UNUSED
                +2           CCF2                 BIT  PCA0CN.2    ; PCA 0 Module 2 Interrupt Flag
                +2           CCF1                 BIT  PCA0CN.1    ; PCA 0 Module 1 Interrupt Flag
                +2           CCF0                 BIT  PCA0CN.0    ; PCA 0 Module 0 Interrupt Flag
                +2           
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    14

                +2           ; PSW 0xD0
                +2           CY                   BIT  PSW.7       ; Carry Flag
                +2           AC                   BIT  PSW.6       ; Auxiliary Carry Flag
                +2           F0                   BIT  PSW.5       ; User Flag 0
                +2           RS1                  BIT  PSW.4       ; Register Bank Select 1
                +2           RS0                  BIT  PSW.3       ; Register Bank Select 0
                +2           OV                   BIT  PSW.2       ; Overflow Flag
                +2           F1                   BIT  PSW.1       ; User Flag 1
                +2           P                    BIT  PSW.0       ; Accumulator Parity Flag
                +2           
                +2           ; SCON0 0x98
                +2           S0MODE               BIT  SCON0.7     ; Serial Mode Control Bit 0
                +2                                                 ; bit 6 UNUSED
                +2           MCE0                 BIT  SCON0.5     ; Multiprocessor Communication Enable
                +2           REN0                 BIT  SCON0.4     ; Receive Enable
                +2           TB80                 BIT  SCON0.3     ; Transmit Bit 8
                +2           RB80                 BIT  SCON0.2     ; Receive Bit 8
                +2           TI0                  BIT  SCON0.1     ; Transmit Interrupt Flag
                +2           RI0                  BIT  SCON0.0     ; Receive Interrupt Flag
                +2           
                +2           ; SMB0CN 0xC0
                +2           MASTER0              BIT  SMB0CN.7    ; SMBus Master/Slave Indicator
                +2           TXMODE0              BIT  SMB0CN.6    ; SMBus Transmit Mode Indicator
                +2           STA0                 BIT  SMB0CN.5    ; SMBus Start Flag
                +2           STO0                 BIT  SMB0CN.4    ; SMBus Stop Flag
                +2           ACKRQ0               BIT  SMB0CN.3    ; SMBus Acknowledge Request
                +2           ARBLOST0             BIT  SMB0CN.2    ; SMBus Arbitration Lost Indicator
                +2           ACK0                 BIT  SMB0CN.1    ; SMBus Acknowledge
                +2           SI0                  BIT  SMB0CN.0    ; SMBus Interrupt
                +2           
                +2           ; SPI0CN 0xF8
                +2           SPIF                 BIT  SPI0CN.7    ; SPI 0 Interrupt Flag
                +2           WCOL                 BIT  SPI0CN.6    ; SPI 0 Write Collision Flag
                +2           MODF                 BIT  SPI0CN.5    ; SPI 0 Mode Fault Flag
                +2           RXOVRN               BIT  SPI0CN.4    ; SPI 0 RX Overrun Flag
                +2           NSSMD1               BIT  SPI0CN.3    ; SPI 0 NSS Mode Bit 1
                +2           NSSMD0               BIT  SPI0CN.2    ; SPI 0 NSS Mode Bit 0
                +2           TXBMT                BIT  SPI0CN.1    ; SPI 0 Transmit Buffer Empty Flag
                +2           SPIEN                BIT  SPI0CN.0    ; SPI 0 SPI Enable
                +2           
                +2           ; TCON 0x88
                +2           TF1                  BIT  TCON.7      ; Timer 1 Overflow Flag
                +2           TR1                  BIT  TCON.6      ; Timer 1 On/Off Control
                +2           TF0                  BIT  TCON.5      ; Timer 0 Overflow Flag
                +2           TR0                  BIT  TCON.4      ; Timer 0 On/Off Control
                +2           IE1                  BIT  TCON.3      ; Ext. Interrupt 1 Edge Flag
                +2           IT1                  BIT  TCON.2      ; Ext. Interrupt 1 Type
                +2           IE0                  BIT  TCON.1      ; Ext. Interrupt 0 Edge Flag
                +2           IT0                  BIT  TCON.0      ; Ext. Interrupt 0 Type
                +2           
                +2           ; TMR2CN 0xC8
                +2           TF2H                 BIT  TMR2CN.7    ; T2 High-Byte Overflow Flag
                +2           TF2L                 BIT  TMR2CN.6    ; T2 Low-Byte Overflow Flag
                +2           TF2LEN               BIT  TMR2CN.5    ; T2 Low Byte Interrupt Enable
                +2           TF2CEN               BIT  TMR2CN.4    ; T2 Input Capture Enable
                +2           T2SPLIT              BIT  TMR2CN.3    ; T2 Split-Mode Enable
                +2           TR2                  BIT  TMR2CN.2    ; Timer 2 On/Off Control
                +2                                                 ; bit 1 UNUSED
                +2           T2XCLK               BIT  TMR2CN.0    ; T2 External Clock Select
                +1           
                +1           
                +1           ;**** **** **** **** ****
                +1           ; Uses internal calibrated oscillator set to 24Mhz
                +1           ;**** **** **** **** ****
                +1           
                +1           ;**** **** **** **** ****
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    15

                +1           ; Constant definitions
                +1           ;**** **** **** **** ****
                +1           CSEG AT 1A40h
                +1           Eep_ESC_Layout:                 DB      "#FC_Fairy_6A#   "      ; ESC layout tag
                +1           CSEG AT 1A50h
                +1           Eep_ESC_MCU:                    DB      "#BLHELI#F850#   "      ; Project and MCU tag (16 B
                             ytes)
                +1           
                +1           MCU_48MHZ                               EQU     0       ; Set to 1 if MCU can run at 48MHz
                +1           ONE_S_CAPABLE                   EQU     0       ; Set to 1 if ESC can operate at 1S
                +1           PORT3_EXIST                             EQU     0       ; Set to 1 if MCU has port3
                +1           COMP1_USED                              EQU     0       ; Set to 1 if MCU has comparator 1 
                             and it is being used
                +1           LOCK_BYTE_ADDRESS_16K   EQU     3FFFh   ; Address of lock byte if 16k flash size
                +1           LOCK_BYTE_ADDRESS_8K    EQU     1FFFh   ; Address of lock byte if 8k flash size
                +1           HIGH_BEC_VOLTAGE                EQU     0       ; Set to 1 or more if high BEC voltage is s
                             upported
                +1           DAMPED_MODE_ENABLE              EQU     0       ; Damped mode disabled
                +1           NFETON_DELAY                    EQU     6       ; Wait delay from pfets off to nfets on
                +1           PFETON_DELAY                    EQU     35      ; Wait delay from nfets off to pfets on
                +1           ADC_LIMIT_L                             EQU 85  ; Power supply measurement ADC value for wh
                             ich main motor power is limited (low byte)
                +1           ADC_LIMIT_H                             EQU     0       ; Power supply measurement ADC valu
                             e for which main motor power is limited (2 MSBs)
                +1           TEMP_LIMIT                              EQU 103 ; Temperature measurement ADC value for whi
                             ch main motor power is limited (low byte, assuming high byte is 1)
                +1           TEMP_LIMIT_STEP                 EQU     4       ; Temperature measurement ADC value increme
                             nt for which main motor power is further limited
                +1           
                +1           ;**** **** **** **** ****
                +1           ; ESC specific defaults
                +1           ;**** **** **** **** ****
                +1           DEFAULT_PGM_MAIN_SPOOLUP_TIME           EQU 7   ; Main motor spoolup time
                +1           DEFAULT_PGM_MAIN_STARTUP_PWR            EQU 11  ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           DEFAULT_PGM_TAIL_STARTUP_PWR            EQU 11  ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           DEFAULT_PGM_MULTI_STARTUP_PWR           EQU 11  ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           
                +1           ;**** **** **** **** ****
                +1           ; Bootloader definitions
                +1           ;**** **** **** **** ****
                +1           RTX_PORT                                EQU P0          ; Receive/Transmit port
                +1           RTX_MDOUT                               EQU     P0MDOUT ; Set to 1 for PUSHPULL            
                                          
                +1           RTX_MDIN                                EQU     P0MDIN  ; Set to 1 for DIGITAL             
                                          
                +1           RTX_SKIP                                EQU     P0SKIP  ; Set to 1 for SKIP                
                                          
                +1           RTX_PIN                                 EQU 5           ; RTX pin
                +1           
                +1           SIGNATURE_001                   EQU     0f8h    ; Device signature
                +1           SIGNATURE_002                   EQU     050h
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 0 definitions *
                +1           ;*********************  
                +1           ;                       EQU     7       ;i (Temp)
                +1           Adc_Ip          EQU     6       ;i
                +1           Rcp_In          EQU     5       ;i
                +1           ;                       EQU     4       ;i (Rcp 1k)
                +1           Mux_C           EQU     3       ;i
                +1           Mux_B           EQU     2       ;i
                +1           Mux_A           EQU     1       ;i
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    16

                +1           Comp_Com        EQU     0       ;i
                +1           
                +1           P0_DIGITAL      EQU     NOT((1 SHL Mux_A)+(1 SHL Mux_B)+(1 SHL Mux_C)+(1 SHL Comp_Com)+(1 S
                             HL Adc_Ip))
                +1           P0_INIT         EQU     0FFh
                +1           P0_PUSHPULL     EQU     0
                +1           P0_SKIP         EQU     NOT(1 SHL Rcp_In) AND 0FFh
                +1           
                +1           Get_Rcp_Capture_Values MACRO
                +1                   mov     Temp1, PCA0CPL0                 ; Get PCA capture values
                +1                   mov     Temp2, PCA0CPH0
                +1           ENDM
                +1           Read_Rcp_Int MACRO
                +1                   mov     A, P0
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+4)   ; Is pwm polarity negative?
                +1                   cpl     A                                               ; Yes - invert
                +1           ENDM
                +1           Rcp_Int_Enable MACRO
                +1                   orl     PCA0CPM0, #01h                          ; Interrupt enabled
                +1           ENDM
                +1           Rcp_Int_Disable MACRO
                +1                   anl     PCA0CPM0, #0FEh                 ; Interrupt disabled
                +1           ENDM
                +1           Rcp_Int_First MACRO
                +1                   anl     PCA0CPM0, #0CFh                 
                +1                   jb      Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity positive?
                +1                   orl     PCA0CPM0, #20h                          ; Capture rising edge
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity negative?
                +1                   orl     PCA0CPM0, #10h                          ; Capture falling edge
                +1           ENDM
                +1           Rcp_Int_Second MACRO
                +1                   anl     PCA0CPM0, #0CFh                 
                +1                   jb      Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity positive?
                +1                   orl     PCA0CPM0, #10h                          ; Capture falling edge
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity negative?
                +1                   orl     PCA0CPM0, #20h                          ; Capture rising edge
                +1           ENDM
                +1           Rcp_Clear_Int_Flag MACRO
                +1                   clr     CCF0                                            ; Clear interrupt flag
                +1           ENDM            
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 1 definitions *
                +1           ;*********************
                +1           ;                       EQU     7       ;i
                +1           ;                       EQU     6       ;i
                +1           CnFET           EQU     5       ;o
                +1           CpFET           EQU     4       ;o
                +1           BnFET           EQU     3       ;o
                +1           BpFET           EQU     2       ;o
                +1           AnFET           EQU     1       ;o
                +1           ApFET           EQU     0       ;o
                +1           
                +1           P1_DIGITAL      EQU     (1 SHL AnFET)+(1 SHL BnFET)+(1 SHL CnFET)+(1 SHL ApFET)+(1 SHL BpFE
                             T)+(1 SHL CpFET)
                +1           P1_INIT         EQU 0           
                +1           P1_PUSHPULL     EQU     (1 SHL AnFET)+(1 SHL BnFET)+(1 SHL CnFET)+(1 SHL ApFET)+(1 SHL BpFE
                             T)+(1 SHL CpFET)
                +1           P1_SKIP         EQU     0
                +1           
                +1           AnFET_on MACRO
                +1                   setb    P1.AnFET
                +1           ENDM
                +1           AnFET_off MACRO
                +1                   clr     P1.AnFET
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    17

                +1           ENDM
                +1           BnFET_on MACRO
                +1                   setb    P1.BnFET
                +1           ENDM
                +1           BnFET_off MACRO
                +1                   clr     P1.BnFET
                +1           ENDM
                +1           CnFET_on MACRO
                +1                   setb    P1.CnFET
                +1           ENDM
                +1           CnFET_off MACRO
                +1                   clr     P1.CnFET
                +1           ENDM
                +1           All_nFETs_Off MACRO
                +1                   clr     P1.AnFET
                +1                   clr     P1.BnFET
                +1                   clr     P1.CnFET
                +1           ENDM
                +1           
                +1           ApFET_on MACRO
                +1                   setb    P1.ApFET
                +1           ENDM
                +1           ApFET_off MACRO
                +1                   clr     P1.ApFET
                +1           ENDM
                +1           BpFET_on MACRO
                +1                   setb    P1.BpFET
                +1           ENDM
                +1           BpFET_off MACRO
                +1                   clr     P1.BpFET
                +1           ENDM
                +1           CpFET_on MACRO
                +1                   setb    P1.CpFET
                +1           ENDM
                +1           CpFET_off MACRO
                +1                   clr     P1.CpFET
                +1           ENDM
                +1           All_pFETs_Off MACRO
                +1                   clr     P1.ApFET
                +1                   clr     P1.BpFET
                +1                   clr     P1.CpFET
                +1           ENDM
                +1           
                +1           Brake_FETs_On MACRO
                +1                   AnFET_on
                +1                   BnFET_on
                +1                   CnFET_on
                +1           ENDM
                +1           Damping_FET_On MACRO
                +1                   mov     A, DampingFET
                +1                   orl     P1, A
                +1           ENDM
                +1           
                +1           Set_Comp_Phase_A MACRO
                +1                   mov     CPT0MX, #01h    ; Set comparator multiplexer to phase A
                +1           ENDM
                +1           Set_Comp_Phase_B MACRO
                +1                   mov     CPT0MX, #02h    ; Set comparator multiplexer to phase B
                +1           ENDM
                +1           Set_Comp_Phase_C MACRO
                +1                   mov     CPT0MX, #03h    ; Set comparator multiplexer to phase C
                +1           ENDM
                +1           Read_Comp_Out MACRO
                +1                   mov     A, CPT0CN               ; Read comparator output
                +1           ENDM
                +1           
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    18

                +1           
                +1           ;*********************
                +1           ; PORT 2 definitions *
                +1           ;*********************
                +1           DebugPin                EQU     0       ;o
                +1           
                +1           P2_PUSHPULL     EQU     (1 SHL DebugPin)
                +1           
                +1           
                +1           ;**********************
                +1           ; MCU specific s *
                +1           ;**********************
                +1           Interrupt_Table_Definition MACRO
                +1           CSEG AT 0                               ; Code segment start
                +1                   jmp reset
                +1           CSEG AT 0Bh                     ; Timer0 interrupt      
                +1                   jmp     t0_int  
                +1           CSEG AT 2Bh                     ; Timer2 interrupt      
                +1                   jmp     t2_int  
                +1           CSEG AT 5Bh                     ; PCA interrupt 
                +1                   jmp     pca_int 
                +1           CSEG AT 73h                     ; Timer3 interrupt      
                +1                   jmp     t3_int  
                +1           ENDM
                +1           
                +1           Initialize_Xbar MACRO
                +1                   mov     XBR2, #40h      ; Xbar enabled                  
                +1                   mov     XBR1, #01h      ; CEX0 routed to pin Rcp_In                     
                +1           ENDM
                +1           
                +1           Initialize_Adc MACRO
                +1                   mov     REF0CN, #0Ch    ; Set vdd (3.3V) as reference. Enable temp sensor and bias
                +1                   mov     ADC0CF, #59h    ; ADC clock 2MHz, PGA gain 1
                +1                   mov     ADC0MX, #Adc_Ip; Select ADC input
                +1                   mov     ADC0CN0, #80h   ; ADC enabled 
                +1                   mov     ADC0CN1, #01h   ; Common mode buffer enabled
                +1           ENDM
                +1           Set_Adc_Ip_Volt MACRO
                +1                   mov     ADC0MX, #Adc_Ip; Select ADC input
                +1           ENDM
                +1           Set_Adc_Ip_Temp MACRO
                +1                   mov     ADC0MX, #10h    ; Select temp sensor input
                +1           ENDM
                +1           Start_Adc MACRO
                +1                   mov     ADC0CN0, #90h   ; ADC start
                +1           ENDM
                +1           Read_Adc_Result MACRO
                +1                   mov     Temp1, ADC0L
                +1                   mov     Temp2, ADC0H
                +1           ENDM
                +1           Stop_Adc MACRO
                +1           ENDM
                +1           Set_RPM_Out MACRO
                +1           ENDM
                +1           Clear_RPM_Out MACRO
                +1           ENDM
                +1           Set_MCU_Clk_24MHz MACRO
                +1           ENDM
                +1           Set_MCU_Clk_48MHz MACRO
                +1           ENDM
                             ENDIF
                    1132     
                    1133     IF BESCNO == Flycolor_Fairy_6A_Multi
                             MODE    EQU     2                               ; Choose mode. Set to 2 for multirotor
                             ;$include (Flycolor_Fairy_6A.inc) ; Select Flycolor Fairy 6A pinout
                +1           ;**** **** **** **** ****
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    19

                +1           ;
                +1           ; BLHeli program for controlling brushless motors in helicopters and multirotors
                +1           ;
                +1           ; Copyright 2011, 2012 Steffen Skaug
                +1           ; This program is distributed under the terms of the GNU General Public License
                +1           ;
                +1           ; This file is part of BLHeli.
                +1           ;
                +1           ; BLHeli is free software: you can redistribute it and/or modify
                +1           ; it under the terms of the GNU General Public License as published by
                +1           ; the Free Software Foundation, either version 3 of the License, or
                +1           ; (at your option) any later version.
                +1           ;
                +1           ; BLHeli is distributed in the hope that it will be useful,
                +1           ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                +1           ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                +1           ; GNU General Public License for more details.
                +1           ;
                +1           ; You should have received a copy of the GNU General Public License
                +1           ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                +1           ;
                +1           ;**** **** **** **** ****
                +1           ;
                +1           ; Flycolor Fairy 6A hardware definition file
                +1           ;
                +1           ;**** **** **** **** ****
                +1           
                +1           
                +1           
                +1           ;*********************
                +1           ; Device SiLabs F850
                +1           ;*********************
                +1           ;$include (c8051f850.inc)
                +2           ; PAGE DEFINITIONS
                +2           ACTIVE_PAGE          EQU 000H
                +2           DEBUG_PAGE           EQU 001H
                +2           
                +2           ; SFR ADDRESSES BEGIN
                +2           ADC0AC               DATA 0B3H ; ACTIVE
                +2           ADC0CF               DATA 0BCH ; ACTIVE
                +2           ADC0CN0              DATA 0E8H ; ACTIVE
                +2           ADC0CN1              DATA 0B2H ; ACTIVE
                +2           ADC0GTH              DATA 0C4H ; ACTIVE
                +2           ADC0GTL              DATA 0C3H ; ACTIVE
                +2           ADC0H                DATA 0BEH ; ACTIVE
                +2           ADC0L                DATA 0BDH ; ACTIVE
                +2           ADC0LTH              DATA 0C6H ; ACTIVE
                +2           ADC0LTL              DATA 0C5H ; ACTIVE
                +2           ADC0MX               DATA 0BBH ; ACTIVE
                +2           ADC0PWR              DATA 0DFH ; ACTIVE
                +2           ADC0TK               DATA 0B9H ; ACTIVE
                +2           ACC                  DATA 0E0H ;
                +2           B                    DATA 0F0H ;
                +2           DPH                  DATA 083H ;
                +2           DPL                  DATA 082H ;
                +2           PCON                 DATA 087H ;
                +2           PSW                  DATA 0D0H ;
                +2           SP                   DATA 081H ;
                +2           CRC0AUTO             DATA 0D2H ; ACTIVE
                +2           CRC0CN               DATA 0CEH ; ACTIVE
                +2           CRC0CNT              DATA 0D3H ; ACTIVE
                +2           CRC0DAT              DATA 0DEH ; ACTIVE
                +2           CRC0FLIP             DATA 0CFH ; ACTIVE
                +2           CRC0IN               DATA 0DDH ; ACTIVE
                +2           CPT0CN               DATA 09BH ; ACTIVE
                +2           CPT0MD               DATA 09DH ; ACTIVE
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    20

                +2           CPT0MX               DATA 09FH ; ACTIVE
                +2           CPT1CN               DATA 0BFH ; ACTIVE
                +2           CPT1MD               DATA 0ABH ; ACTIVE
                +2           CPT1MX               DATA 0AAH ; ACTIVE
                +2           DERIVID              DATA 0ADH ; ACTIVE
                +2           DEVICEID             DATA 0B5H ; ACTIVE
                +2           FLSCL                DATA 09AH ; ACTIVE
                +2           REVID                DATA 0B6H ; ACTIVE
                +2           FLKEY                DATA 0B7H ;
                +2           PSCTL                DATA 08FH ;
                +2           EIE1                 DATA 0E6H ;
                +2           EIP1                 DATA 0F3H ; ACTIVE
                +2           IE                   DATA 0A8H ;
                +2           IP                   DATA 0B8H ;
                +2           IT01CF               DATA 0E4H ; ACTIVE
                +2           CKCON                DATA 08EH ; ACTIVE
                +2           CLKSEL               DATA 0A9H ;
                +2           OSCLCN               DATA 0B1H ; ACTIVE
                +2           OSCICL               DATA 0C7H ; ACTIVE
                +2           PCA0CENT             DATA 09EH ; ACTIVE
                +2           PCA0CLR              DATA 09CH ; ACTIVE
                +2           PCA0CN               DATA 0D8H ; ACTIVE
                +2           PCA0CPH0             DATA 0FCH ; ACTIVE
                +2           PCA0CPH1             DATA 0EAH ; ACTIVE
                +2           PCA0CPH2             DATA 0ECH ; ACTIVE
                +2           PCA0CPL0             DATA 0FBH ; ACTIVE
                +2           PCA0CPL1             DATA 0E9H ; ACTIVE
                +2           PCA0CPL2             DATA 0EBH ; ACTIVE
                +2           PCA0CPM0             DATA 0DAH ; ACTIVE
                +2           PCA0CPM1             DATA 0DBH ; ACTIVE
                +2           PCA0CPM2             DATA 0DCH ; ACTIVE
                +2           PCA0H                DATA 0FAH ; ACTIVE
                +2           PCA0L                DATA 0F9H ; ACTIVE
                +2           PCA0MD               DATA 0D9H ; ACTIVE
                +2           PCA0POL              DATA 096H ; ACTIVE
                +2           PCA0PWM              DATA 0F7H ; ACTIVE
                +2           P0                   DATA 080H ;
                +2           P0MASK               DATA 0FEH ; ACTIVE
                +2           P0MAT                DATA 0FDH ; ACTIVE
                +2           P0MDIN               DATA 0F1H ; ACTIVE
                +2           P0MDOUT              DATA 0A4H ; ACTIVE
                +2           P0SKIP               DATA 0D4H ; ACTIVE
                +2           P1                   DATA 090H ; ACTIVE
                +2           P1MASK               DATA 0EEH ; ACTIVE
                +2           P1MAT                DATA 0EDH ; ACTIVE
                +2           P1MDIN               DATA 0F2H ; ACTIVE
                +2           P1MDOUT              DATA 0A5H ; ACTIVE
                +2           P1SKIP               DATA 0D5H ; ACTIVE
                +2           P2                   DATA 0A0H ;
                +2           P2MDOUT              DATA 0A6H ; ACTIVE
                +2           PRTDRV               DATA 0F6H ; ACTIVE
                +2           XBR0                 DATA 0E1H ; ACTIVE
                +2           XBR1                 DATA 0E2H ; ACTIVE
                +2           XBR2                 DATA 0E3H ; ACTIVE
                +2           RSTSRC               DATA 0EFH ; ACTIVE
                +2           SMB0ADM              DATA 0D6H ; ACTIVE
                +2           SMB0ADR              DATA 0D7H ; ACTIVE
                +2           SMB0CF               DATA 0C1H ; ACTIVE
                +2           SMB0CN               DATA 0C0H ; ACTIVE
                +2           SMB0DAT              DATA 0C2H ; ACTIVE
                +2           SMB0TC               DATA 0ACH ; ACTIVE
                +2           SPI0CFG              DATA 0A1H ; ACTIVE
                +2           SPI0CKR              DATA 0A2H ; ACTIVE
                +2           SPI0CN               DATA 0F8H ; ACTIVE
                +2           SPI0DAT              DATA 0A3H ; ACTIVE
                +2           TCON                 DATA 088H ; ACTIVE
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    21

                +2           TH0                  DATA 08CH ; ACTIVE
                +2           TH1                  DATA 08DH ; ACTIVE
                +2           TL0                  DATA 08AH ; ACTIVE
                +2           TL1                  DATA 08BH ; ACTIVE
                +2           TMOD                 DATA 089H ; ACTIVE
                +2           TMR2CN               DATA 0C8H ;
                +2           TMR2H                DATA 0CDH ; ACTIVE
                +2           TMR2L                DATA 0CCH ; ACTIVE
                +2           TMR2RLH              DATA 0CBH ; ACTIVE
                +2           TMR2RLL              DATA 0CAH ; ACTIVE
                +2           TMR3CN               DATA 091H ; ACTIVE
                +2           TMR3H                DATA 095H ; ACTIVE
                +2           TMR3L                DATA 094H ; ACTIVE
                +2           TMR3RLH              DATA 093H ; ACTIVE
                +2           TMR3RLL              DATA 092H ; ACTIVE
                +2           SBUF0                DATA 099H ; ACTIVE
                +2           SCON0                DATA 098H ;
                +2           REF0CN               DATA 0D1H ; ACTIVE
                +2           REG0CN               DATA 0C9H ; ACTIVE
                +2           VDM0CN               DATA 0FFH ; ACTIVE
                +2           WDTCN                DATA 097H ;
                +2           ; SFR ADDRESSES END
                +2           
                +2           ; BIT DEFINITIONS
                +2           
                +2           ; ADC0CN0 0xE8
                +2           AD0EN                BIT  ADC0CN0.7   ;
                +2           BURSTEN              BIT  ADC0CN0.6   ;
                +2           AD0INT               BIT  ADC0CN0.5   ;
                +2           AD0BUSY              BIT  ADC0CN0.4   ;
                +2           AD0WINT              BIT  ADC0CN0.3   ;
                +2           ADC0M2               BIT  ADC0CN0.2   ;
                +2           ADC0M1               BIT  ADC0CN0.1   ;
                +2           ADC0M0               BIT  ADC0CN0.0   ;
                +2           
                +2           ; IE 0xA8
                +2           EA                   BIT  IE.7        ; Global Interrupt Enable
                +2           ESPI0                BIT  IE.6        ; Serial Peripheral Interface Enable
                +2           ET2                  BIT  IE.5        ; Timer 2 Interrupt Enable
                +2           ES0                  BIT  IE.4        ; Serial Port Interrupt Enable
                +2           ET1                  BIT  IE.3        ; Timer 1 Interrupt Enable
                +2           EX1                  BIT  IE.2        ; External Interrupt Enable
                +2           ET0                  BIT  IE.1        ; Timer 0 Interrupt Enable
                +2           EX0                  BIT  IE.0        ; External Interrupt 0 Enable
                +2           
                +2           ; IP 0xB8
                +2                                                 ; bit 7 UNUSED
                +2           PSPI0                BIT  IP.6        ; Serial Peripheral Interface Priority
                +2           PT2                  BIT  IP.5        ; Timer 2 Priority
                +2           PS0                  BIT  IP.4        ; Serial Port Priority
                +2           PT1                  BIT  IP.3        ; Timer 1 Priority
                +2           PX1                  BIT  IP.2        ; External Interrupt 1 Priority
                +2           PT0                  BIT  IP.1        ; Timer 0 Priority
                +2           PX0                  BIT  IP.0        ; External Interrupt 0 Priority
                +2           
                +2           ; PCA0CN 0xD8
                +2           CF                   BIT  PCA0CN.7    ; PCA 0 Counter Overflow Flag
                +2           CR                   BIT  PCA0CN.6    ; PCA 0 Counter Run Control Bit
                +2                                                 ; bit 5 UNUSED
                +2                                                 ; bit 4 UNUSED
                +2                                                 ; bit 3 UNUSED
                +2           CCF2                 BIT  PCA0CN.2    ; PCA 0 Module 2 Interrupt Flag
                +2           CCF1                 BIT  PCA0CN.1    ; PCA 0 Module 1 Interrupt Flag
                +2           CCF0                 BIT  PCA0CN.0    ; PCA 0 Module 0 Interrupt Flag
                +2           
                +2           ; PSW 0xD0
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    22

                +2           CY                   BIT  PSW.7       ; Carry Flag
                +2           AC                   BIT  PSW.6       ; Auxiliary Carry Flag
                +2           F0                   BIT  PSW.5       ; User Flag 0
                +2           RS1                  BIT  PSW.4       ; Register Bank Select 1
                +2           RS0                  BIT  PSW.3       ; Register Bank Select 0
                +2           OV                   BIT  PSW.2       ; Overflow Flag
                +2           F1                   BIT  PSW.1       ; User Flag 1
                +2           P                    BIT  PSW.0       ; Accumulator Parity Flag
                +2           
                +2           ; SCON0 0x98
                +2           S0MODE               BIT  SCON0.7     ; Serial Mode Control Bit 0
                +2                                                 ; bit 6 UNUSED
                +2           MCE0                 BIT  SCON0.5     ; Multiprocessor Communication Enable
                +2           REN0                 BIT  SCON0.4     ; Receive Enable
                +2           TB80                 BIT  SCON0.3     ; Transmit Bit 8
                +2           RB80                 BIT  SCON0.2     ; Receive Bit 8
                +2           TI0                  BIT  SCON0.1     ; Transmit Interrupt Flag
                +2           RI0                  BIT  SCON0.0     ; Receive Interrupt Flag
                +2           
                +2           ; SMB0CN 0xC0
                +2           MASTER0              BIT  SMB0CN.7    ; SMBus Master/Slave Indicator
                +2           TXMODE0              BIT  SMB0CN.6    ; SMBus Transmit Mode Indicator
                +2           STA0                 BIT  SMB0CN.5    ; SMBus Start Flag
                +2           STO0                 BIT  SMB0CN.4    ; SMBus Stop Flag
                +2           ACKRQ0               BIT  SMB0CN.3    ; SMBus Acknowledge Request
                +2           ARBLOST0             BIT  SMB0CN.2    ; SMBus Arbitration Lost Indicator
                +2           ACK0                 BIT  SMB0CN.1    ; SMBus Acknowledge
                +2           SI0                  BIT  SMB0CN.0    ; SMBus Interrupt
                +2           
                +2           ; SPI0CN 0xF8
                +2           SPIF                 BIT  SPI0CN.7    ; SPI 0 Interrupt Flag
                +2           WCOL                 BIT  SPI0CN.6    ; SPI 0 Write Collision Flag
                +2           MODF                 BIT  SPI0CN.5    ; SPI 0 Mode Fault Flag
                +2           RXOVRN               BIT  SPI0CN.4    ; SPI 0 RX Overrun Flag
                +2           NSSMD1               BIT  SPI0CN.3    ; SPI 0 NSS Mode Bit 1
                +2           NSSMD0               BIT  SPI0CN.2    ; SPI 0 NSS Mode Bit 0
                +2           TXBMT                BIT  SPI0CN.1    ; SPI 0 Transmit Buffer Empty Flag
                +2           SPIEN                BIT  SPI0CN.0    ; SPI 0 SPI Enable
                +2           
                +2           ; TCON 0x88
                +2           TF1                  BIT  TCON.7      ; Timer 1 Overflow Flag
                +2           TR1                  BIT  TCON.6      ; Timer 1 On/Off Control
                +2           TF0                  BIT  TCON.5      ; Timer 0 Overflow Flag
                +2           TR0                  BIT  TCON.4      ; Timer 0 On/Off Control
                +2           IE1                  BIT  TCON.3      ; Ext. Interrupt 1 Edge Flag
                +2           IT1                  BIT  TCON.2      ; Ext. Interrupt 1 Type
                +2           IE0                  BIT  TCON.1      ; Ext. Interrupt 0 Edge Flag
                +2           IT0                  BIT  TCON.0      ; Ext. Interrupt 0 Type
                +2           
                +2           ; TMR2CN 0xC8
                +2           TF2H                 BIT  TMR2CN.7    ; T2 High-Byte Overflow Flag
                +2           TF2L                 BIT  TMR2CN.6    ; T2 Low-Byte Overflow Flag
                +2           TF2LEN               BIT  TMR2CN.5    ; T2 Low Byte Interrupt Enable
                +2           TF2CEN               BIT  TMR2CN.4    ; T2 Input Capture Enable
                +2           T2SPLIT              BIT  TMR2CN.3    ; T2 Split-Mode Enable
                +2           TR2                  BIT  TMR2CN.2    ; Timer 2 On/Off Control
                +2                                                 ; bit 1 UNUSED
                +2           T2XCLK               BIT  TMR2CN.0    ; T2 External Clock Select
                +1           
                +1           
                +1           ;**** **** **** **** ****
                +1           ; Uses internal calibrated oscillator set to 24Mhz
                +1           ;**** **** **** **** ****
                +1           
                +1           ;**** **** **** **** ****
                +1           ; Constant definitions
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    23

                +1           ;**** **** **** **** ****
                +1           CSEG AT 1A40h
                +1           Eep_ESC_Layout:                 DB      "#FC_Fairy_6A#   "      ; ESC layout tag
                +1           CSEG AT 1A50h
                +1           Eep_ESC_MCU:                    DB      "#BLHELI#F850#   "      ; Project and MCU tag (16 B
                             ytes)
                +1           
                +1           MCU_48MHZ                               EQU     0       ; Set to 1 if MCU can run at 48MHz
                +1           ONE_S_CAPABLE                   EQU     0       ; Set to 1 if ESC can operate at 1S
                +1           PORT3_EXIST                             EQU     0       ; Set to 1 if MCU has port3
                +1           COMP1_USED                              EQU     0       ; Set to 1 if MCU has comparator 1 
                             and it is being used
                +1           LOCK_BYTE_ADDRESS_16K   EQU     3FFFh   ; Address of lock byte if 16k flash size
                +1           LOCK_BYTE_ADDRESS_8K    EQU     1FFFh   ; Address of lock byte if 8k flash size
                +1           HIGH_BEC_VOLTAGE                EQU     0       ; Set to 1 or more if high BEC voltage is s
                             upported
                +1           DAMPED_MODE_ENABLE              EQU     0       ; Damped mode disabled
                +1           NFETON_DELAY                    EQU     6       ; Wait delay from pfets off to nfets on
                +1           PFETON_DELAY                    EQU     35      ; Wait delay from nfets off to pfets on
                +1           ADC_LIMIT_L                             EQU 85  ; Power supply measurement ADC value for wh
                             ich main motor power is limited (low byte)
                +1           ADC_LIMIT_H                             EQU     0       ; Power supply measurement ADC valu
                             e for which main motor power is limited (2 MSBs)
                +1           TEMP_LIMIT                              EQU 103 ; Temperature measurement ADC value for whi
                             ch main motor power is limited (low byte, assuming high byte is 1)
                +1           TEMP_LIMIT_STEP                 EQU     4       ; Temperature measurement ADC value increme
                             nt for which main motor power is further limited
                +1           
                +1           ;**** **** **** **** ****
                +1           ; ESC specific defaults
                +1           ;**** **** **** **** ****
                +1           DEFAULT_PGM_MAIN_SPOOLUP_TIME           EQU 7   ; Main motor spoolup time
                +1           DEFAULT_PGM_MAIN_STARTUP_PWR            EQU 11  ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           DEFAULT_PGM_TAIL_STARTUP_PWR            EQU 11  ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           DEFAULT_PGM_MULTI_STARTUP_PWR           EQU 11  ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           
                +1           ;**** **** **** **** ****
                +1           ; Bootloader definitions
                +1           ;**** **** **** **** ****
                +1           RTX_PORT                                EQU P0          ; Receive/Transmit port
                +1           RTX_MDOUT                               EQU     P0MDOUT ; Set to 1 for PUSHPULL            
                                          
                +1           RTX_MDIN                                EQU     P0MDIN  ; Set to 1 for DIGITAL             
                                          
                +1           RTX_SKIP                                EQU     P0SKIP  ; Set to 1 for SKIP                
                                          
                +1           RTX_PIN                                 EQU 5           ; RTX pin
                +1           
                +1           SIGNATURE_001                   EQU     0f8h    ; Device signature
                +1           SIGNATURE_002                   EQU     050h
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 0 definitions *
                +1           ;*********************  
                +1           ;                       EQU     7       ;i (Temp)
                +1           Adc_Ip          EQU     6       ;i
                +1           Rcp_In          EQU     5       ;i
                +1           ;                       EQU     4       ;i (Rcp 1k)
                +1           Mux_C           EQU     3       ;i
                +1           Mux_B           EQU     2       ;i
                +1           Mux_A           EQU     1       ;i
                +1           Comp_Com        EQU     0       ;i
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    24

                +1           
                +1           P0_DIGITAL      EQU     NOT((1 SHL Mux_A)+(1 SHL Mux_B)+(1 SHL Mux_C)+(1 SHL Comp_Com)+(1 S
                             HL Adc_Ip))
                +1           P0_INIT         EQU     0FFh
                +1           P0_PUSHPULL     EQU     0
                +1           P0_SKIP         EQU     NOT(1 SHL Rcp_In) AND 0FFh
                +1           
                +1           Get_Rcp_Capture_Values MACRO
                +1                   mov     Temp1, PCA0CPL0                 ; Get PCA capture values
                +1                   mov     Temp2, PCA0CPH0
                +1           ENDM
                +1           Read_Rcp_Int MACRO
                +1                   mov     A, P0
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+4)   ; Is pwm polarity negative?
                +1                   cpl     A                                               ; Yes - invert
                +1           ENDM
                +1           Rcp_Int_Enable MACRO
                +1                   orl     PCA0CPM0, #01h                          ; Interrupt enabled
                +1           ENDM
                +1           Rcp_Int_Disable MACRO
                +1                   anl     PCA0CPM0, #0FEh                 ; Interrupt disabled
                +1           ENDM
                +1           Rcp_Int_First MACRO
                +1                   anl     PCA0CPM0, #0CFh                 
                +1                   jb      Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity positive?
                +1                   orl     PCA0CPM0, #20h                          ; Capture rising edge
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity negative?
                +1                   orl     PCA0CPM0, #10h                          ; Capture falling edge
                +1           ENDM
                +1           Rcp_Int_Second MACRO
                +1                   anl     PCA0CPM0, #0CFh                 
                +1                   jb      Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity positive?
                +1                   orl     PCA0CPM0, #10h                          ; Capture falling edge
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity negative?
                +1                   orl     PCA0CPM0, #20h                          ; Capture rising edge
                +1           ENDM
                +1           Rcp_Clear_Int_Flag MACRO
                +1                   clr     CCF0                                            ; Clear interrupt flag
                +1           ENDM            
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 1 definitions *
                +1           ;*********************
                +1           ;                       EQU     7       ;i
                +1           ;                       EQU     6       ;i
                +1           CnFET           EQU     5       ;o
                +1           CpFET           EQU     4       ;o
                +1           BnFET           EQU     3       ;o
                +1           BpFET           EQU     2       ;o
                +1           AnFET           EQU     1       ;o
                +1           ApFET           EQU     0       ;o
                +1           
                +1           P1_DIGITAL      EQU     (1 SHL AnFET)+(1 SHL BnFET)+(1 SHL CnFET)+(1 SHL ApFET)+(1 SHL BpFE
                             T)+(1 SHL CpFET)
                +1           P1_INIT         EQU 0           
                +1           P1_PUSHPULL     EQU     (1 SHL AnFET)+(1 SHL BnFET)+(1 SHL CnFET)+(1 SHL ApFET)+(1 SHL BpFE
                             T)+(1 SHL CpFET)
                +1           P1_SKIP         EQU     0
                +1           
                +1           AnFET_on MACRO
                +1                   setb    P1.AnFET
                +1           ENDM
                +1           AnFET_off MACRO
                +1                   clr     P1.AnFET
                +1           ENDM
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    25

                +1           BnFET_on MACRO
                +1                   setb    P1.BnFET
                +1           ENDM
                +1           BnFET_off MACRO
                +1                   clr     P1.BnFET
                +1           ENDM
                +1           CnFET_on MACRO
                +1                   setb    P1.CnFET
                +1           ENDM
                +1           CnFET_off MACRO
                +1                   clr     P1.CnFET
                +1           ENDM
                +1           All_nFETs_Off MACRO
                +1                   clr     P1.AnFET
                +1                   clr     P1.BnFET
                +1                   clr     P1.CnFET
                +1           ENDM
                +1           
                +1           ApFET_on MACRO
                +1                   setb    P1.ApFET
                +1           ENDM
                +1           ApFET_off MACRO
                +1                   clr     P1.ApFET
                +1           ENDM
                +1           BpFET_on MACRO
                +1                   setb    P1.BpFET
                +1           ENDM
                +1           BpFET_off MACRO
                +1                   clr     P1.BpFET
                +1           ENDM
                +1           CpFET_on MACRO
                +1                   setb    P1.CpFET
                +1           ENDM
                +1           CpFET_off MACRO
                +1                   clr     P1.CpFET
                +1           ENDM
                +1           All_pFETs_Off MACRO
                +1                   clr     P1.ApFET
                +1                   clr     P1.BpFET
                +1                   clr     P1.CpFET
                +1           ENDM
                +1           
                +1           Brake_FETs_On MACRO
                +1                   AnFET_on
                +1                   BnFET_on
                +1                   CnFET_on
                +1           ENDM
                +1           Damping_FET_On MACRO
                +1                   mov     A, DampingFET
                +1                   orl     P1, A
                +1           ENDM
                +1           
                +1           Set_Comp_Phase_A MACRO
                +1                   mov     CPT0MX, #01h    ; Set comparator multiplexer to phase A
                +1           ENDM
                +1           Set_Comp_Phase_B MACRO
                +1                   mov     CPT0MX, #02h    ; Set comparator multiplexer to phase B
                +1           ENDM
                +1           Set_Comp_Phase_C MACRO
                +1                   mov     CPT0MX, #03h    ; Set comparator multiplexer to phase C
                +1           ENDM
                +1           Read_Comp_Out MACRO
                +1                   mov     A, CPT0CN               ; Read comparator output
                +1           ENDM
                +1           
                +1           
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    26

                +1           ;*********************
                +1           ; PORT 2 definitions *
                +1           ;*********************
                +1           DebugPin                EQU     0       ;o
                +1           
                +1           P2_PUSHPULL     EQU     (1 SHL DebugPin)
                +1           
                +1           
                +1           ;**********************
                +1           ; MCU specific s *
                +1           ;**********************
                +1           Interrupt_Table_Definition MACRO
                +1           CSEG AT 0                               ; Code segment start
                +1                   jmp reset
                +1           CSEG AT 0Bh                     ; Timer0 interrupt      
                +1                   jmp     t0_int  
                +1           CSEG AT 2Bh                     ; Timer2 interrupt      
                +1                   jmp     t2_int  
                +1           CSEG AT 5Bh                     ; PCA interrupt 
                +1                   jmp     pca_int 
                +1           CSEG AT 73h                     ; Timer3 interrupt      
                +1                   jmp     t3_int  
                +1           ENDM
                +1           
                +1           Initialize_Xbar MACRO
                +1                   mov     XBR2, #40h      ; Xbar enabled                  
                +1                   mov     XBR1, #01h      ; CEX0 routed to pin Rcp_In                     
                +1           ENDM
                +1           
                +1           Initialize_Adc MACRO
                +1                   mov     REF0CN, #0Ch    ; Set vdd (3.3V) as reference. Enable temp sensor and bias
                +1                   mov     ADC0CF, #59h    ; ADC clock 2MHz, PGA gain 1
                +1                   mov     ADC0MX, #Adc_Ip; Select ADC input
                +1                   mov     ADC0CN0, #80h   ; ADC enabled 
                +1                   mov     ADC0CN1, #01h   ; Common mode buffer enabled
                +1           ENDM
                +1           Set_Adc_Ip_Volt MACRO
                +1                   mov     ADC0MX, #Adc_Ip; Select ADC input
                +1           ENDM
                +1           Set_Adc_Ip_Temp MACRO
                +1                   mov     ADC0MX, #10h    ; Select temp sensor input
                +1           ENDM
                +1           Start_Adc MACRO
                +1                   mov     ADC0CN0, #90h   ; ADC start
                +1           ENDM
                +1           Read_Adc_Result MACRO
                +1                   mov     Temp1, ADC0L
                +1                   mov     Temp2, ADC0H
                +1           ENDM
                +1           Stop_Adc MACRO
                +1           ENDM
                +1           Set_RPM_Out MACRO
                +1           ENDM
                +1           Clear_RPM_Out MACRO
                +1           ENDM
                +1           Set_MCU_Clk_24MHz MACRO
                +1           ENDM
                +1           Set_MCU_Clk_48MHz MACRO
                +1           ENDM
                             ENDIF
                    1643     
                    1644     IF BESCNO == Flycolor_Fairy_30A_Main
  0000              1645     MODE    EQU     0                               ; Choose mode. Set to 0 for main motor
                    1646     ;$include (Flycolor_Fairy_30A.inc) ; Select Flycolor Fairy 30A pinout
                +1  1647     ;**** **** **** **** ****
                +1  1648     ;
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    27

                +1  1649     ; BLHeli program for controlling brushless motors in helicopters and multirotors
                +1  1650     ;
                +1  1651     ; Copyright 2011, 2012 Steffen Skaug
                +1  1652     ; This program is distributed under the terms of the GNU General Public License
                +1  1653     ;
                +1  1654     ; This file is part of BLHeli.
                +1  1655     ;
                +1  1656     ; BLHeli is free software: you can redistribute it and/or modify
                +1  1657     ; it under the terms of the GNU General Public License as published by
                +1  1658     ; the Free Software Foundation, either version 3 of the License, or
                +1  1659     ; (at your option) any later version.
                +1  1660     ;
                +1  1661     ; BLHeli is distributed in the hope that it will be useful,
                +1  1662     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                +1  1663     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                +1  1664     ; GNU General Public License for more details.
                +1  1665     ;
                +1  1666     ; You should have received a copy of the GNU General Public License
                +1  1667     ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                +1  1668     ;
                +1  1669     ;**** **** **** **** ****
                +1  1670     ;
                +1  1671     ; Flycolor Fairy 30A hardware definition file
                +1  1672     ;
                +1  1673     ;**** **** **** **** ****
                +1  1674     
                +1  1675     
                +1  1676     
                +1  1677     ;*********************
                +1  1678     ; Device SiLabs F850
                +1  1679     ;*********************
                +1  1680     ;$include (c8051f850.inc)
                +2  1681     ; PAGE DEFINITIONS
  0000          +2  1682     ACTIVE_PAGE          EQU 000H
  0001          +2  1683     DEBUG_PAGE           EQU 001H
                +2  1684     
                +2  1685     ; SFR ADDRESSES BEGIN
  00B3          +2  1686     ADC0AC               DATA 0B3H ; ACTIVE
  00BC          +2  1687     ADC0CF               DATA 0BCH ; ACTIVE
  00E8          +2  1688     ADC0CN0              DATA 0E8H ; ACTIVE
  00B2          +2  1689     ADC0CN1              DATA 0B2H ; ACTIVE
  00C4          +2  1690     ADC0GTH              DATA 0C4H ; ACTIVE
  00C3          +2  1691     ADC0GTL              DATA 0C3H ; ACTIVE
  00BE          +2  1692     ADC0H                DATA 0BEH ; ACTIVE
  00BD          +2  1693     ADC0L                DATA 0BDH ; ACTIVE
  00C6          +2  1694     ADC0LTH              DATA 0C6H ; ACTIVE
  00C5          +2  1695     ADC0LTL              DATA 0C5H ; ACTIVE
  00BB          +2  1696     ADC0MX               DATA 0BBH ; ACTIVE
  00DF          +2  1697     ADC0PWR              DATA 0DFH ; ACTIVE
  00B9          +2  1698     ADC0TK               DATA 0B9H ; ACTIVE
  00E0          +2  1699     ACC                  DATA 0E0H ;
  00F0          +2  1700     B                    DATA 0F0H ;
  0083          +2  1701     DPH                  DATA 083H ;
  0082          +2  1702     DPL                  DATA 082H ;
  0087          +2  1703     PCON                 DATA 087H ;
  00D0          +2  1704     PSW                  DATA 0D0H ;
  0081          +2  1705     SP                   DATA 081H ;
  00D2          +2  1706     CRC0AUTO             DATA 0D2H ; ACTIVE
  00CE          +2  1707     CRC0CN               DATA 0CEH ; ACTIVE
  00D3          +2  1708     CRC0CNT              DATA 0D3H ; ACTIVE
  00DE          +2  1709     CRC0DAT              DATA 0DEH ; ACTIVE
  00CF          +2  1710     CRC0FLIP             DATA 0CFH ; ACTIVE
  00DD          +2  1711     CRC0IN               DATA 0DDH ; ACTIVE
  009B          +2  1712     CPT0CN               DATA 09BH ; ACTIVE
  009D          +2  1713     CPT0MD               DATA 09DH ; ACTIVE
  009F          +2  1714     CPT0MX               DATA 09FH ; ACTIVE
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    28

  00BF          +2  1715     CPT1CN               DATA 0BFH ; ACTIVE
  00AB          +2  1716     CPT1MD               DATA 0ABH ; ACTIVE
  00AA          +2  1717     CPT1MX               DATA 0AAH ; ACTIVE
  00AD          +2  1718     DERIVID              DATA 0ADH ; ACTIVE
  00B5          +2  1719     DEVICEID             DATA 0B5H ; ACTIVE
  009A          +2  1720     FLSCL                DATA 09AH ; ACTIVE
  00B6          +2  1721     REVID                DATA 0B6H ; ACTIVE
  00B7          +2  1722     FLKEY                DATA 0B7H ;
  008F          +2  1723     PSCTL                DATA 08FH ;
  00E6          +2  1724     EIE1                 DATA 0E6H ;
  00F3          +2  1725     EIP1                 DATA 0F3H ; ACTIVE
  00A8          +2  1726     IE                   DATA 0A8H ;
  00B8          +2  1727     IP                   DATA 0B8H ;
  00E4          +2  1728     IT01CF               DATA 0E4H ; ACTIVE
  008E          +2  1729     CKCON                DATA 08EH ; ACTIVE
  00A9          +2  1730     CLKSEL               DATA 0A9H ;
  00B1          +2  1731     OSCLCN               DATA 0B1H ; ACTIVE
  00C7          +2  1732     OSCICL               DATA 0C7H ; ACTIVE
  009E          +2  1733     PCA0CENT             DATA 09EH ; ACTIVE
  009C          +2  1734     PCA0CLR              DATA 09CH ; ACTIVE
  00D8          +2  1735     PCA0CN               DATA 0D8H ; ACTIVE
  00FC          +2  1736     PCA0CPH0             DATA 0FCH ; ACTIVE
  00EA          +2  1737     PCA0CPH1             DATA 0EAH ; ACTIVE
  00EC          +2  1738     PCA0CPH2             DATA 0ECH ; ACTIVE
  00FB          +2  1739     PCA0CPL0             DATA 0FBH ; ACTIVE
  00E9          +2  1740     PCA0CPL1             DATA 0E9H ; ACTIVE
  00EB          +2  1741     PCA0CPL2             DATA 0EBH ; ACTIVE
  00DA          +2  1742     PCA0CPM0             DATA 0DAH ; ACTIVE
  00DB          +2  1743     PCA0CPM1             DATA 0DBH ; ACTIVE
  00DC          +2  1744     PCA0CPM2             DATA 0DCH ; ACTIVE
  00FA          +2  1745     PCA0H                DATA 0FAH ; ACTIVE
  00F9          +2  1746     PCA0L                DATA 0F9H ; ACTIVE
  00D9          +2  1747     PCA0MD               DATA 0D9H ; ACTIVE
  0096          +2  1748     PCA0POL              DATA 096H ; ACTIVE
  00F7          +2  1749     PCA0PWM              DATA 0F7H ; ACTIVE
  0080          +2  1750     P0                   DATA 080H ;
  00FE          +2  1751     P0MASK               DATA 0FEH ; ACTIVE
  00FD          +2  1752     P0MAT                DATA 0FDH ; ACTIVE
  00F1          +2  1753     P0MDIN               DATA 0F1H ; ACTIVE
  00A4          +2  1754     P0MDOUT              DATA 0A4H ; ACTIVE
  00D4          +2  1755     P0SKIP               DATA 0D4H ; ACTIVE
  0090          +2  1756     P1                   DATA 090H ; ACTIVE
  00EE          +2  1757     P1MASK               DATA 0EEH ; ACTIVE
  00ED          +2  1758     P1MAT                DATA 0EDH ; ACTIVE
  00F2          +2  1759     P1MDIN               DATA 0F2H ; ACTIVE
  00A5          +2  1760     P1MDOUT              DATA 0A5H ; ACTIVE
  00D5          +2  1761     P1SKIP               DATA 0D5H ; ACTIVE
  00A0          +2  1762     P2                   DATA 0A0H ;
  00A6          +2  1763     P2MDOUT              DATA 0A6H ; ACTIVE
  00F6          +2  1764     PRTDRV               DATA 0F6H ; ACTIVE
  00E1          +2  1765     XBR0                 DATA 0E1H ; ACTIVE
  00E2          +2  1766     XBR1                 DATA 0E2H ; ACTIVE
  00E3          +2  1767     XBR2                 DATA 0E3H ; ACTIVE
  00EF          +2  1768     RSTSRC               DATA 0EFH ; ACTIVE
  00D6          +2  1769     SMB0ADM              DATA 0D6H ; ACTIVE
  00D7          +2  1770     SMB0ADR              DATA 0D7H ; ACTIVE
  00C1          +2  1771     SMB0CF               DATA 0C1H ; ACTIVE
  00C0          +2  1772     SMB0CN               DATA 0C0H ; ACTIVE
  00C2          +2  1773     SMB0DAT              DATA 0C2H ; ACTIVE
  00AC          +2  1774     SMB0TC               DATA 0ACH ; ACTIVE
  00A1          +2  1775     SPI0CFG              DATA 0A1H ; ACTIVE
  00A2          +2  1776     SPI0CKR              DATA 0A2H ; ACTIVE
  00F8          +2  1777     SPI0CN               DATA 0F8H ; ACTIVE
  00A3          +2  1778     SPI0DAT              DATA 0A3H ; ACTIVE
  0088          +2  1779     TCON                 DATA 088H ; ACTIVE
  008C          +2  1780     TH0                  DATA 08CH ; ACTIVE
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    29

  008D          +2  1781     TH1                  DATA 08DH ; ACTIVE
  008A          +2  1782     TL0                  DATA 08AH ; ACTIVE
  008B          +2  1783     TL1                  DATA 08BH ; ACTIVE
  0089          +2  1784     TMOD                 DATA 089H ; ACTIVE
  00C8          +2  1785     TMR2CN               DATA 0C8H ;
  00CD          +2  1786     TMR2H                DATA 0CDH ; ACTIVE
  00CC          +2  1787     TMR2L                DATA 0CCH ; ACTIVE
  00CB          +2  1788     TMR2RLH              DATA 0CBH ; ACTIVE
  00CA          +2  1789     TMR2RLL              DATA 0CAH ; ACTIVE
  0091          +2  1790     TMR3CN               DATA 091H ; ACTIVE
  0095          +2  1791     TMR3H                DATA 095H ; ACTIVE
  0094          +2  1792     TMR3L                DATA 094H ; ACTIVE
  0093          +2  1793     TMR3RLH              DATA 093H ; ACTIVE
  0092          +2  1794     TMR3RLL              DATA 092H ; ACTIVE
  0099          +2  1795     SBUF0                DATA 099H ; ACTIVE
  0098          +2  1796     SCON0                DATA 098H ;
  00D1          +2  1797     REF0CN               DATA 0D1H ; ACTIVE
  00C9          +2  1798     REG0CN               DATA 0C9H ; ACTIVE
  00FF          +2  1799     VDM0CN               DATA 0FFH ; ACTIVE
  0097          +2  1800     WDTCN                DATA 097H ;
                +2  1801     ; SFR ADDRESSES END
                +2  1802     
                +2  1803     ; BIT DEFINITIONS
                +2  1804     
                +2  1805     ; ADC0CN0 0xE8
  00EF          +2  1806     AD0EN                BIT  ADC0CN0.7   ;
  00EE          +2  1807     BURSTEN              BIT  ADC0CN0.6   ;
  00ED          +2  1808     AD0INT               BIT  ADC0CN0.5   ;
  00EC          +2  1809     AD0BUSY              BIT  ADC0CN0.4   ;
  00EB          +2  1810     AD0WINT              BIT  ADC0CN0.3   ;
  00EA          +2  1811     ADC0M2               BIT  ADC0CN0.2   ;
  00E9          +2  1812     ADC0M1               BIT  ADC0CN0.1   ;
  00E8          +2  1813     ADC0M0               BIT  ADC0CN0.0   ;
                +2  1814     
                +2  1815     ; IE 0xA8
  00AF          +2  1816     EA                   BIT  IE.7        ; Global Interrupt Enable
  00AE          +2  1817     ESPI0                BIT  IE.6        ; Serial Peripheral Interface Enable
  00AD          +2  1818     ET2                  BIT  IE.5        ; Timer 2 Interrupt Enable
  00AC          +2  1819     ES0                  BIT  IE.4        ; Serial Port Interrupt Enable
  00AB          +2  1820     ET1                  BIT  IE.3        ; Timer 1 Interrupt Enable
  00AA          +2  1821     EX1                  BIT  IE.2        ; External Interrupt Enable
  00A9          +2  1822     ET0                  BIT  IE.1        ; Timer 0 Interrupt Enable
  00A8          +2  1823     EX0                  BIT  IE.0        ; External Interrupt 0 Enable
                +2  1824     
                +2  1825     ; IP 0xB8
                +2  1826                                           ; bit 7 UNUSED
  00BE          +2  1827     PSPI0                BIT  IP.6        ; Serial Peripheral Interface Priority
  00BD          +2  1828     PT2                  BIT  IP.5        ; Timer 2 Priority
  00BC          +2  1829     PS0                  BIT  IP.4        ; Serial Port Priority
  00BB          +2  1830     PT1                  BIT  IP.3        ; Timer 1 Priority
  00BA          +2  1831     PX1                  BIT  IP.2        ; External Interrupt 1 Priority
  00B9          +2  1832     PT0                  BIT  IP.1        ; Timer 0 Priority
  00B8          +2  1833     PX0                  BIT  IP.0        ; External Interrupt 0 Priority
                +2  1834     
                +2  1835     ; PCA0CN 0xD8
  00DF          +2  1836     CF                   BIT  PCA0CN.7    ; PCA 0 Counter Overflow Flag
  00DE          +2  1837     CR                   BIT  PCA0CN.6    ; PCA 0 Counter Run Control Bit
                +2  1838                                           ; bit 5 UNUSED
                +2  1839                                           ; bit 4 UNUSED
                +2  1840                                           ; bit 3 UNUSED
  00DA          +2  1841     CCF2                 BIT  PCA0CN.2    ; PCA 0 Module 2 Interrupt Flag
  00D9          +2  1842     CCF1                 BIT  PCA0CN.1    ; PCA 0 Module 1 Interrupt Flag
  00D8          +2  1843     CCF0                 BIT  PCA0CN.0    ; PCA 0 Module 0 Interrupt Flag
                +2  1844     
                +2  1845     ; PSW 0xD0
  00D7          +2  1846     CY                   BIT  PSW.7       ; Carry Flag
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    30

  00D6          +2  1847     AC                   BIT  PSW.6       ; Auxiliary Carry Flag
  00D5          +2  1848     F0                   BIT  PSW.5       ; User Flag 0
  00D4          +2  1849     RS1                  BIT  PSW.4       ; Register Bank Select 1
  00D3          +2  1850     RS0                  BIT  PSW.3       ; Register Bank Select 0
  00D2          +2  1851     OV                   BIT  PSW.2       ; Overflow Flag
  00D1          +2  1852     F1                   BIT  PSW.1       ; User Flag 1
  00D0          +2  1853     P                    BIT  PSW.0       ; Accumulator Parity Flag
                +2  1854     
                +2  1855     ; SCON0 0x98
  009F          +2  1856     S0MODE               BIT  SCON0.7     ; Serial Mode Control Bit 0
                +2  1857                                           ; bit 6 UNUSED
  009D          +2  1858     MCE0                 BIT  SCON0.5     ; Multiprocessor Communication Enable
  009C          +2  1859     REN0                 BIT  SCON0.4     ; Receive Enable
  009B          +2  1860     TB80                 BIT  SCON0.3     ; Transmit Bit 8
  009A          +2  1861     RB80                 BIT  SCON0.2     ; Receive Bit 8
  0099          +2  1862     TI0                  BIT  SCON0.1     ; Transmit Interrupt Flag
  0098          +2  1863     RI0                  BIT  SCON0.0     ; Receive Interrupt Flag
                +2  1864     
                +2  1865     ; SMB0CN 0xC0
  00C7          +2  1866     MASTER0              BIT  SMB0CN.7    ; SMBus Master/Slave Indicator
  00C6          +2  1867     TXMODE0              BIT  SMB0CN.6    ; SMBus Transmit Mode Indicator
  00C5          +2  1868     STA0                 BIT  SMB0CN.5    ; SMBus Start Flag
  00C4          +2  1869     STO0                 BIT  SMB0CN.4    ; SMBus Stop Flag
  00C3          +2  1870     ACKRQ0               BIT  SMB0CN.3    ; SMBus Acknowledge Request
  00C2          +2  1871     ARBLOST0             BIT  SMB0CN.2    ; SMBus Arbitration Lost Indicator
  00C1          +2  1872     ACK0                 BIT  SMB0CN.1    ; SMBus Acknowledge
  00C0          +2  1873     SI0                  BIT  SMB0CN.0    ; SMBus Interrupt
                +2  1874     
                +2  1875     ; SPI0CN 0xF8
  00FF          +2  1876     SPIF                 BIT  SPI0CN.7    ; SPI 0 Interrupt Flag
  00FE          +2  1877     WCOL                 BIT  SPI0CN.6    ; SPI 0 Write Collision Flag
  00FD          +2  1878     MODF                 BIT  SPI0CN.5    ; SPI 0 Mode Fault Flag
  00FC          +2  1879     RXOVRN               BIT  SPI0CN.4    ; SPI 0 RX Overrun Flag
  00FB          +2  1880     NSSMD1               BIT  SPI0CN.3    ; SPI 0 NSS Mode Bit 1
  00FA          +2  1881     NSSMD0               BIT  SPI0CN.2    ; SPI 0 NSS Mode Bit 0
  00F9          +2  1882     TXBMT                BIT  SPI0CN.1    ; SPI 0 Transmit Buffer Empty Flag
  00F8          +2  1883     SPIEN                BIT  SPI0CN.0    ; SPI 0 SPI Enable
                +2  1884     
                +2  1885     ; TCON 0x88
  008F          +2  1886     TF1                  BIT  TCON.7      ; Timer 1 Overflow Flag
  008E          +2  1887     TR1                  BIT  TCON.6      ; Timer 1 On/Off Control
  008D          +2  1888     TF0                  BIT  TCON.5      ; Timer 0 Overflow Flag
  008C          +2  1889     TR0                  BIT  TCON.4      ; Timer 0 On/Off Control
  008B          +2  1890     IE1                  BIT  TCON.3      ; Ext. Interrupt 1 Edge Flag
  008A          +2  1891     IT1                  BIT  TCON.2      ; Ext. Interrupt 1 Type
  0089          +2  1892     IE0                  BIT  TCON.1      ; Ext. Interrupt 0 Edge Flag
  0088          +2  1893     IT0                  BIT  TCON.0      ; Ext. Interrupt 0 Type
                +2  1894     
                +2  1895     ; TMR2CN 0xC8
  00CF          +2  1896     TF2H                 BIT  TMR2CN.7    ; T2 High-Byte Overflow Flag
  00CE          +2  1897     TF2L                 BIT  TMR2CN.6    ; T2 Low-Byte Overflow Flag
  00CD          +2  1898     TF2LEN               BIT  TMR2CN.5    ; T2 Low Byte Interrupt Enable
  00CC          +2  1899     TF2CEN               BIT  TMR2CN.4    ; T2 Input Capture Enable
  00CB          +2  1900     T2SPLIT              BIT  TMR2CN.3    ; T2 Split-Mode Enable
  00CA          +2  1901     TR2                  BIT  TMR2CN.2    ; Timer 2 On/Off Control
                +2  1902                                           ; bit 1 UNUSED
  00C8          +2  1903     T2XCLK               BIT  TMR2CN.0    ; T2 External Clock Select
                +1  1904     
                +1  1905     
                +1  1906     ;**** **** **** **** ****
                +1  1907     ; Uses internal calibrated oscillator set to 24Mhz
                +1  1908     ;**** **** **** **** ****
                +1  1909     
                +1  1910     ;**** **** **** **** ****
                +1  1911     ; Constant definitions
                +1  1912     ;**** **** **** **** ****
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    31

----            +1  1913     CSEG AT 1A40h
1A40 2346435F   +1  1914     Eep_ESC_Layout:                 DB      "#FC_Fairy_30A#  "      ; ESC layout tag
1A44 46616972                
1A48 795F3330                
1A4C 41232020                
----            +1  1915     CSEG AT 1A50h
1A50 23424C48   +1  1916     Eep_ESC_MCU:                    DB      "#BLHELI#F850#   "      ; Project and MCU tag (16 B
                             ytes)
1A54 454C4923                
1A58 46383530                
1A5C 23202020                
                +1  1917     
  0000          +1  1918     MCU_48MHZ                               EQU     0       ; Set to 1 if MCU can run at 48MHz
  0000          +1  1919     ONE_S_CAPABLE                   EQU     0       ; Set to 1 if ESC can operate at 1S
  0000          +1  1920     PORT3_EXIST                             EQU     0       ; Set to 1 if MCU has port3
  0000          +1  1921     COMP1_USED                              EQU     0       ; Set to 1 if MCU has comparator 1 
                             and it is being used
  3FFF          +1  1922     LOCK_BYTE_ADDRESS_16K   EQU     3FFFh   ; Address of lock byte if 16k flash size
  1FFF          +1  1923     LOCK_BYTE_ADDRESS_8K    EQU     1FFFh   ; Address of lock byte if 8k flash size
  0000          +1  1924     HIGH_BEC_VOLTAGE                EQU     0       ; Set to 1 or more if high BEC voltage is s
                             upported
  0001          +1  1925     DAMPED_MODE_ENABLE              EQU     1       ; Damped mode enabled
  0006          +1  1926     NFETON_DELAY                    EQU     6       ; Wait delay from pfets off to nfets on
  0001          +1  1927     PFETON_DELAY                    EQU     1       ; Wait delay from nfets off to pfets on
  0055          +1  1928     ADC_LIMIT_L                             EQU 85  ; Power supply measurement ADC value for wh
                             ich main motor power is limited (low byte)
  0000          +1  1929     ADC_LIMIT_H                             EQU     0       ; Power supply measurement ADC valu
                             e for which main motor power is limited (2 MSBs)
  0067          +1  1930     TEMP_LIMIT                              EQU 103 ; Temperature measurement ADC value for whi
                             ch main motor power is limited (low byte, assuming high byte is 1)
  0004          +1  1931     TEMP_LIMIT_STEP                 EQU     4       ; Temperature measurement ADC value increme
                             nt for which main motor power is further limited
                +1  1932     
                +1  1933     ;**** **** **** **** ****
                +1  1934     ; ESC specific defaults
                +1  1935     ;**** **** **** **** ****
  000A          +1  1936     DEFAULT_PGM_MAIN_SPOOLUP_TIME           EQU 10  ; Main motor spoolup time
  0009          +1  1937     DEFAULT_PGM_MAIN_STARTUP_PWR            EQU 9   ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
  0009          +1  1938     DEFAULT_PGM_TAIL_STARTUP_PWR            EQU 9   ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
  0009          +1  1939     DEFAULT_PGM_MULTI_STARTUP_PWR           EQU 9   ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1  1940     
                +1  1941     ;**** **** **** **** ****
                +1  1942     ; Bootloader definitions
                +1  1943     ;**** **** **** **** ****
  0080          +1  1944     RTX_PORT                                EQU     P0              ; Receive/Transmit port
  00A4          +1  1945     RTX_MDOUT                               EQU     P0MDOUT ; Set to 1 for PUSHPULL            
                                          
  00F1          +1  1946     RTX_MDIN                                EQU     P0MDIN  ; Set to 1 for DIGITAL             
                                          
  00D4          +1  1947     RTX_SKIP                                EQU     P0SKIP  ; Set to 1 for SKIP                
                                          
  0005          +1  1948     RTX_PIN                                 EQU 5           ; RTX pin
                +1  1949     
  00F8          +1  1950     SIGNATURE_001                   EQU     0f8h            ; Device signature
  0050          +1  1951     SIGNATURE_002                   EQU     050h
                +1  1952     
                +1  1953     
                +1  1954     ;*********************
                +1  1955     ; PORT 0 definitions *
                +1  1956     ;*********************  
                +1  1957     ;                       EQU     7       ;i (Temp)
  0006          +1  1958     Adc_Ip          EQU     6       ;i
  0005          +1  1959     Rcp_In          EQU     5       ;i
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    32

                +1  1960     ;                       EQU     4       ;i (Rcp 1k)
  0003          +1  1961     Mux_C           EQU     3       ;i
  0002          +1  1962     Mux_B           EQU     2       ;i
  0001          +1  1963     Mux_A           EQU     1       ;i
  0000          +1  1964     Comp_Com        EQU     0       ;i
                +1  1965     
  FFB0          +1  1966     P0_DIGITAL      EQU     NOT((1 SHL Mux_A)+(1 SHL Mux_B)+(1 SHL Mux_C)+(1 SHL Comp_Com)+(1 S
                             HL Adc_Ip))
  00FF          +1  1967     P0_INIT         EQU     0FFh
  0000          +1  1968     P0_PUSHPULL     EQU     0
  00DF          +1  1969     P0_SKIP         EQU     NOT(1 SHL Rcp_In) AND 0FFh
                +1  1970     
                +1  1971     Get_Rcp_Capture_Values MACRO
                +1  1972             mov     Temp1, PCA0CPL0                 ; Get PCA capture values
                +1  1973             mov     Temp2, PCA0CPH0
                +1  1974     ENDM
                +1  1975     Read_Rcp_Int MACRO
                +1  1976             mov     A, P0
                +1  1977             jnb     Flags3.PGM_RCP_PWM_POL, ($+4)   ; Is pwm polarity negative?
                +1  1978             cpl     A                                               ; Yes - invert
                +1  1979     ENDM
                +1  1980     Rcp_Int_Enable MACRO
                +1  1981             orl     PCA0CPM0, #01h                          ; Interrupt enabled
                +1  1982     ENDM
                +1  1983     Rcp_Int_Disable MACRO
                +1  1984             anl     PCA0CPM0, #0FEh                 ; Interrupt disabled
                +1  1985     ENDM
                +1  1986     Rcp_Int_First MACRO
                +1  1987             anl     PCA0CPM0, #0CFh                 
                +1  1988             jb      Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity positive?
                +1  1989             orl     PCA0CPM0, #20h                          ; Capture rising edge
                +1  1990             jnb     Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity negative?
                +1  1991             orl     PCA0CPM0, #10h                          ; Capture falling edge
                +1  1992     ENDM
                +1  1993     Rcp_Int_Second MACRO
                +1  1994             anl     PCA0CPM0, #0CFh                 
                +1  1995             jb      Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity positive?
                +1  1996             orl     PCA0CPM0, #10h                          ; Capture falling edge
                +1  1997             jnb     Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity negative?
                +1  1998             orl     PCA0CPM0, #20h                          ; Capture rising edge
                +1  1999     ENDM
                +1  2000     Rcp_Clear_Int_Flag MACRO
                +1  2001             clr     CCF0                                            ; Clear interrupt flag
                +1  2002     ENDM            
                +1  2003     
                +1  2004     
                +1  2005     ;*********************
                +1  2006     ; PORT 1 definitions *
                +1  2007     ;*********************
                +1  2008     ;                       EQU     7       ;i
                +1  2009     ;                       EQU     6       ;i
  0005          +1  2010     CnFET           EQU     5       ;o
  0004          +1  2011     CpFET           EQU     4       ;o
  0003          +1  2012     BnFET           EQU     3       ;o
  0002          +1  2013     BpFET           EQU     2       ;o
  0001          +1  2014     AnFET           EQU     1       ;o
  0000          +1  2015     ApFET           EQU     0       ;o
                +1  2016     
  003F          +1  2017     P1_DIGITAL      EQU     (1 SHL AnFET)+(1 SHL BnFET)+(1 SHL CnFET)+(1 SHL ApFET)+(1 SHL BpFE
                             T)+(1 SHL CpFET)
  0015          +1  2018     P1_INIT         EQU     (1 SHL ApFET)+(1 SHL BpFET)+(1 SHL CpFET)               
  003F          +1  2019     P1_PUSHPULL     EQU     (1 SHL AnFET)+(1 SHL BnFET)+(1 SHL CnFET)+(1 SHL ApFET)+(1 SHL BpFE
                             T)+(1 SHL CpFET)
  0000          +1  2020     P1_SKIP         EQU     0
                +1  2021     
                +1  2022     AnFET_on MACRO
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    33

                +1  2023             setb    P1.AnFET
                +1  2024     ENDM
                +1  2025     AnFET_off MACRO
                +1  2026             clr     P1.AnFET
                +1  2027     ENDM
                +1  2028     BnFET_on MACRO
                +1  2029             setb    P1.BnFET
                +1  2030     ENDM
                +1  2031     BnFET_off MACRO
                +1  2032             clr     P1.BnFET
                +1  2033     ENDM
                +1  2034     CnFET_on MACRO
                +1  2035             setb    P1.CnFET
                +1  2036     ENDM
                +1  2037     CnFET_off MACRO
                +1  2038             clr     P1.CnFET
                +1  2039     ENDM
                +1  2040     All_nFETs_Off MACRO
                +1  2041             clr     P1.AnFET
                +1  2042             clr     P1.BnFET
                +1  2043             clr     P1.CnFET
                +1  2044     ENDM
                +1  2045     
                +1  2046     ApFET_on MACRO
                +1  2047             clr     P1.ApFET
                +1  2048     ENDM
                +1  2049     ApFET_off MACRO
                +1  2050             setb    P1.ApFET
                +1  2051     ENDM
                +1  2052     BpFET_on MACRO
                +1  2053             clr     P1.BpFET
                +1  2054     ENDM
                +1  2055     BpFET_off MACRO
                +1  2056             setb    P1.BpFET
                +1  2057     ENDM
                +1  2058     CpFET_on MACRO
                +1  2059             clr     P1.CpFET
                +1  2060     ENDM
                +1  2061     CpFET_off MACRO
                +1  2062             setb    P1.CpFET
                +1  2063     ENDM
                +1  2064     All_pFETs_Off MACRO
                +1  2065             setb    P1.ApFET
                +1  2066             setb    P1.BpFET
                +1  2067             setb    P1.CpFET
                +1  2068     ENDM
                +1  2069     
                +1  2070     Brake_FETs_On MACRO
                +1  2071             AnFET_on
                +1  2072             BnFET_on
                +1  2073             CnFET_on
                +1  2074     ENDM
                +1  2075     Damping_FET_On MACRO
                +1  2076             mov     A, DampingFET
                +1  2077             cpl     A
                +1  2078             anl     P1, A
                +1  2079     ENDM
                +1  2080     
                +1  2081     Set_Comp_Phase_A MACRO
                +1  2082             mov     CPT0MX, #01h    ; Set comparator multiplexer to phase A
                +1  2083     ENDM
                +1  2084     Set_Comp_Phase_B MACRO
                +1  2085             mov     CPT0MX, #02h    ; Set comparator multiplexer to phase B
                +1  2086     ENDM
                +1  2087     Set_Comp_Phase_C MACRO
                +1  2088             mov     CPT0MX, #03h    ; Set comparator multiplexer to phase C
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    34

                +1  2089     ENDM
                +1  2090     Read_Comp_Out MACRO
                +1  2091             mov     A, CPT0CN               ; Read comparator output
                +1  2092     ENDM
                +1  2093     
                +1  2094     
                +1  2095     ;*********************
                +1  2096     ; PORT 2 definitions *
                +1  2097     ;*********************
  0000          +1  2098     DebugPin                EQU     0       ;o
                +1  2099     
  0001          +1  2100     P2_PUSHPULL     EQU     (1 SHL DebugPin)
                +1  2101     
                +1  2102     
                +1  2103     ;**********************
                +1  2104     ; MCU specific macros *
                +1  2105     ;**********************
                +1  2106     Interrupt_Table_Definition MACRO
                +1  2107     CSEG AT 0                               ; Code segment start
                +1  2108             jmp reset
                +1  2109     CSEG AT 0Bh                     ; Timer0 interrupt      
                +1  2110             jmp     t0_int  
                +1  2111     CSEG AT 2Bh                     ; Timer2 interrupt      
                +1  2112             jmp     t2_int  
                +1  2113     CSEG AT 5Bh                     ; PCA interrupt 
                +1  2114             jmp     pca_int 
                +1  2115     CSEG AT 73h                     ; Timer3 interrupt      
                +1  2116             jmp     t3_int  
                +1  2117     ENDM
                +1  2118     
                +1  2119     Initialize_Xbar MACRO
                +1  2120             mov     XBR2, #40h      ; Xbar enabled                  
                +1  2121             mov     XBR1, #01h      ; CEX0 routed to pin Rcp_In                     
                +1  2122     ENDM
                +1  2123     
                +1  2124     Initialize_Adc MACRO
                +1  2125             mov     REF0CN, #0Ch    ; Set vdd (3.3V) as reference. Enable temp sensor and bias
                +1  2126             mov     ADC0CF, #59h    ; ADC clock 2MHz, PGA gain 1
                +1  2127             mov     ADC0MX, #Adc_Ip; Select ADC input
                +1  2128             mov     ADC0CN0, #80h   ; ADC enabled 
                +1  2129             mov     ADC0CN1, #01h   ; Common mode buffer enabled
                +1  2130     ENDM
                +1  2131     Set_Adc_Ip_Volt MACRO
                +1  2132             mov     ADC0MX, #Adc_Ip; Select ADC input
                +1  2133     ENDM
                +1  2134     Set_Adc_Ip_Temp MACRO
                +1  2135             mov     ADC0MX, #10h    ; Select temp sensor input
                +1  2136     ENDM
                +1  2137     Start_Adc MACRO
                +1  2138             mov     ADC0CN0, #90h   ; ADC start
                +1  2139     ENDM
                +1  2140     Read_Adc_Result MACRO
                +1  2141             mov     Temp1, ADC0L
                +1  2142             mov     Temp2, ADC0H
                +1  2143     ENDM
                +1  2144     Stop_Adc MACRO
                +1  2145     ENDM
                +1  2146     Set_RPM_Out MACRO
                +1  2147     ENDM
                +1  2148     Clear_RPM_Out MACRO
                +1  2149     ENDM
                +1  2150     Set_MCU_Clk_24MHz MACRO
                +1  2151     ENDM
                +1  2152     Set_MCU_Clk_48MHz MACRO
                +1  2153     ENDM
                    2154     ENDIF
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    35

                    2155     
                    2156     IF BESCNO == Flycolor_Fairy_30A_Tail
                             MODE    EQU     1                               ; Choose mode. Set to 1 for tail motor
                             ;$include (Flycolor_Fairy_30A.inc) ; Select Flycolor Fairy 30A pinout
                +1           ;**** **** **** **** ****
                +1           ;
                +1           ; BLHeli program for controlling brushless motors in helicopters and multirotors
                +1           ;
                +1           ; Copyright 2011, 2012 Steffen Skaug
                +1           ; This program is distributed under the terms of the GNU General Public License
                +1           ;
                +1           ; This file is part of BLHeli.
                +1           ;
                +1           ; BLHeli is free software: you can redistribute it and/or modify
                +1           ; it under the terms of the GNU General Public License as published by
                +1           ; the Free Software Foundation, either version 3 of the License, or
                +1           ; (at your option) any later version.
                +1           ;
                +1           ; BLHeli is distributed in the hope that it will be useful,
                +1           ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                +1           ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                +1           ; GNU General Public License for more details.
                +1           ;
                +1           ; You should have received a copy of the GNU General Public License
                +1           ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                +1           ;
                +1           ;**** **** **** **** ****
                +1           ;
                +1           ; Flycolor Fairy 30A hardware definition file
                +1           ;
                +1           ;**** **** **** **** ****
                +1           
                +1           
                +1           
                +1           ;*********************
                +1           ; Device SiLabs F850
                +1           ;*********************
                +1           ;$include (c8051f850.inc)
                +2           ; PAGE DEFINITIONS
                +2           ACTIVE_PAGE          EQU 000H
                +2           DEBUG_PAGE           EQU 001H
                +2           
                +2           ; SFR ADDRESSES BEGIN
                +2           ADC0AC               DATA 0B3H ; ACTIVE
                +2           ADC0CF               DATA 0BCH ; ACTIVE
                +2           ADC0CN0              DATA 0E8H ; ACTIVE
                +2           ADC0CN1              DATA 0B2H ; ACTIVE
                +2           ADC0GTH              DATA 0C4H ; ACTIVE
                +2           ADC0GTL              DATA 0C3H ; ACTIVE
                +2           ADC0H                DATA 0BEH ; ACTIVE
                +2           ADC0L                DATA 0BDH ; ACTIVE
                +2           ADC0LTH              DATA 0C6H ; ACTIVE
                +2           ADC0LTL              DATA 0C5H ; ACTIVE
                +2           ADC0MX               DATA 0BBH ; ACTIVE
                +2           ADC0PWR              DATA 0DFH ; ACTIVE
                +2           ADC0TK               DATA 0B9H ; ACTIVE
                +2           ACC                  DATA 0E0H ;
                +2           B                    DATA 0F0H ;
                +2           DPH                  DATA 083H ;
                +2           DPL                  DATA 082H ;
                +2           PCON                 DATA 087H ;
                +2           PSW                  DATA 0D0H ;
                +2           SP                   DATA 081H ;
                +2           CRC0AUTO             DATA 0D2H ; ACTIVE
                +2           CRC0CN               DATA 0CEH ; ACTIVE
                +2           CRC0CNT              DATA 0D3H ; ACTIVE
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    36

                +2           CRC0DAT              DATA 0DEH ; ACTIVE
                +2           CRC0FLIP             DATA 0CFH ; ACTIVE
                +2           CRC0IN               DATA 0DDH ; ACTIVE
                +2           CPT0CN               DATA 09BH ; ACTIVE
                +2           CPT0MD               DATA 09DH ; ACTIVE
                +2           CPT0MX               DATA 09FH ; ACTIVE
                +2           CPT1CN               DATA 0BFH ; ACTIVE
                +2           CPT1MD               DATA 0ABH ; ACTIVE
                +2           CPT1MX               DATA 0AAH ; ACTIVE
                +2           DERIVID              DATA 0ADH ; ACTIVE
                +2           DEVICEID             DATA 0B5H ; ACTIVE
                +2           FLSCL                DATA 09AH ; ACTIVE
                +2           REVID                DATA 0B6H ; ACTIVE
                +2           FLKEY                DATA 0B7H ;
                +2           PSCTL                DATA 08FH ;
                +2           EIE1                 DATA 0E6H ;
                +2           EIP1                 DATA 0F3H ; ACTIVE
                +2           IE                   DATA 0A8H ;
                +2           IP                   DATA 0B8H ;
                +2           IT01CF               DATA 0E4H ; ACTIVE
                +2           CKCON                DATA 08EH ; ACTIVE
                +2           CLKSEL               DATA 0A9H ;
                +2           OSCLCN               DATA 0B1H ; ACTIVE
                +2           OSCICL               DATA 0C7H ; ACTIVE
                +2           PCA0CENT             DATA 09EH ; ACTIVE
                +2           PCA0CLR              DATA 09CH ; ACTIVE
                +2           PCA0CN               DATA 0D8H ; ACTIVE
                +2           PCA0CPH0             DATA 0FCH ; ACTIVE
                +2           PCA0CPH1             DATA 0EAH ; ACTIVE
                +2           PCA0CPH2             DATA 0ECH ; ACTIVE
                +2           PCA0CPL0             DATA 0FBH ; ACTIVE
                +2           PCA0CPL1             DATA 0E9H ; ACTIVE
                +2           PCA0CPL2             DATA 0EBH ; ACTIVE
                +2           PCA0CPM0             DATA 0DAH ; ACTIVE
                +2           PCA0CPM1             DATA 0DBH ; ACTIVE
                +2           PCA0CPM2             DATA 0DCH ; ACTIVE
                +2           PCA0H                DATA 0FAH ; ACTIVE
                +2           PCA0L                DATA 0F9H ; ACTIVE
                +2           PCA0MD               DATA 0D9H ; ACTIVE
                +2           PCA0POL              DATA 096H ; ACTIVE
                +2           PCA0PWM              DATA 0F7H ; ACTIVE
                +2           P0                   DATA 080H ;
                +2           P0MASK               DATA 0FEH ; ACTIVE
                +2           P0MAT                DATA 0FDH ; ACTIVE
                +2           P0MDIN               DATA 0F1H ; ACTIVE
                +2           P0MDOUT              DATA 0A4H ; ACTIVE
                +2           P0SKIP               DATA 0D4H ; ACTIVE
                +2           P1                   DATA 090H ; ACTIVE
                +2           P1MASK               DATA 0EEH ; ACTIVE
                +2           P1MAT                DATA 0EDH ; ACTIVE
                +2           P1MDIN               DATA 0F2H ; ACTIVE
                +2           P1MDOUT              DATA 0A5H ; ACTIVE
                +2           P1SKIP               DATA 0D5H ; ACTIVE
                +2           P2                   DATA 0A0H ;
                +2           P2MDOUT              DATA 0A6H ; ACTIVE
                +2           PRTDRV               DATA 0F6H ; ACTIVE
                +2           XBR0                 DATA 0E1H ; ACTIVE
                +2           XBR1                 DATA 0E2H ; ACTIVE
                +2           XBR2                 DATA 0E3H ; ACTIVE
                +2           RSTSRC               DATA 0EFH ; ACTIVE
                +2           SMB0ADM              DATA 0D6H ; ACTIVE
                +2           SMB0ADR              DATA 0D7H ; ACTIVE
                +2           SMB0CF               DATA 0C1H ; ACTIVE
                +2           SMB0CN               DATA 0C0H ; ACTIVE
                +2           SMB0DAT              DATA 0C2H ; ACTIVE
                +2           SMB0TC               DATA 0ACH ; ACTIVE
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    37

                +2           SPI0CFG              DATA 0A1H ; ACTIVE
                +2           SPI0CKR              DATA 0A2H ; ACTIVE
                +2           SPI0CN               DATA 0F8H ; ACTIVE
                +2           SPI0DAT              DATA 0A3H ; ACTIVE
                +2           TCON                 DATA 088H ; ACTIVE
                +2           TH0                  DATA 08CH ; ACTIVE
                +2           TH1                  DATA 08DH ; ACTIVE
                +2           TL0                  DATA 08AH ; ACTIVE
                +2           TL1                  DATA 08BH ; ACTIVE
                +2           TMOD                 DATA 089H ; ACTIVE
                +2           TMR2CN               DATA 0C8H ;
                +2           TMR2H                DATA 0CDH ; ACTIVE
                +2           TMR2L                DATA 0CCH ; ACTIVE
                +2           TMR2RLH              DATA 0CBH ; ACTIVE
                +2           TMR2RLL              DATA 0CAH ; ACTIVE
                +2           TMR3CN               DATA 091H ; ACTIVE
                +2           TMR3H                DATA 095H ; ACTIVE
                +2           TMR3L                DATA 094H ; ACTIVE
                +2           TMR3RLH              DATA 093H ; ACTIVE
                +2           TMR3RLL              DATA 092H ; ACTIVE
                +2           SBUF0                DATA 099H ; ACTIVE
                +2           SCON0                DATA 098H ;
                +2           REF0CN               DATA 0D1H ; ACTIVE
                +2           REG0CN               DATA 0C9H ; ACTIVE
                +2           VDM0CN               DATA 0FFH ; ACTIVE
                +2           WDTCN                DATA 097H ;
                +2           ; SFR ADDRESSES END
                +2           
                +2           ; BIT DEFINITIONS
                +2           
                +2           ; ADC0CN0 0xE8
                +2           AD0EN                BIT  ADC0CN0.7   ;
                +2           BURSTEN              BIT  ADC0CN0.6   ;
                +2           AD0INT               BIT  ADC0CN0.5   ;
                +2           AD0BUSY              BIT  ADC0CN0.4   ;
                +2           AD0WINT              BIT  ADC0CN0.3   ;
                +2           ADC0M2               BIT  ADC0CN0.2   ;
                +2           ADC0M1               BIT  ADC0CN0.1   ;
                +2           ADC0M0               BIT  ADC0CN0.0   ;
                +2           
                +2           ; IE 0xA8
                +2           EA                   BIT  IE.7        ; Global Interrupt Enable
                +2           ESPI0                BIT  IE.6        ; Serial Peripheral Interface Enable
                +2           ET2                  BIT  IE.5        ; Timer 2 Interrupt Enable
                +2           ES0                  BIT  IE.4        ; Serial Port Interrupt Enable
                +2           ET1                  BIT  IE.3        ; Timer 1 Interrupt Enable
                +2           EX1                  BIT  IE.2        ; External Interrupt Enable
                +2           ET0                  BIT  IE.1        ; Timer 0 Interrupt Enable
                +2           EX0                  BIT  IE.0        ; External Interrupt 0 Enable
                +2           
                +2           ; IP 0xB8
                +2                                                 ; bit 7 UNUSED
                +2           PSPI0                BIT  IP.6        ; Serial Peripheral Interface Priority
                +2           PT2                  BIT  IP.5        ; Timer 2 Priority
                +2           PS0                  BIT  IP.4        ; Serial Port Priority
                +2           PT1                  BIT  IP.3        ; Timer 1 Priority
                +2           PX1                  BIT  IP.2        ; External Interrupt 1 Priority
                +2           PT0                  BIT  IP.1        ; Timer 0 Priority
                +2           PX0                  BIT  IP.0        ; External Interrupt 0 Priority
                +2           
                +2           ; PCA0CN 0xD8
                +2           CF                   BIT  PCA0CN.7    ; PCA 0 Counter Overflow Flag
                +2           CR                   BIT  PCA0CN.6    ; PCA 0 Counter Run Control Bit
                +2                                                 ; bit 5 UNUSED
                +2                                                 ; bit 4 UNUSED
                +2                                                 ; bit 3 UNUSED
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    38

                +2           CCF2                 BIT  PCA0CN.2    ; PCA 0 Module 2 Interrupt Flag
                +2           CCF1                 BIT  PCA0CN.1    ; PCA 0 Module 1 Interrupt Flag
                +2           CCF0                 BIT  PCA0CN.0    ; PCA 0 Module 0 Interrupt Flag
                +2           
                +2           ; PSW 0xD0
                +2           CY                   BIT  PSW.7       ; Carry Flag
                +2           AC                   BIT  PSW.6       ; Auxiliary Carry Flag
                +2           F0                   BIT  PSW.5       ; User Flag 0
                +2           RS1                  BIT  PSW.4       ; Register Bank Select 1
                +2           RS0                  BIT  PSW.3       ; Register Bank Select 0
                +2           OV                   BIT  PSW.2       ; Overflow Flag
                +2           F1                   BIT  PSW.1       ; User Flag 1
                +2           P                    BIT  PSW.0       ; Accumulator Parity Flag
                +2           
                +2           ; SCON0 0x98
                +2           S0MODE               BIT  SCON0.7     ; Serial Mode Control Bit 0
                +2                                                 ; bit 6 UNUSED
                +2           MCE0                 BIT  SCON0.5     ; Multiprocessor Communication Enable
                +2           REN0                 BIT  SCON0.4     ; Receive Enable
                +2           TB80                 BIT  SCON0.3     ; Transmit Bit 8
                +2           RB80                 BIT  SCON0.2     ; Receive Bit 8
                +2           TI0                  BIT  SCON0.1     ; Transmit Interrupt Flag
                +2           RI0                  BIT  SCON0.0     ; Receive Interrupt Flag
                +2           
                +2           ; SMB0CN 0xC0
                +2           MASTER0              BIT  SMB0CN.7    ; SMBus Master/Slave Indicator
                +2           TXMODE0              BIT  SMB0CN.6    ; SMBus Transmit Mode Indicator
                +2           STA0                 BIT  SMB0CN.5    ; SMBus Start Flag
                +2           STO0                 BIT  SMB0CN.4    ; SMBus Stop Flag
                +2           ACKRQ0               BIT  SMB0CN.3    ; SMBus Acknowledge Request
                +2           ARBLOST0             BIT  SMB0CN.2    ; SMBus Arbitration Lost Indicator
                +2           ACK0                 BIT  SMB0CN.1    ; SMBus Acknowledge
                +2           SI0                  BIT  SMB0CN.0    ; SMBus Interrupt
                +2           
                +2           ; SPI0CN 0xF8
                +2           SPIF                 BIT  SPI0CN.7    ; SPI 0 Interrupt Flag
                +2           WCOL                 BIT  SPI0CN.6    ; SPI 0 Write Collision Flag
                +2           MODF                 BIT  SPI0CN.5    ; SPI 0 Mode Fault Flag
                +2           RXOVRN               BIT  SPI0CN.4    ; SPI 0 RX Overrun Flag
                +2           NSSMD1               BIT  SPI0CN.3    ; SPI 0 NSS Mode Bit 1
                +2           NSSMD0               BIT  SPI0CN.2    ; SPI 0 NSS Mode Bit 0
                +2           TXBMT                BIT  SPI0CN.1    ; SPI 0 Transmit Buffer Empty Flag
                +2           SPIEN                BIT  SPI0CN.0    ; SPI 0 SPI Enable
                +2           
                +2           ; TCON 0x88
                +2           TF1                  BIT  TCON.7      ; Timer 1 Overflow Flag
                +2           TR1                  BIT  TCON.6      ; Timer 1 On/Off Control
                +2           TF0                  BIT  TCON.5      ; Timer 0 Overflow Flag
                +2           TR0                  BIT  TCON.4      ; Timer 0 On/Off Control
                +2           IE1                  BIT  TCON.3      ; Ext. Interrupt 1 Edge Flag
                +2           IT1                  BIT  TCON.2      ; Ext. Interrupt 1 Type
                +2           IE0                  BIT  TCON.1      ; Ext. Interrupt 0 Edge Flag
                +2           IT0                  BIT  TCON.0      ; Ext. Interrupt 0 Type
                +2           
                +2           ; TMR2CN 0xC8
                +2           TF2H                 BIT  TMR2CN.7    ; T2 High-Byte Overflow Flag
                +2           TF2L                 BIT  TMR2CN.6    ; T2 Low-Byte Overflow Flag
                +2           TF2LEN               BIT  TMR2CN.5    ; T2 Low Byte Interrupt Enable
                +2           TF2CEN               BIT  TMR2CN.4    ; T2 Input Capture Enable
                +2           T2SPLIT              BIT  TMR2CN.3    ; T2 Split-Mode Enable
                +2           TR2                  BIT  TMR2CN.2    ; Timer 2 On/Off Control
                +2                                                 ; bit 1 UNUSED
                +2           T2XCLK               BIT  TMR2CN.0    ; T2 External Clock Select
                +1           
                +1           
                +1           ;**** **** **** **** ****
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    39

                +1           ; Uses internal calibrated oscillator set to 24Mhz
                +1           ;**** **** **** **** ****
                +1           
                +1           ;**** **** **** **** ****
                +1           ; Constant definitions
                +1           ;**** **** **** **** ****
                +1           CSEG AT 1A40h
                +1           Eep_ESC_Layout:                 DB      "#FC_Fairy_30A#  "      ; ESC layout tag
                +1           CSEG AT 1A50h
                +1           Eep_ESC_MCU:                    DB      "#BLHELI#F850#   "      ; Project and MCU tag (16 B
                             ytes)
                +1           
                +1           MCU_48MHZ                               EQU     0       ; Set to 1 if MCU can run at 48MHz
                +1           ONE_S_CAPABLE                   EQU     0       ; Set to 1 if ESC can operate at 1S
                +1           PORT3_EXIST                             EQU     0       ; Set to 1 if MCU has port3
                +1           COMP1_USED                              EQU     0       ; Set to 1 if MCU has comparator 1 
                             and it is being used
                +1           LOCK_BYTE_ADDRESS_16K   EQU     3FFFh   ; Address of lock byte if 16k flash size
                +1           LOCK_BYTE_ADDRESS_8K    EQU     1FFFh   ; Address of lock byte if 8k flash size
                +1           HIGH_BEC_VOLTAGE                EQU     0       ; Set to 1 or more if high BEC voltage is s
                             upported
                +1           DAMPED_MODE_ENABLE              EQU     1       ; Damped mode enabled
                +1           NFETON_DELAY                    EQU     6       ; Wait delay from pfets off to nfets on
                +1           PFETON_DELAY                    EQU     1       ; Wait delay from nfets off to pfets on
                +1           ADC_LIMIT_L                             EQU 85  ; Power supply measurement ADC value for wh
                             ich main motor power is limited (low byte)
                +1           ADC_LIMIT_H                             EQU     0       ; Power supply measurement ADC valu
                             e for which main motor power is limited (2 MSBs)
                +1           TEMP_LIMIT                              EQU 103 ; Temperature measurement ADC value for whi
                             ch main motor power is limited (low byte, assuming high byte is 1)
                +1           TEMP_LIMIT_STEP                 EQU     4       ; Temperature measurement ADC value increme
                             nt for which main motor power is further limited
                +1           
                +1           ;**** **** **** **** ****
                +1           ; ESC specific defaults
                +1           ;**** **** **** **** ****
                +1           DEFAULT_PGM_MAIN_SPOOLUP_TIME           EQU 10  ; Main motor spoolup time
                +1           DEFAULT_PGM_MAIN_STARTUP_PWR            EQU 9   ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           DEFAULT_PGM_TAIL_STARTUP_PWR            EQU 9   ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           DEFAULT_PGM_MULTI_STARTUP_PWR           EQU 9   ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           
                +1           ;**** **** **** **** ****
                +1           ; Bootloader definitions
                +1           ;**** **** **** **** ****
                +1           RTX_PORT                                EQU     P0              ; Receive/Transmit port
                +1           RTX_MDOUT                               EQU     P0MDOUT ; Set to 1 for PUSHPULL            
                                          
                +1           RTX_MDIN                                EQU     P0MDIN  ; Set to 1 for DIGITAL             
                                          
                +1           RTX_SKIP                                EQU     P0SKIP  ; Set to 1 for SKIP                
                                          
                +1           RTX_PIN                                 EQU 5           ; RTX pin
                +1           
                +1           SIGNATURE_001                   EQU     0f8h            ; Device signature
                +1           SIGNATURE_002                   EQU     050h
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 0 definitions *
                +1           ;*********************  
                +1           ;                       EQU     7       ;i (Temp)
                +1           Adc_Ip          EQU     6       ;i
                +1           Rcp_In          EQU     5       ;i
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    40

                +1           ;                       EQU     4       ;i (Rcp 1k)
                +1           Mux_C           EQU     3       ;i
                +1           Mux_B           EQU     2       ;i
                +1           Mux_A           EQU     1       ;i
                +1           Comp_Com        EQU     0       ;i
                +1           
                +1           P0_DIGITAL      EQU     NOT((1 SHL Mux_A)+(1 SHL Mux_B)+(1 SHL Mux_C)+(1 SHL Comp_Com)+(1 S
                             HL Adc_Ip))
                +1           P0_INIT         EQU     0FFh
                +1           P0_PUSHPULL     EQU     0
                +1           P0_SKIP         EQU     NOT(1 SHL Rcp_In) AND 0FFh
                +1           
                +1           Get_Rcp_Capture_Values MACRO
                +1                   mov     Temp1, PCA0CPL0                 ; Get PCA capture values
                +1                   mov     Temp2, PCA0CPH0
                +1           ENDM
                +1           Read_Rcp_Int MACRO
                +1                   mov     A, P0
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+4)   ; Is pwm polarity negative?
                +1                   cpl     A                                               ; Yes - invert
                +1           ENDM
                +1           Rcp_Int_Enable MACRO
                +1                   orl     PCA0CPM0, #01h                          ; Interrupt enabled
                +1           ENDM
                +1           Rcp_Int_Disable MACRO
                +1                   anl     PCA0CPM0, #0FEh                 ; Interrupt disabled
                +1           ENDM
                +1           Rcp_Int_First MACRO
                +1                   anl     PCA0CPM0, #0CFh                 
                +1                   jb      Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity positive?
                +1                   orl     PCA0CPM0, #20h                          ; Capture rising edge
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity negative?
                +1                   orl     PCA0CPM0, #10h                          ; Capture falling edge
                +1           ENDM
                +1           Rcp_Int_Second MACRO
                +1                   anl     PCA0CPM0, #0CFh                 
                +1                   jb      Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity positive?
                +1                   orl     PCA0CPM0, #10h                          ; Capture falling edge
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity negative?
                +1                   orl     PCA0CPM0, #20h                          ; Capture rising edge
                +1           ENDM
                +1           Rcp_Clear_Int_Flag MACRO
                +1                   clr     CCF0                                            ; Clear interrupt flag
                +1           ENDM            
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 1 definitions *
                +1           ;*********************
                +1           ;                       EQU     7       ;i
                +1           ;                       EQU     6       ;i
                +1           CnFET           EQU     5       ;o
                +1           CpFET           EQU     4       ;o
                +1           BnFET           EQU     3       ;o
                +1           BpFET           EQU     2       ;o
                +1           AnFET           EQU     1       ;o
                +1           ApFET           EQU     0       ;o
                +1           
                +1           P1_DIGITAL      EQU     (1 SHL AnFET)+(1 SHL BnFET)+(1 SHL CnFET)+(1 SHL ApFET)+(1 SHL BpFE
                             T)+(1 SHL CpFET)
                +1           P1_INIT         EQU     (1 SHL ApFET)+(1 SHL BpFET)+(1 SHL CpFET)               
                +1           P1_PUSHPULL     EQU     (1 SHL AnFET)+(1 SHL BnFET)+(1 SHL CnFET)+(1 SHL ApFET)+(1 SHL BpFE
                             T)+(1 SHL CpFET)
                +1           P1_SKIP         EQU     0
                +1           
                +1           AnFET_on MACRO
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    41

                +1                   setb    P1.AnFET
                +1           ENDM
                +1           AnFET_off MACRO
                +1                   clr     P1.AnFET
                +1           ENDM
                +1           BnFET_on MACRO
                +1                   setb    P1.BnFET
                +1           ENDM
                +1           BnFET_off MACRO
                +1                   clr     P1.BnFET
                +1           ENDM
                +1           CnFET_on MACRO
                +1                   setb    P1.CnFET
                +1           ENDM
                +1           CnFET_off MACRO
                +1                   clr     P1.CnFET
                +1           ENDM
                +1           All_nFETs_Off MACRO
                +1                   clr     P1.AnFET
                +1                   clr     P1.BnFET
                +1                   clr     P1.CnFET
                +1           ENDM
                +1           
                +1           ApFET_on MACRO
                +1                   clr     P1.ApFET
                +1           ENDM
                +1           ApFET_off MACRO
                +1                   setb    P1.ApFET
                +1           ENDM
                +1           BpFET_on MACRO
                +1                   clr     P1.BpFET
                +1           ENDM
                +1           BpFET_off MACRO
                +1                   setb    P1.BpFET
                +1           ENDM
                +1           CpFET_on MACRO
                +1                   clr     P1.CpFET
                +1           ENDM
                +1           CpFET_off MACRO
                +1                   setb    P1.CpFET
                +1           ENDM
                +1           All_pFETs_Off MACRO
                +1                   setb    P1.ApFET
                +1                   setb    P1.BpFET
                +1                   setb    P1.CpFET
                +1           ENDM
                +1           
                +1           Brake_FETs_On MACRO
                +1                   AnFET_on
                +1                   BnFET_on
                +1                   CnFET_on
                +1           ENDM
                +1           Damping_FET_On MACRO
                +1                   mov     A, DampingFET
                +1                   cpl     A
                +1                   anl     P1, A
                +1           ENDM
                +1           
                +1           Set_Comp_Phase_A MACRO
                +1                   mov     CPT0MX, #01h    ; Set comparator multiplexer to phase A
                +1           ENDM
                +1           Set_Comp_Phase_B MACRO
                +1                   mov     CPT0MX, #02h    ; Set comparator multiplexer to phase B
                +1           ENDM
                +1           Set_Comp_Phase_C MACRO
                +1                   mov     CPT0MX, #03h    ; Set comparator multiplexer to phase C
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    42

                +1           ENDM
                +1           Read_Comp_Out MACRO
                +1                   mov     A, CPT0CN               ; Read comparator output
                +1           ENDM
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 2 definitions *
                +1           ;*********************
                +1           DebugPin                EQU     0       ;o
                +1           
                +1           P2_PUSHPULL     EQU     (1 SHL DebugPin)
                +1           
                +1           
                +1           ;**********************
                +1           ; MCU specific macros *
                +1           ;**********************
                +1           Interrupt_Table_Definition MACRO
                +1           CSEG AT 0                               ; Code segment start
                +1                   jmp reset
                +1           CSEG AT 0Bh                     ; Timer0 interrupt      
                +1                   jmp     t0_int  
                +1           CSEG AT 2Bh                     ; Timer2 interrupt      
                +1                   jmp     t2_int  
                +1           CSEG AT 5Bh                     ; PCA interrupt 
                +1                   jmp     pca_int 
                +1           CSEG AT 73h                     ; Timer3 interrupt      
                +1                   jmp     t3_int  
                +1           ENDM
                +1           
                +1           Initialize_Xbar MACRO
                +1                   mov     XBR2, #40h      ; Xbar enabled                  
                +1                   mov     XBR1, #01h      ; CEX0 routed to pin Rcp_In                     
                +1           ENDM
                +1           
                +1           Initialize_Adc MACRO
                +1                   mov     REF0CN, #0Ch    ; Set vdd (3.3V) as reference. Enable temp sensor and bias
                +1                   mov     ADC0CF, #59h    ; ADC clock 2MHz, PGA gain 1
                +1                   mov     ADC0MX, #Adc_Ip; Select ADC input
                +1                   mov     ADC0CN0, #80h   ; ADC enabled 
                +1                   mov     ADC0CN1, #01h   ; Common mode buffer enabled
                +1           ENDM
                +1           Set_Adc_Ip_Volt MACRO
                +1                   mov     ADC0MX, #Adc_Ip; Select ADC input
                +1           ENDM
                +1           Set_Adc_Ip_Temp MACRO
                +1                   mov     ADC0MX, #10h    ; Select temp sensor input
                +1           ENDM
                +1           Start_Adc MACRO
                +1                   mov     ADC0CN0, #90h   ; ADC start
                +1           ENDM
                +1           Read_Adc_Result MACRO
                +1                   mov     Temp1, ADC0L
                +1                   mov     Temp2, ADC0H
                +1           ENDM
                +1           Stop_Adc MACRO
                +1           ENDM
                +1           Set_RPM_Out MACRO
                +1           ENDM
                +1           Clear_RPM_Out MACRO
                +1           ENDM
                +1           Set_MCU_Clk_24MHz MACRO
                +1           ENDM
                +1           Set_MCU_Clk_48MHz MACRO
                +1           ENDM
                             ENDIF
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    43

                    2667     
                    2668     IF BESCNO == Flycolor_Fairy_30A_Multi
                             MODE    EQU     2                               ; Choose mode. Set to 2 for multirotor
                             ;$include (Flycolor_Fairy_30A.inc) ; Select Flycolor Fairy 30A pinout
                +1           ;**** **** **** **** ****
                +1           ;
                +1           ; BLHeli program for controlling brushless motors in helicopters and multirotors
                +1           ;
                +1           ; Copyright 2011, 2012 Steffen Skaug
                +1           ; This program is distributed under the terms of the GNU General Public License
                +1           ;
                +1           ; This file is part of BLHeli.
                +1           ;
                +1           ; BLHeli is free software: you can redistribute it and/or modify
                +1           ; it under the terms of the GNU General Public License as published by
                +1           ; the Free Software Foundation, either version 3 of the License, or
                +1           ; (at your option) any later version.
                +1           ;
                +1           ; BLHeli is distributed in the hope that it will be useful,
                +1           ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                +1           ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                +1           ; GNU General Public License for more details.
                +1           ;
                +1           ; You should have received a copy of the GNU General Public License
                +1           ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                +1           ;
                +1           ;**** **** **** **** ****
                +1           ;
                +1           ; Flycolor Fairy 30A hardware definition file
                +1           ;
                +1           ;**** **** **** **** ****
                +1           
                +1           
                +1           
                +1           ;*********************
                +1           ; Device SiLabs F850
                +1           ;*********************
                +1           ;$include (c8051f850.inc)
                +2           ; PAGE DEFINITIONS
                +2           ACTIVE_PAGE          EQU 000H
                +2           DEBUG_PAGE           EQU 001H
                +2           
                +2           ; SFR ADDRESSES BEGIN
                +2           ADC0AC               DATA 0B3H ; ACTIVE
                +2           ADC0CF               DATA 0BCH ; ACTIVE
                +2           ADC0CN0              DATA 0E8H ; ACTIVE
                +2           ADC0CN1              DATA 0B2H ; ACTIVE
                +2           ADC0GTH              DATA 0C4H ; ACTIVE
                +2           ADC0GTL              DATA 0C3H ; ACTIVE
                +2           ADC0H                DATA 0BEH ; ACTIVE
                +2           ADC0L                DATA 0BDH ; ACTIVE
                +2           ADC0LTH              DATA 0C6H ; ACTIVE
                +2           ADC0LTL              DATA 0C5H ; ACTIVE
                +2           ADC0MX               DATA 0BBH ; ACTIVE
                +2           ADC0PWR              DATA 0DFH ; ACTIVE
                +2           ADC0TK               DATA 0B9H ; ACTIVE
                +2           ACC                  DATA 0E0H ;
                +2           B                    DATA 0F0H ;
                +2           DPH                  DATA 083H ;
                +2           DPL                  DATA 082H ;
                +2           PCON                 DATA 087H ;
                +2           PSW                  DATA 0D0H ;
                +2           SP                   DATA 081H ;
                +2           CRC0AUTO             DATA 0D2H ; ACTIVE
                +2           CRC0CN               DATA 0CEH ; ACTIVE
                +2           CRC0CNT              DATA 0D3H ; ACTIVE
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    44

                +2           CRC0DAT              DATA 0DEH ; ACTIVE
                +2           CRC0FLIP             DATA 0CFH ; ACTIVE
                +2           CRC0IN               DATA 0DDH ; ACTIVE
                +2           CPT0CN               DATA 09BH ; ACTIVE
                +2           CPT0MD               DATA 09DH ; ACTIVE
                +2           CPT0MX               DATA 09FH ; ACTIVE
                +2           CPT1CN               DATA 0BFH ; ACTIVE
                +2           CPT1MD               DATA 0ABH ; ACTIVE
                +2           CPT1MX               DATA 0AAH ; ACTIVE
                +2           DERIVID              DATA 0ADH ; ACTIVE
                +2           DEVICEID             DATA 0B5H ; ACTIVE
                +2           FLSCL                DATA 09AH ; ACTIVE
                +2           REVID                DATA 0B6H ; ACTIVE
                +2           FLKEY                DATA 0B7H ;
                +2           PSCTL                DATA 08FH ;
                +2           EIE1                 DATA 0E6H ;
                +2           EIP1                 DATA 0F3H ; ACTIVE
                +2           IE                   DATA 0A8H ;
                +2           IP                   DATA 0B8H ;
                +2           IT01CF               DATA 0E4H ; ACTIVE
                +2           CKCON                DATA 08EH ; ACTIVE
                +2           CLKSEL               DATA 0A9H ;
                +2           OSCLCN               DATA 0B1H ; ACTIVE
                +2           OSCICL               DATA 0C7H ; ACTIVE
                +2           PCA0CENT             DATA 09EH ; ACTIVE
                +2           PCA0CLR              DATA 09CH ; ACTIVE
                +2           PCA0CN               DATA 0D8H ; ACTIVE
                +2           PCA0CPH0             DATA 0FCH ; ACTIVE
                +2           PCA0CPH1             DATA 0EAH ; ACTIVE
                +2           PCA0CPH2             DATA 0ECH ; ACTIVE
                +2           PCA0CPL0             DATA 0FBH ; ACTIVE
                +2           PCA0CPL1             DATA 0E9H ; ACTIVE
                +2           PCA0CPL2             DATA 0EBH ; ACTIVE
                +2           PCA0CPM0             DATA 0DAH ; ACTIVE
                +2           PCA0CPM1             DATA 0DBH ; ACTIVE
                +2           PCA0CPM2             DATA 0DCH ; ACTIVE
                +2           PCA0H                DATA 0FAH ; ACTIVE
                +2           PCA0L                DATA 0F9H ; ACTIVE
                +2           PCA0MD               DATA 0D9H ; ACTIVE
                +2           PCA0POL              DATA 096H ; ACTIVE
                +2           PCA0PWM              DATA 0F7H ; ACTIVE
                +2           P0                   DATA 080H ;
                +2           P0MASK               DATA 0FEH ; ACTIVE
                +2           P0MAT                DATA 0FDH ; ACTIVE
                +2           P0MDIN               DATA 0F1H ; ACTIVE
                +2           P0MDOUT              DATA 0A4H ; ACTIVE
                +2           P0SKIP               DATA 0D4H ; ACTIVE
                +2           P1                   DATA 090H ; ACTIVE
                +2           P1MASK               DATA 0EEH ; ACTIVE
                +2           P1MAT                DATA 0EDH ; ACTIVE
                +2           P1MDIN               DATA 0F2H ; ACTIVE
                +2           P1MDOUT              DATA 0A5H ; ACTIVE
                +2           P1SKIP               DATA 0D5H ; ACTIVE
                +2           P2                   DATA 0A0H ;
                +2           P2MDOUT              DATA 0A6H ; ACTIVE
                +2           PRTDRV               DATA 0F6H ; ACTIVE
                +2           XBR0                 DATA 0E1H ; ACTIVE
                +2           XBR1                 DATA 0E2H ; ACTIVE
                +2           XBR2                 DATA 0E3H ; ACTIVE
                +2           RSTSRC               DATA 0EFH ; ACTIVE
                +2           SMB0ADM              DATA 0D6H ; ACTIVE
                +2           SMB0ADR              DATA 0D7H ; ACTIVE
                +2           SMB0CF               DATA 0C1H ; ACTIVE
                +2           SMB0CN               DATA 0C0H ; ACTIVE
                +2           SMB0DAT              DATA 0C2H ; ACTIVE
                +2           SMB0TC               DATA 0ACH ; ACTIVE
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    45

                +2           SPI0CFG              DATA 0A1H ; ACTIVE
                +2           SPI0CKR              DATA 0A2H ; ACTIVE
                +2           SPI0CN               DATA 0F8H ; ACTIVE
                +2           SPI0DAT              DATA 0A3H ; ACTIVE
                +2           TCON                 DATA 088H ; ACTIVE
                +2           TH0                  DATA 08CH ; ACTIVE
                +2           TH1                  DATA 08DH ; ACTIVE
                +2           TL0                  DATA 08AH ; ACTIVE
                +2           TL1                  DATA 08BH ; ACTIVE
                +2           TMOD                 DATA 089H ; ACTIVE
                +2           TMR2CN               DATA 0C8H ;
                +2           TMR2H                DATA 0CDH ; ACTIVE
                +2           TMR2L                DATA 0CCH ; ACTIVE
                +2           TMR2RLH              DATA 0CBH ; ACTIVE
                +2           TMR2RLL              DATA 0CAH ; ACTIVE
                +2           TMR3CN               DATA 091H ; ACTIVE
                +2           TMR3H                DATA 095H ; ACTIVE
                +2           TMR3L                DATA 094H ; ACTIVE
                +2           TMR3RLH              DATA 093H ; ACTIVE
                +2           TMR3RLL              DATA 092H ; ACTIVE
                +2           SBUF0                DATA 099H ; ACTIVE
                +2           SCON0                DATA 098H ;
                +2           REF0CN               DATA 0D1H ; ACTIVE
                +2           REG0CN               DATA 0C9H ; ACTIVE
                +2           VDM0CN               DATA 0FFH ; ACTIVE
                +2           WDTCN                DATA 097H ;
                +2           ; SFR ADDRESSES END
                +2           
                +2           ; BIT DEFINITIONS
                +2           
                +2           ; ADC0CN0 0xE8
                +2           AD0EN                BIT  ADC0CN0.7   ;
                +2           BURSTEN              BIT  ADC0CN0.6   ;
                +2           AD0INT               BIT  ADC0CN0.5   ;
                +2           AD0BUSY              BIT  ADC0CN0.4   ;
                +2           AD0WINT              BIT  ADC0CN0.3   ;
                +2           ADC0M2               BIT  ADC0CN0.2   ;
                +2           ADC0M1               BIT  ADC0CN0.1   ;
                +2           ADC0M0               BIT  ADC0CN0.0   ;
                +2           
                +2           ; IE 0xA8
                +2           EA                   BIT  IE.7        ; Global Interrupt Enable
                +2           ESPI0                BIT  IE.6        ; Serial Peripheral Interface Enable
                +2           ET2                  BIT  IE.5        ; Timer 2 Interrupt Enable
                +2           ES0                  BIT  IE.4        ; Serial Port Interrupt Enable
                +2           ET1                  BIT  IE.3        ; Timer 1 Interrupt Enable
                +2           EX1                  BIT  IE.2        ; External Interrupt Enable
                +2           ET0                  BIT  IE.1        ; Timer 0 Interrupt Enable
                +2           EX0                  BIT  IE.0        ; External Interrupt 0 Enable
                +2           
                +2           ; IP 0xB8
                +2                                                 ; bit 7 UNUSED
                +2           PSPI0                BIT  IP.6        ; Serial Peripheral Interface Priority
                +2           PT2                  BIT  IP.5        ; Timer 2 Priority
                +2           PS0                  BIT  IP.4        ; Serial Port Priority
                +2           PT1                  BIT  IP.3        ; Timer 1 Priority
                +2           PX1                  BIT  IP.2        ; External Interrupt 1 Priority
                +2           PT0                  BIT  IP.1        ; Timer 0 Priority
                +2           PX0                  BIT  IP.0        ; External Interrupt 0 Priority
                +2           
                +2           ; PCA0CN 0xD8
                +2           CF                   BIT  PCA0CN.7    ; PCA 0 Counter Overflow Flag
                +2           CR                   BIT  PCA0CN.6    ; PCA 0 Counter Run Control Bit
                +2                                                 ; bit 5 UNUSED
                +2                                                 ; bit 4 UNUSED
                +2                                                 ; bit 3 UNUSED
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    46

                +2           CCF2                 BIT  PCA0CN.2    ; PCA 0 Module 2 Interrupt Flag
                +2           CCF1                 BIT  PCA0CN.1    ; PCA 0 Module 1 Interrupt Flag
                +2           CCF0                 BIT  PCA0CN.0    ; PCA 0 Module 0 Interrupt Flag
                +2           
                +2           ; PSW 0xD0
                +2           CY                   BIT  PSW.7       ; Carry Flag
                +2           AC                   BIT  PSW.6       ; Auxiliary Carry Flag
                +2           F0                   BIT  PSW.5       ; User Flag 0
                +2           RS1                  BIT  PSW.4       ; Register Bank Select 1
                +2           RS0                  BIT  PSW.3       ; Register Bank Select 0
                +2           OV                   BIT  PSW.2       ; Overflow Flag
                +2           F1                   BIT  PSW.1       ; User Flag 1
                +2           P                    BIT  PSW.0       ; Accumulator Parity Flag
                +2           
                +2           ; SCON0 0x98
                +2           S0MODE               BIT  SCON0.7     ; Serial Mode Control Bit 0
                +2                                                 ; bit 6 UNUSED
                +2           MCE0                 BIT  SCON0.5     ; Multiprocessor Communication Enable
                +2           REN0                 BIT  SCON0.4     ; Receive Enable
                +2           TB80                 BIT  SCON0.3     ; Transmit Bit 8
                +2           RB80                 BIT  SCON0.2     ; Receive Bit 8
                +2           TI0                  BIT  SCON0.1     ; Transmit Interrupt Flag
                +2           RI0                  BIT  SCON0.0     ; Receive Interrupt Flag
                +2           
                +2           ; SMB0CN 0xC0
                +2           MASTER0              BIT  SMB0CN.7    ; SMBus Master/Slave Indicator
                +2           TXMODE0              BIT  SMB0CN.6    ; SMBus Transmit Mode Indicator
                +2           STA0                 BIT  SMB0CN.5    ; SMBus Start Flag
                +2           STO0                 BIT  SMB0CN.4    ; SMBus Stop Flag
                +2           ACKRQ0               BIT  SMB0CN.3    ; SMBus Acknowledge Request
                +2           ARBLOST0             BIT  SMB0CN.2    ; SMBus Arbitration Lost Indicator
                +2           ACK0                 BIT  SMB0CN.1    ; SMBus Acknowledge
                +2           SI0                  BIT  SMB0CN.0    ; SMBus Interrupt
                +2           
                +2           ; SPI0CN 0xF8
                +2           SPIF                 BIT  SPI0CN.7    ; SPI 0 Interrupt Flag
                +2           WCOL                 BIT  SPI0CN.6    ; SPI 0 Write Collision Flag
                +2           MODF                 BIT  SPI0CN.5    ; SPI 0 Mode Fault Flag
                +2           RXOVRN               BIT  SPI0CN.4    ; SPI 0 RX Overrun Flag
                +2           NSSMD1               BIT  SPI0CN.3    ; SPI 0 NSS Mode Bit 1
                +2           NSSMD0               BIT  SPI0CN.2    ; SPI 0 NSS Mode Bit 0
                +2           TXBMT                BIT  SPI0CN.1    ; SPI 0 Transmit Buffer Empty Flag
                +2           SPIEN                BIT  SPI0CN.0    ; SPI 0 SPI Enable
                +2           
                +2           ; TCON 0x88
                +2           TF1                  BIT  TCON.7      ; Timer 1 Overflow Flag
                +2           TR1                  BIT  TCON.6      ; Timer 1 On/Off Control
                +2           TF0                  BIT  TCON.5      ; Timer 0 Overflow Flag
                +2           TR0                  BIT  TCON.4      ; Timer 0 On/Off Control
                +2           IE1                  BIT  TCON.3      ; Ext. Interrupt 1 Edge Flag
                +2           IT1                  BIT  TCON.2      ; Ext. Interrupt 1 Type
                +2           IE0                  BIT  TCON.1      ; Ext. Interrupt 0 Edge Flag
                +2           IT0                  BIT  TCON.0      ; Ext. Interrupt 0 Type
                +2           
                +2           ; TMR2CN 0xC8
                +2           TF2H                 BIT  TMR2CN.7    ; T2 High-Byte Overflow Flag
                +2           TF2L                 BIT  TMR2CN.6    ; T2 Low-Byte Overflow Flag
                +2           TF2LEN               BIT  TMR2CN.5    ; T2 Low Byte Interrupt Enable
                +2           TF2CEN               BIT  TMR2CN.4    ; T2 Input Capture Enable
                +2           T2SPLIT              BIT  TMR2CN.3    ; T2 Split-Mode Enable
                +2           TR2                  BIT  TMR2CN.2    ; Timer 2 On/Off Control
                +2                                                 ; bit 1 UNUSED
                +2           T2XCLK               BIT  TMR2CN.0    ; T2 External Clock Select
                +1           
                +1           
                +1           ;**** **** **** **** ****
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    47

                +1           ; Uses internal calibrated oscillator set to 24Mhz
                +1           ;**** **** **** **** ****
                +1           
                +1           ;**** **** **** **** ****
                +1           ; Constant definitions
                +1           ;**** **** **** **** ****
                +1           CSEG AT 1A40h
                +1           Eep_ESC_Layout:                 DB      "#FC_Fairy_30A#  "      ; ESC layout tag
                +1           CSEG AT 1A50h
                +1           Eep_ESC_MCU:                    DB      "#BLHELI#F850#   "      ; Project and MCU tag (16 B
                             ytes)
                +1           
                +1           MCU_48MHZ                               EQU     0       ; Set to 1 if MCU can run at 48MHz
                +1           ONE_S_CAPABLE                   EQU     0       ; Set to 1 if ESC can operate at 1S
                +1           PORT3_EXIST                             EQU     0       ; Set to 1 if MCU has port3
                +1           COMP1_USED                              EQU     0       ; Set to 1 if MCU has comparator 1 
                             and it is being used
                +1           LOCK_BYTE_ADDRESS_16K   EQU     3FFFh   ; Address of lock byte if 16k flash size
                +1           LOCK_BYTE_ADDRESS_8K    EQU     1FFFh   ; Address of lock byte if 8k flash size
                +1           HIGH_BEC_VOLTAGE                EQU     0       ; Set to 1 or more if high BEC voltage is s
                             upported
                +1           DAMPED_MODE_ENABLE              EQU     1       ; Damped mode enabled
                +1           NFETON_DELAY                    EQU     6       ; Wait delay from pfets off to nfets on
                +1           PFETON_DELAY                    EQU     1       ; Wait delay from nfets off to pfets on
                +1           ADC_LIMIT_L                             EQU 85  ; Power supply measurement ADC value for wh
                             ich main motor power is limited (low byte)
                +1           ADC_LIMIT_H                             EQU     0       ; Power supply measurement ADC valu
                             e for which main motor power is limited (2 MSBs)
                +1           TEMP_LIMIT                              EQU 103 ; Temperature measurement ADC value for whi
                             ch main motor power is limited (low byte, assuming high byte is 1)
                +1           TEMP_LIMIT_STEP                 EQU     4       ; Temperature measurement ADC value increme
                             nt for which main motor power is further limited
                +1           
                +1           ;**** **** **** **** ****
                +1           ; ESC specific defaults
                +1           ;**** **** **** **** ****
                +1           DEFAULT_PGM_MAIN_SPOOLUP_TIME           EQU 10  ; Main motor spoolup time
                +1           DEFAULT_PGM_MAIN_STARTUP_PWR            EQU 9   ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           DEFAULT_PGM_TAIL_STARTUP_PWR            EQU 9   ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           DEFAULT_PGM_MULTI_STARTUP_PWR           EQU 9   ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           
                +1           ;**** **** **** **** ****
                +1           ; Bootloader definitions
                +1           ;**** **** **** **** ****
                +1           RTX_PORT                                EQU     P0              ; Receive/Transmit port
                +1           RTX_MDOUT                               EQU     P0MDOUT ; Set to 1 for PUSHPULL            
                                          
                +1           RTX_MDIN                                EQU     P0MDIN  ; Set to 1 for DIGITAL             
                                          
                +1           RTX_SKIP                                EQU     P0SKIP  ; Set to 1 for SKIP                
                                          
                +1           RTX_PIN                                 EQU 5           ; RTX pin
                +1           
                +1           SIGNATURE_001                   EQU     0f8h            ; Device signature
                +1           SIGNATURE_002                   EQU     050h
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 0 definitions *
                +1           ;*********************  
                +1           ;                       EQU     7       ;i (Temp)
                +1           Adc_Ip          EQU     6       ;i
                +1           Rcp_In          EQU     5       ;i
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    48

                +1           ;                       EQU     4       ;i (Rcp 1k)
                +1           Mux_C           EQU     3       ;i
                +1           Mux_B           EQU     2       ;i
                +1           Mux_A           EQU     1       ;i
                +1           Comp_Com        EQU     0       ;i
                +1           
                +1           P0_DIGITAL      EQU     NOT((1 SHL Mux_A)+(1 SHL Mux_B)+(1 SHL Mux_C)+(1 SHL Comp_Com)+(1 S
                             HL Adc_Ip))
                +1           P0_INIT         EQU     0FFh
                +1           P0_PUSHPULL     EQU     0
                +1           P0_SKIP         EQU     NOT(1 SHL Rcp_In) AND 0FFh
                +1           
                +1           Get_Rcp_Capture_Values MACRO
                +1                   mov     Temp1, PCA0CPL0                 ; Get PCA capture values
                +1                   mov     Temp2, PCA0CPH0
                +1           ENDM
                +1           Read_Rcp_Int MACRO
                +1                   mov     A, P0
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+4)   ; Is pwm polarity negative?
                +1                   cpl     A                                               ; Yes - invert
                +1           ENDM
                +1           Rcp_Int_Enable MACRO
                +1                   orl     PCA0CPM0, #01h                          ; Interrupt enabled
                +1           ENDM
                +1           Rcp_Int_Disable MACRO
                +1                   anl     PCA0CPM0, #0FEh                 ; Interrupt disabled
                +1           ENDM
                +1           Rcp_Int_First MACRO
                +1                   anl     PCA0CPM0, #0CFh                 
                +1                   jb      Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity positive?
                +1                   orl     PCA0CPM0, #20h                          ; Capture rising edge
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity negative?
                +1                   orl     PCA0CPM0, #10h                          ; Capture falling edge
                +1           ENDM
                +1           Rcp_Int_Second MACRO
                +1                   anl     PCA0CPM0, #0CFh                 
                +1                   jb      Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity positive?
                +1                   orl     PCA0CPM0, #10h                          ; Capture falling edge
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity negative?
                +1                   orl     PCA0CPM0, #20h                          ; Capture rising edge
                +1           ENDM
                +1           Rcp_Clear_Int_Flag MACRO
                +1                   clr     CCF0                                            ; Clear interrupt flag
                +1           ENDM            
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 1 definitions *
                +1           ;*********************
                +1           ;                       EQU     7       ;i
                +1           ;                       EQU     6       ;i
                +1           CnFET           EQU     5       ;o
                +1           CpFET           EQU     4       ;o
                +1           BnFET           EQU     3       ;o
                +1           BpFET           EQU     2       ;o
                +1           AnFET           EQU     1       ;o
                +1           ApFET           EQU     0       ;o
                +1           
                +1           P1_DIGITAL      EQU     (1 SHL AnFET)+(1 SHL BnFET)+(1 SHL CnFET)+(1 SHL ApFET)+(1 SHL BpFE
                             T)+(1 SHL CpFET)
                +1           P1_INIT         EQU     (1 SHL ApFET)+(1 SHL BpFET)+(1 SHL CpFET)               
                +1           P1_PUSHPULL     EQU     (1 SHL AnFET)+(1 SHL BnFET)+(1 SHL CnFET)+(1 SHL ApFET)+(1 SHL BpFE
                             T)+(1 SHL CpFET)
                +1           P1_SKIP         EQU     0
                +1           
                +1           AnFET_on MACRO
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    49

                +1                   setb    P1.AnFET
                +1           ENDM
                +1           AnFET_off MACRO
                +1                   clr     P1.AnFET
                +1           ENDM
                +1           BnFET_on MACRO
                +1                   setb    P1.BnFET
                +1           ENDM
                +1           BnFET_off MACRO
                +1                   clr     P1.BnFET
                +1           ENDM
                +1           CnFET_on MACRO
                +1                   setb    P1.CnFET
                +1           ENDM
                +1           CnFET_off MACRO
                +1                   clr     P1.CnFET
                +1           ENDM
                +1           All_nFETs_Off MACRO
                +1                   clr     P1.AnFET
                +1                   clr     P1.BnFET
                +1                   clr     P1.CnFET
                +1           ENDM
                +1           
                +1           ApFET_on MACRO
                +1                   clr     P1.ApFET
                +1           ENDM
                +1           ApFET_off MACRO
                +1                   setb    P1.ApFET
                +1           ENDM
                +1           BpFET_on MACRO
                +1                   clr     P1.BpFET
                +1           ENDM
                +1           BpFET_off MACRO
                +1                   setb    P1.BpFET
                +1           ENDM
                +1           CpFET_on MACRO
                +1                   clr     P1.CpFET
                +1           ENDM
                +1           CpFET_off MACRO
                +1                   setb    P1.CpFET
                +1           ENDM
                +1           All_pFETs_Off MACRO
                +1                   setb    P1.ApFET
                +1                   setb    P1.BpFET
                +1                   setb    P1.CpFET
                +1           ENDM
                +1           
                +1           Brake_FETs_On MACRO
                +1                   AnFET_on
                +1                   BnFET_on
                +1                   CnFET_on
                +1           ENDM
                +1           Damping_FET_On MACRO
                +1                   mov     A, DampingFET
                +1                   cpl     A
                +1                   anl     P1, A
                +1           ENDM
                +1           
                +1           Set_Comp_Phase_A MACRO
                +1                   mov     CPT0MX, #01h    ; Set comparator multiplexer to phase A
                +1           ENDM
                +1           Set_Comp_Phase_B MACRO
                +1                   mov     CPT0MX, #02h    ; Set comparator multiplexer to phase B
                +1           ENDM
                +1           Set_Comp_Phase_C MACRO
                +1                   mov     CPT0MX, #03h    ; Set comparator multiplexer to phase C
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    50

                +1           ENDM
                +1           Read_Comp_Out MACRO
                +1                   mov     A, CPT0CN               ; Read comparator output
                +1           ENDM
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 2 definitions *
                +1           ;*********************
                +1           DebugPin                EQU     0       ;o
                +1           
                +1           P2_PUSHPULL     EQU     (1 SHL DebugPin)
                +1           
                +1           
                +1           ;**********************
                +1           ; MCU specific macros *
                +1           ;**********************
                +1           Interrupt_Table_Definition MACRO
                +1           CSEG AT 0                               ; Code segment start
                +1                   jmp reset
                +1           CSEG AT 0Bh                     ; Timer0 interrupt      
                +1                   jmp     t0_int  
                +1           CSEG AT 2Bh                     ; Timer2 interrupt      
                +1                   jmp     t2_int  
                +1           CSEG AT 5Bh                     ; PCA interrupt 
                +1                   jmp     pca_int 
                +1           CSEG AT 73h                     ; Timer3 interrupt      
                +1                   jmp     t3_int  
                +1           ENDM
                +1           
                +1           Initialize_Xbar MACRO
                +1                   mov     XBR2, #40h      ; Xbar enabled                  
                +1                   mov     XBR1, #01h      ; CEX0 routed to pin Rcp_In                     
                +1           ENDM
                +1           
                +1           Initialize_Adc MACRO
                +1                   mov     REF0CN, #0Ch    ; Set vdd (3.3V) as reference. Enable temp sensor and bias
                +1                   mov     ADC0CF, #59h    ; ADC clock 2MHz, PGA gain 1
                +1                   mov     ADC0MX, #Adc_Ip; Select ADC input
                +1                   mov     ADC0CN0, #80h   ; ADC enabled 
                +1                   mov     ADC0CN1, #01h   ; Common mode buffer enabled
                +1           ENDM
                +1           Set_Adc_Ip_Volt MACRO
                +1                   mov     ADC0MX, #Adc_Ip; Select ADC input
                +1           ENDM
                +1           Set_Adc_Ip_Temp MACRO
                +1                   mov     ADC0MX, #10h    ; Select temp sensor input
                +1           ENDM
                +1           Start_Adc MACRO
                +1                   mov     ADC0CN0, #90h   ; ADC start
                +1           ENDM
                +1           Read_Adc_Result MACRO
                +1                   mov     Temp1, ADC0L
                +1                   mov     Temp2, ADC0H
                +1           ENDM
                +1           Stop_Adc MACRO
                +1           ENDM
                +1           Set_RPM_Out MACRO
                +1           ENDM
                +1           Clear_RPM_Out MACRO
                +1           ENDM
                +1           Set_MCU_Clk_24MHz MACRO
                +1           ENDM
                +1           Set_MCU_Clk_48MHz MACRO
                +1           ENDM
                             ENDIF
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    51

                    3179     
                    3180     IF BESCNO == Flycolor_Fairy_V2_30A_Main
                             MODE    EQU     0                               ; Choose mode. Set to 0 for main motor
                             ;$include (Flycolor_Fairy_V2_30A.inc) ; Select Flycolor Fairy V2 30A pinout
                +1           ;**** **** **** **** ****
                +1           ;
                +1           ; BLHeli program for controlling brushless motors in helicopters and multirotors
                +1           ;
                +1           ; Copyright 2011, 2012 Steffen Skaug
                +1           ; This program is distributed under the terms of the GNU General Public License
                +1           ;
                +1           ; This file is part of BLHeli.
                +1           ;
                +1           ; BLHeli is free software: you can redistribute it and/or modify
                +1           ; it under the terms of the GNU General Public License as published by
                +1           ; the Free Software Foundation, either version 3 of the License, or
                +1           ; (at your option) any later version.
                +1           ;
                +1           ; BLHeli is distributed in the hope that it will be useful,
                +1           ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                +1           ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                +1           ; GNU General Public License for more details.
                +1           ;
                +1           ; You should have received a copy of the GNU General Public License
                +1           ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                +1           ;
                +1           ;**** **** **** **** ****
                +1           ;
                +1           ; Flycolor Fairy V2 30A hardware definition file
                +1           ;
                +1           ;**** **** **** **** ****
                +1           
                +1           
                +1           
                +1           ;*********************
                +1           ; Device SiLabs F850
                +1           ;*********************
                +1           ;$include (c8051f850.inc)
                +2           ; PAGE DEFINITIONS
                +2           ACTIVE_PAGE          EQU 000H
                +2           DEBUG_PAGE           EQU 001H
                +2           
                +2           ; SFR ADDRESSES BEGIN
                +2           ADC0AC               DATA 0B3H ; ACTIVE
                +2           ADC0CF               DATA 0BCH ; ACTIVE
                +2           ADC0CN0              DATA 0E8H ; ACTIVE
                +2           ADC0CN1              DATA 0B2H ; ACTIVE
                +2           ADC0GTH              DATA 0C4H ; ACTIVE
                +2           ADC0GTL              DATA 0C3H ; ACTIVE
                +2           ADC0H                DATA 0BEH ; ACTIVE
                +2           ADC0L                DATA 0BDH ; ACTIVE
                +2           ADC0LTH              DATA 0C6H ; ACTIVE
                +2           ADC0LTL              DATA 0C5H ; ACTIVE
                +2           ADC0MX               DATA 0BBH ; ACTIVE
                +2           ADC0PWR              DATA 0DFH ; ACTIVE
                +2           ADC0TK               DATA 0B9H ; ACTIVE
                +2           ACC                  DATA 0E0H ;
                +2           B                    DATA 0F0H ;
                +2           DPH                  DATA 083H ;
                +2           DPL                  DATA 082H ;
                +2           PCON                 DATA 087H ;
                +2           PSW                  DATA 0D0H ;
                +2           SP                   DATA 081H ;
                +2           CRC0AUTO             DATA 0D2H ; ACTIVE
                +2           CRC0CN               DATA 0CEH ; ACTIVE
                +2           CRC0CNT              DATA 0D3H ; ACTIVE
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    52

                +2           CRC0DAT              DATA 0DEH ; ACTIVE
                +2           CRC0FLIP             DATA 0CFH ; ACTIVE
                +2           CRC0IN               DATA 0DDH ; ACTIVE
                +2           CPT0CN               DATA 09BH ; ACTIVE
                +2           CPT0MD               DATA 09DH ; ACTIVE
                +2           CPT0MX               DATA 09FH ; ACTIVE
                +2           CPT1CN               DATA 0BFH ; ACTIVE
                +2           CPT1MD               DATA 0ABH ; ACTIVE
                +2           CPT1MX               DATA 0AAH ; ACTIVE
                +2           DERIVID              DATA 0ADH ; ACTIVE
                +2           DEVICEID             DATA 0B5H ; ACTIVE
                +2           FLSCL                DATA 09AH ; ACTIVE
                +2           REVID                DATA 0B6H ; ACTIVE
                +2           FLKEY                DATA 0B7H ;
                +2           PSCTL                DATA 08FH ;
                +2           EIE1                 DATA 0E6H ;
                +2           EIP1                 DATA 0F3H ; ACTIVE
                +2           IE                   DATA 0A8H ;
                +2           IP                   DATA 0B8H ;
                +2           IT01CF               DATA 0E4H ; ACTIVE
                +2           CKCON                DATA 08EH ; ACTIVE
                +2           CLKSEL               DATA 0A9H ;
                +2           OSCLCN               DATA 0B1H ; ACTIVE
                +2           OSCICL               DATA 0C7H ; ACTIVE
                +2           PCA0CENT             DATA 09EH ; ACTIVE
                +2           PCA0CLR              DATA 09CH ; ACTIVE
                +2           PCA0CN               DATA 0D8H ; ACTIVE
                +2           PCA0CPH0             DATA 0FCH ; ACTIVE
                +2           PCA0CPH1             DATA 0EAH ; ACTIVE
                +2           PCA0CPH2             DATA 0ECH ; ACTIVE
                +2           PCA0CPL0             DATA 0FBH ; ACTIVE
                +2           PCA0CPL1             DATA 0E9H ; ACTIVE
                +2           PCA0CPL2             DATA 0EBH ; ACTIVE
                +2           PCA0CPM0             DATA 0DAH ; ACTIVE
                +2           PCA0CPM1             DATA 0DBH ; ACTIVE
                +2           PCA0CPM2             DATA 0DCH ; ACTIVE
                +2           PCA0H                DATA 0FAH ; ACTIVE
                +2           PCA0L                DATA 0F9H ; ACTIVE
                +2           PCA0MD               DATA 0D9H ; ACTIVE
                +2           PCA0POL              DATA 096H ; ACTIVE
                +2           PCA0PWM              DATA 0F7H ; ACTIVE
                +2           P0                   DATA 080H ;
                +2           P0MASK               DATA 0FEH ; ACTIVE
                +2           P0MAT                DATA 0FDH ; ACTIVE
                +2           P0MDIN               DATA 0F1H ; ACTIVE
                +2           P0MDOUT              DATA 0A4H ; ACTIVE
                +2           P0SKIP               DATA 0D4H ; ACTIVE
                +2           P1                   DATA 090H ; ACTIVE
                +2           P1MASK               DATA 0EEH ; ACTIVE
                +2           P1MAT                DATA 0EDH ; ACTIVE
                +2           P1MDIN               DATA 0F2H ; ACTIVE
                +2           P1MDOUT              DATA 0A5H ; ACTIVE
                +2           P1SKIP               DATA 0D5H ; ACTIVE
                +2           P2                   DATA 0A0H ;
                +2           P2MDOUT              DATA 0A6H ; ACTIVE
                +2           PRTDRV               DATA 0F6H ; ACTIVE
                +2           XBR0                 DATA 0E1H ; ACTIVE
                +2           XBR1                 DATA 0E2H ; ACTIVE
                +2           XBR2                 DATA 0E3H ; ACTIVE
                +2           RSTSRC               DATA 0EFH ; ACTIVE
                +2           SMB0ADM              DATA 0D6H ; ACTIVE
                +2           SMB0ADR              DATA 0D7H ; ACTIVE
                +2           SMB0CF               DATA 0C1H ; ACTIVE
                +2           SMB0CN               DATA 0C0H ; ACTIVE
                +2           SMB0DAT              DATA 0C2H ; ACTIVE
                +2           SMB0TC               DATA 0ACH ; ACTIVE
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    53

                +2           SPI0CFG              DATA 0A1H ; ACTIVE
                +2           SPI0CKR              DATA 0A2H ; ACTIVE
                +2           SPI0CN               DATA 0F8H ; ACTIVE
                +2           SPI0DAT              DATA 0A3H ; ACTIVE
                +2           TCON                 DATA 088H ; ACTIVE
                +2           TH0                  DATA 08CH ; ACTIVE
                +2           TH1                  DATA 08DH ; ACTIVE
                +2           TL0                  DATA 08AH ; ACTIVE
                +2           TL1                  DATA 08BH ; ACTIVE
                +2           TMOD                 DATA 089H ; ACTIVE
                +2           TMR2CN               DATA 0C8H ;
                +2           TMR2H                DATA 0CDH ; ACTIVE
                +2           TMR2L                DATA 0CCH ; ACTIVE
                +2           TMR2RLH              DATA 0CBH ; ACTIVE
                +2           TMR2RLL              DATA 0CAH ; ACTIVE
                +2           TMR3CN               DATA 091H ; ACTIVE
                +2           TMR3H                DATA 095H ; ACTIVE
                +2           TMR3L                DATA 094H ; ACTIVE
                +2           TMR3RLH              DATA 093H ; ACTIVE
                +2           TMR3RLL              DATA 092H ; ACTIVE
                +2           SBUF0                DATA 099H ; ACTIVE
                +2           SCON0                DATA 098H ;
                +2           REF0CN               DATA 0D1H ; ACTIVE
                +2           REG0CN               DATA 0C9H ; ACTIVE
                +2           VDM0CN               DATA 0FFH ; ACTIVE
                +2           WDTCN                DATA 097H ;
                +2           ; SFR ADDRESSES END
                +2           
                +2           ; BIT DEFINITIONS
                +2           
                +2           ; ADC0CN0 0xE8
                +2           AD0EN                BIT  ADC0CN0.7   ;
                +2           BURSTEN              BIT  ADC0CN0.6   ;
                +2           AD0INT               BIT  ADC0CN0.5   ;
                +2           AD0BUSY              BIT  ADC0CN0.4   ;
                +2           AD0WINT              BIT  ADC0CN0.3   ;
                +2           ADC0M2               BIT  ADC0CN0.2   ;
                +2           ADC0M1               BIT  ADC0CN0.1   ;
                +2           ADC0M0               BIT  ADC0CN0.0   ;
                +2           
                +2           ; IE 0xA8
                +2           EA                   BIT  IE.7        ; Global Interrupt Enable
                +2           ESPI0                BIT  IE.6        ; Serial Peripheral Interface Enable
                +2           ET2                  BIT  IE.5        ; Timer 2 Interrupt Enable
                +2           ES0                  BIT  IE.4        ; Serial Port Interrupt Enable
                +2           ET1                  BIT  IE.3        ; Timer 1 Interrupt Enable
                +2           EX1                  BIT  IE.2        ; External Interrupt Enable
                +2           ET0                  BIT  IE.1        ; Timer 0 Interrupt Enable
                +2           EX0                  BIT  IE.0        ; External Interrupt 0 Enable
                +2           
                +2           ; IP 0xB8
                +2                                                 ; bit 7 UNUSED
                +2           PSPI0                BIT  IP.6        ; Serial Peripheral Interface Priority
                +2           PT2                  BIT  IP.5        ; Timer 2 Priority
                +2           PS0                  BIT  IP.4        ; Serial Port Priority
                +2           PT1                  BIT  IP.3        ; Timer 1 Priority
                +2           PX1                  BIT  IP.2        ; External Interrupt 1 Priority
                +2           PT0                  BIT  IP.1        ; Timer 0 Priority
                +2           PX0                  BIT  IP.0        ; External Interrupt 0 Priority
                +2           
                +2           ; PCA0CN 0xD8
                +2           CF                   BIT  PCA0CN.7    ; PCA 0 Counter Overflow Flag
                +2           CR                   BIT  PCA0CN.6    ; PCA 0 Counter Run Control Bit
                +2                                                 ; bit 5 UNUSED
                +2                                                 ; bit 4 UNUSED
                +2                                                 ; bit 3 UNUSED
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    54

                +2           CCF2                 BIT  PCA0CN.2    ; PCA 0 Module 2 Interrupt Flag
                +2           CCF1                 BIT  PCA0CN.1    ; PCA 0 Module 1 Interrupt Flag
                +2           CCF0                 BIT  PCA0CN.0    ; PCA 0 Module 0 Interrupt Flag
                +2           
                +2           ; PSW 0xD0
                +2           CY                   BIT  PSW.7       ; Carry Flag
                +2           AC                   BIT  PSW.6       ; Auxiliary Carry Flag
                +2           F0                   BIT  PSW.5       ; User Flag 0
                +2           RS1                  BIT  PSW.4       ; Register Bank Select 1
                +2           RS0                  BIT  PSW.3       ; Register Bank Select 0
                +2           OV                   BIT  PSW.2       ; Overflow Flag
                +2           F1                   BIT  PSW.1       ; User Flag 1
                +2           P                    BIT  PSW.0       ; Accumulator Parity Flag
                +2           
                +2           ; SCON0 0x98
                +2           S0MODE               BIT  SCON0.7     ; Serial Mode Control Bit 0
                +2                                                 ; bit 6 UNUSED
                +2           MCE0                 BIT  SCON0.5     ; Multiprocessor Communication Enable
                +2           REN0                 BIT  SCON0.4     ; Receive Enable
                +2           TB80                 BIT  SCON0.3     ; Transmit Bit 8
                +2           RB80                 BIT  SCON0.2     ; Receive Bit 8
                +2           TI0                  BIT  SCON0.1     ; Transmit Interrupt Flag
                +2           RI0                  BIT  SCON0.0     ; Receive Interrupt Flag
                +2           
                +2           ; SMB0CN 0xC0
                +2           MASTER0              BIT  SMB0CN.7    ; SMBus Master/Slave Indicator
                +2           TXMODE0              BIT  SMB0CN.6    ; SMBus Transmit Mode Indicator
                +2           STA0                 BIT  SMB0CN.5    ; SMBus Start Flag
                +2           STO0                 BIT  SMB0CN.4    ; SMBus Stop Flag
                +2           ACKRQ0               BIT  SMB0CN.3    ; SMBus Acknowledge Request
                +2           ARBLOST0             BIT  SMB0CN.2    ; SMBus Arbitration Lost Indicator
                +2           ACK0                 BIT  SMB0CN.1    ; SMBus Acknowledge
                +2           SI0                  BIT  SMB0CN.0    ; SMBus Interrupt
                +2           
                +2           ; SPI0CN 0xF8
                +2           SPIF                 BIT  SPI0CN.7    ; SPI 0 Interrupt Flag
                +2           WCOL                 BIT  SPI0CN.6    ; SPI 0 Write Collision Flag
                +2           MODF                 BIT  SPI0CN.5    ; SPI 0 Mode Fault Flag
                +2           RXOVRN               BIT  SPI0CN.4    ; SPI 0 RX Overrun Flag
                +2           NSSMD1               BIT  SPI0CN.3    ; SPI 0 NSS Mode Bit 1
                +2           NSSMD0               BIT  SPI0CN.2    ; SPI 0 NSS Mode Bit 0
                +2           TXBMT                BIT  SPI0CN.1    ; SPI 0 Transmit Buffer Empty Flag
                +2           SPIEN                BIT  SPI0CN.0    ; SPI 0 SPI Enable
                +2           
                +2           ; TCON 0x88
                +2           TF1                  BIT  TCON.7      ; Timer 1 Overflow Flag
                +2           TR1                  BIT  TCON.6      ; Timer 1 On/Off Control
                +2           TF0                  BIT  TCON.5      ; Timer 0 Overflow Flag
                +2           TR0                  BIT  TCON.4      ; Timer 0 On/Off Control
                +2           IE1                  BIT  TCON.3      ; Ext. Interrupt 1 Edge Flag
                +2           IT1                  BIT  TCON.2      ; Ext. Interrupt 1 Type
                +2           IE0                  BIT  TCON.1      ; Ext. Interrupt 0 Edge Flag
                +2           IT0                  BIT  TCON.0      ; Ext. Interrupt 0 Type
                +2           
                +2           ; TMR2CN 0xC8
                +2           TF2H                 BIT  TMR2CN.7    ; T2 High-Byte Overflow Flag
                +2           TF2L                 BIT  TMR2CN.6    ; T2 Low-Byte Overflow Flag
                +2           TF2LEN               BIT  TMR2CN.5    ; T2 Low Byte Interrupt Enable
                +2           TF2CEN               BIT  TMR2CN.4    ; T2 Input Capture Enable
                +2           T2SPLIT              BIT  TMR2CN.3    ; T2 Split-Mode Enable
                +2           TR2                  BIT  TMR2CN.2    ; Timer 2 On/Off Control
                +2                                                 ; bit 1 UNUSED
                +2           T2XCLK               BIT  TMR2CN.0    ; T2 External Clock Select
                +1           
                +1           
                +1           ;**** **** **** **** ****
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    55

                +1           ; Uses internal calibrated oscillator set to 24Mhz
                +1           ;**** **** **** **** ****
                +1           
                +1           ;**** **** **** **** ****
                +1           ; Constant definitions
                +1           ;**** **** **** **** ****
                +1           CSEG AT 1A40h
                +1           Eep_ESC_Layout:         DB      "#FC_FairyV2_30A#"      ; ESC layout tag
                +1           CSEG AT 1A50h
                +1           Eep_ESC_MCU:                    DB      "#BLHELI#F850#   "      ; Project and MCU tag (16 B
                             ytes)
                +1           
                +1           MCU_48MHZ                               EQU     0       ; Set to 1 if MCU can run at 48MHz
                +1           ONE_S_CAPABLE                   EQU     0       ; Set to 1 if ESC can operate at 1S
                +1           PORT3_EXIST                     EQU     0       ; Set to 1 if MCU has port3
                +1           COMP1_USED                      EQU     0       ; Set to 1 if MCU has comparator 1 and it i
                             s being used
                +1           LOCK_BYTE_ADDRESS_16K   EQU     3FFFh   ; Address of lock byte if 16k flash size
                +1           LOCK_BYTE_ADDRESS_8K    EQU     1FFFh   ; Address of lock byte if 8k flash size
                +1           HIGH_BEC_VOLTAGE                EQU     0       ; Set to 1 or more if high BEC voltage is s
                             upported
                +1           DAMPED_MODE_ENABLE              EQU     1       ; Damped mode enabled
                +1           NFETON_DELAY                    EQU     8       ; Wait delay from pfets off to nfets on
                +1           PFETON_DELAY                    EQU     8       ; Wait delay from nfets off to pfets on
                +1           ADC_LIMIT_L                     EQU     85      ; Power supply measurement ADC value for wh
                             ich main motor power is limited (low byte)
                +1           ADC_LIMIT_H                     EQU     0       ; Power supply measurement ADC value for wh
                             ich main motor power is limited (2 MSBs)
                +1           TEMP_LIMIT                      EQU     103     ; Temperature measurement ADC value for whi
                             ch main motor power is limited (low byte, assuming high byte is 1)
                +1           TEMP_LIMIT_STEP         EQU     4       ; Temperature measurement ADC value increment for w
                             hich main motor power is further limited
                +1           
                +1           ;**** **** **** **** ****
                +1           ; ESC specific defaults
                +1           ;**** **** **** **** ****
                +1           DEFAULT_PGM_MAIN_SPOOLUP_TIME           EQU 10  ; Main motor spoolup time
                +1           DEFAULT_PGM_MAIN_STARTUP_PWR            EQU 9   ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           DEFAULT_PGM_TAIL_STARTUP_PWR            EQU 9   ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           DEFAULT_PGM_MULTI_STARTUP_PWR           EQU 9   ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           
                +1           ;**** **** **** **** ****
                +1           ; Bootloader definitions
                +1           ;**** **** **** **** ****
                +1           RTX_PORT                                EQU P0          ; Receive/Transmit port
                +1           RTX_MDOUT                               EQU     P0MDOUT ; Set to 1 for PUSHPULL            
                                          
                +1           RTX_MDIN                                EQU     P0MDIN  ; Set to 1 for DIGITAL             
                                          
                +1           RTX_SKIP                                EQU     P0SKIP  ; Set to 1 for SKIP                
                                          
                +1           RTX_PIN                                 EQU 5           ; RTX pin
                +1           
                +1           SIGNATURE_001                   EQU     0f8h            ; Device signature
                +1           SIGNATURE_002                   EQU     050h
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 0 definitions *
                +1           ;*********************  
                +1           ;                       EQU     7       ;i (Temp)
                +1           Adc_Ip          EQU     6       ;i
                +1           Rcp_In          EQU     5       ;i
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    56

                +1           ;                       EQU     4       ;i (Rcp 1k)
                +1           Mux_C           EQU     3       ;i
                +1           Mux_B           EQU     2       ;i
                +1           Mux_A           EQU     1       ;i
                +1           Comp_Com        EQU     0       ;i
                +1           
                +1           P0_DIGITAL      EQU     NOT((1 SHL Mux_A)+(1 SHL Mux_B)+(1 SHL Mux_C)+(1 SHL Comp_Com)+(1 S
                             HL Adc_Ip))
                +1           P0_INIT         EQU     0FFh
                +1           P0_PUSHPULL     EQU     0
                +1           P0_SKIP         EQU     NOT(1 SHL Rcp_In) AND 0FFh
                +1           
                +1           Get_Rcp_Capture_Values MACRO
                +1                   mov     Temp1, PCA0CPL0                 ; Get PCA capture values
                +1                   mov     Temp2, PCA0CPH0
                +1           ENDM
                +1           Read_Rcp_Int MACRO
                +1                   mov     A, P0
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+4)   ; Is pwm polarity negative?
                +1                   cpl     A                                               ; Yes - invert
                +1           ENDM
                +1           Rcp_Int_Enable MACRO
                +1                   orl     PCA0CPM0, #01h                          ; Interrupt enabled
                +1           ENDM
                +1           Rcp_Int_Disable MACRO
                +1                   anl     PCA0CPM0, #0FEh                 ; Interrupt disabled
                +1           ENDM
                +1           Rcp_Int_First MACRO
                +1                   anl     PCA0CPM0, #0CFh                 
                +1                   jb      Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity positive?
                +1                   orl     PCA0CPM0, #20h                          ; Capture rising edge
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity negative?
                +1                   orl     PCA0CPM0, #10h                          ; Capture falling edge
                +1           ENDM
                +1           Rcp_Int_Second MACRO
                +1                   anl     PCA0CPM0, #0CFh                 
                +1                   jb      Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity positive?
                +1                   orl     PCA0CPM0, #10h                          ; Capture falling edge
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity negative?
                +1                   orl     PCA0CPM0, #20h                          ; Capture rising edge
                +1           ENDM
                +1           Rcp_Clear_Int_Flag MACRO
                +1                   clr     CCF0                                            ; Clear interrupt flag
                +1           ENDM            
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 1 definitions *
                +1           ;*********************
                +1           ;                       EQU     7       ;i
                +1           ;                       EQU     6       ;i
                +1           CnFET           EQU     5       ;o
                +1           CpFET           EQU     4       ;o
                +1           BnFET           EQU     3       ;o
                +1           BpFET           EQU     2       ;o
                +1           AnFET           EQU     1       ;o
                +1           ApFET           EQU     0       ;o
                +1           
                +1           P1_DIGITAL      EQU     (1 SHL AnFET)+(1 SHL BnFET)+(1 SHL CnFET)+(1 SHL ApFET)+(1 SHL BpFE
                             T)+(1 SHL CpFET)
                +1           P1_INIT         EQU     0               
                +1           P1_PUSHPULL     EQU     (1 SHL AnFET)+(1 SHL BnFET)+(1 SHL CnFET)+(1 SHL ApFET)+(1 SHL BpFE
                             T)+(1 SHL CpFET)
                +1           P1_SKIP         EQU     0
                +1           
                +1           AnFET_on MACRO
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    57

                +1                   setb    P1.AnFET
                +1           ENDM
                +1           AnFET_off MACRO
                +1                   clr     P1.AnFET
                +1           ENDM
                +1           BnFET_on MACRO
                +1                   setb    P1.BnFET
                +1           ENDM
                +1           BnFET_off MACRO
                +1                   clr     P1.BnFET
                +1           ENDM
                +1           CnFET_on MACRO
                +1                   setb    P1.CnFET
                +1           ENDM
                +1           CnFET_off MACRO
                +1                   clr     P1.CnFET
                +1           ENDM
                +1           All_nFETs_Off MACRO
                +1                   clr     P1.AnFET
                +1                   clr     P1.BnFET
                +1                   clr     P1.CnFET
                +1           ENDM
                +1           
                +1           ApFET_on MACRO
                +1                   setb    P1.ApFET
                +1           ENDM
                +1           ApFET_off MACRO
                +1                   clr     P1.ApFET
                +1           ENDM
                +1           BpFET_on MACRO
                +1                   setb    P1.BpFET
                +1           ENDM
                +1           BpFET_off MACRO
                +1                   clr     P1.BpFET
                +1           ENDM
                +1           CpFET_on MACRO
                +1                   setb    P1.CpFET
                +1           ENDM
                +1           CpFET_off MACRO
                +1                   clr     P1.CpFET
                +1           ENDM
                +1           All_pFETs_Off MACRO
                +1                   clr     P1.ApFET
                +1                   clr     P1.BpFET
                +1                   clr     P1.CpFET
                +1           ENDM
                +1           
                +1           Brake_FETs_On   MACRO
                +1                   AnFET_on
                +1                   BnFET_on
                +1                   CnFET_on
                +1           ENDM
                +1           Damping_FET_On MACRO
                +1                   mov     A, DampingFET
                +1                   orl     P1, A
                +1           ENDM
                +1           
                +1           Set_Comp_Phase_A MACRO
                +1                   mov     CPT0MX, #01h    ; Set comparator multiplexer to phase A
                +1           ENDM
                +1           Set_Comp_Phase_B MACRO
                +1                   mov     CPT0MX, #02h    ; Set comparator multiplexer to phase B
                +1           ENDM
                +1           Set_Comp_Phase_C MACRO
                +1                   mov     CPT0MX, #03h    ; Set comparator multiplexer to phase C
                +1           ENDM
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    58

                +1           Read_Comp_Out MACRO
                +1                   mov     A, CPT0CN               ; Read comparator output
                +1           ENDM
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 2 definitions *
                +1           ;*********************
                +1           DebugPin                EQU     0       ;o
                +1           
                +1           P2_PUSHPULL     EQU     (1 SHL DebugPin)
                +1           
                +1           
                +1           ;**********************
                +1           ; MCU specific macros *
                +1           ;**********************
                +1           Interrupt_Table_Definition MACRO
                +1           CSEG AT 0                               ; Code segment start
                +1                   jmp reset
                +1           CSEG AT 0Bh                     ; Timer0 interrupt      
                +1                   jmp     t0_int  
                +1           CSEG AT 2Bh                     ; Timer2 interrupt      
                +1                   jmp     t2_int  
                +1           CSEG AT 5Bh                     ; PCA interrupt 
                +1                   jmp     pca_int 
                +1           CSEG AT 73h                     ; Timer3 interrupt      
                +1                   jmp     t3_int  
                +1           ENDM
                +1           
                +1           Initialize_Xbar MACRO
                +1                   mov     XBR2, #40h      ; Xbar enabled                  
                +1                   mov     XBR1, #01h      ; CEX0 routed to pin Rcp_In                     
                +1           ENDM
                +1           
                +1           Initialize_Adc MACRO
                +1                   mov     REF0CN, #0Ch    ; Set vdd (3.3V) as reference. Enable temp sensor and bias
                +1                   mov     ADC0CF, #59h    ; ADC clock 2MHz, PGA gain 1
                +1                   mov     ADC0MX, #Adc_Ip; Select ADC input
                +1                   mov     ADC0CN0, #80h   ; ADC enabled 
                +1                   mov     ADC0CN1, #01h   ; Common mode buffer enabled
                +1           ENDM
                +1           Set_Adc_Ip_Volt MACRO
                +1                   mov     ADC0MX, #Adc_Ip; Select ADC input
                +1           ENDM
                +1           Set_Adc_Ip_Temp MACRO
                +1                   mov     ADC0MX, #10h    ; Select temp sensor input
                +1           ENDM
                +1           Start_Adc MACRO
                +1                   mov     ADC0CN0, #90h   ; ADC start
                +1           ENDM
                +1           Read_Adc_Result MACRO
                +1                   mov     Temp1, ADC0L
                +1                   mov     Temp2, ADC0H
                +1           ENDM
                +1           Stop_Adc MACRO
                +1           ENDM
                +1           Set_RPM_Out MACRO
                +1           ENDM
                +1           Clear_RPM_Out MACRO
                +1           ENDM
                +1           Set_MCU_Clk_24MHz MACRO
                +1           ENDM
                +1           Set_MCU_Clk_48MHz MACRO
                +1           ENDM
                             ENDIF
                    3690     
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    59

                    3691     IF BESCNO == Flycolor_Fairy_V2_30A_Tail
                             MODE    EQU     1                               ; Choose mode. Set to 1 for tail motor
                             ;$include (Flycolor_Fairy_V2_30A.inc) ; Select Flycolor Fairy V2 30A pinout
                +1           ;**** **** **** **** ****
                +1           ;
                +1           ; BLHeli program for controlling brushless motors in helicopters and multirotors
                +1           ;
                +1           ; Copyright 2011, 2012 Steffen Skaug
                +1           ; This program is distributed under the terms of the GNU General Public License
                +1           ;
                +1           ; This file is part of BLHeli.
                +1           ;
                +1           ; BLHeli is free software: you can redistribute it and/or modify
                +1           ; it under the terms of the GNU General Public License as published by
                +1           ; the Free Software Foundation, either version 3 of the License, or
                +1           ; (at your option) any later version.
                +1           ;
                +1           ; BLHeli is distributed in the hope that it will be useful,
                +1           ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                +1           ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                +1           ; GNU General Public License for more details.
                +1           ;
                +1           ; You should have received a copy of the GNU General Public License
                +1           ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                +1           ;
                +1           ;**** **** **** **** ****
                +1           ;
                +1           ; Flycolor Fairy V2 30A hardware definition file
                +1           ;
                +1           ;**** **** **** **** ****
                +1           
                +1           
                +1           
                +1           ;*********************
                +1           ; Device SiLabs F850
                +1           ;*********************
                +1           ;$include (c8051f850.inc)
                +2           ; PAGE DEFINITIONS
                +2           ACTIVE_PAGE          EQU 000H
                +2           DEBUG_PAGE           EQU 001H
                +2           
                +2           ; SFR ADDRESSES BEGIN
                +2           ADC0AC               DATA 0B3H ; ACTIVE
                +2           ADC0CF               DATA 0BCH ; ACTIVE
                +2           ADC0CN0              DATA 0E8H ; ACTIVE
                +2           ADC0CN1              DATA 0B2H ; ACTIVE
                +2           ADC0GTH              DATA 0C4H ; ACTIVE
                +2           ADC0GTL              DATA 0C3H ; ACTIVE
                +2           ADC0H                DATA 0BEH ; ACTIVE
                +2           ADC0L                DATA 0BDH ; ACTIVE
                +2           ADC0LTH              DATA 0C6H ; ACTIVE
                +2           ADC0LTL              DATA 0C5H ; ACTIVE
                +2           ADC0MX               DATA 0BBH ; ACTIVE
                +2           ADC0PWR              DATA 0DFH ; ACTIVE
                +2           ADC0TK               DATA 0B9H ; ACTIVE
                +2           ACC                  DATA 0E0H ;
                +2           B                    DATA 0F0H ;
                +2           DPH                  DATA 083H ;
                +2           DPL                  DATA 082H ;
                +2           PCON                 DATA 087H ;
                +2           PSW                  DATA 0D0H ;
                +2           SP                   DATA 081H ;
                +2           CRC0AUTO             DATA 0D2H ; ACTIVE
                +2           CRC0CN               DATA 0CEH ; ACTIVE
                +2           CRC0CNT              DATA 0D3H ; ACTIVE
                +2           CRC0DAT              DATA 0DEH ; ACTIVE
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    60

                +2           CRC0FLIP             DATA 0CFH ; ACTIVE
                +2           CRC0IN               DATA 0DDH ; ACTIVE
                +2           CPT0CN               DATA 09BH ; ACTIVE
                +2           CPT0MD               DATA 09DH ; ACTIVE
                +2           CPT0MX               DATA 09FH ; ACTIVE
                +2           CPT1CN               DATA 0BFH ; ACTIVE
                +2           CPT1MD               DATA 0ABH ; ACTIVE
                +2           CPT1MX               DATA 0AAH ; ACTIVE
                +2           DERIVID              DATA 0ADH ; ACTIVE
                +2           DEVICEID             DATA 0B5H ; ACTIVE
                +2           FLSCL                DATA 09AH ; ACTIVE
                +2           REVID                DATA 0B6H ; ACTIVE
                +2           FLKEY                DATA 0B7H ;
                +2           PSCTL                DATA 08FH ;
                +2           EIE1                 DATA 0E6H ;
                +2           EIP1                 DATA 0F3H ; ACTIVE
                +2           IE                   DATA 0A8H ;
                +2           IP                   DATA 0B8H ;
                +2           IT01CF               DATA 0E4H ; ACTIVE
                +2           CKCON                DATA 08EH ; ACTIVE
                +2           CLKSEL               DATA 0A9H ;
                +2           OSCLCN               DATA 0B1H ; ACTIVE
                +2           OSCICL               DATA 0C7H ; ACTIVE
                +2           PCA0CENT             DATA 09EH ; ACTIVE
                +2           PCA0CLR              DATA 09CH ; ACTIVE
                +2           PCA0CN               DATA 0D8H ; ACTIVE
                +2           PCA0CPH0             DATA 0FCH ; ACTIVE
                +2           PCA0CPH1             DATA 0EAH ; ACTIVE
                +2           PCA0CPH2             DATA 0ECH ; ACTIVE
                +2           PCA0CPL0             DATA 0FBH ; ACTIVE
                +2           PCA0CPL1             DATA 0E9H ; ACTIVE
                +2           PCA0CPL2             DATA 0EBH ; ACTIVE
                +2           PCA0CPM0             DATA 0DAH ; ACTIVE
                +2           PCA0CPM1             DATA 0DBH ; ACTIVE
                +2           PCA0CPM2             DATA 0DCH ; ACTIVE
                +2           PCA0H                DATA 0FAH ; ACTIVE
                +2           PCA0L                DATA 0F9H ; ACTIVE
                +2           PCA0MD               DATA 0D9H ; ACTIVE
                +2           PCA0POL              DATA 096H ; ACTIVE
                +2           PCA0PWM              DATA 0F7H ; ACTIVE
                +2           P0                   DATA 080H ;
                +2           P0MASK               DATA 0FEH ; ACTIVE
                +2           P0MAT                DATA 0FDH ; ACTIVE
                +2           P0MDIN               DATA 0F1H ; ACTIVE
                +2           P0MDOUT              DATA 0A4H ; ACTIVE
                +2           P0SKIP               DATA 0D4H ; ACTIVE
                +2           P1                   DATA 090H ; ACTIVE
                +2           P1MASK               DATA 0EEH ; ACTIVE
                +2           P1MAT                DATA 0EDH ; ACTIVE
                +2           P1MDIN               DATA 0F2H ; ACTIVE
                +2           P1MDOUT              DATA 0A5H ; ACTIVE
                +2           P1SKIP               DATA 0D5H ; ACTIVE
                +2           P2                   DATA 0A0H ;
                +2           P2MDOUT              DATA 0A6H ; ACTIVE
                +2           PRTDRV               DATA 0F6H ; ACTIVE
                +2           XBR0                 DATA 0E1H ; ACTIVE
                +2           XBR1                 DATA 0E2H ; ACTIVE
                +2           XBR2                 DATA 0E3H ; ACTIVE
                +2           RSTSRC               DATA 0EFH ; ACTIVE
                +2           SMB0ADM              DATA 0D6H ; ACTIVE
                +2           SMB0ADR              DATA 0D7H ; ACTIVE
                +2           SMB0CF               DATA 0C1H ; ACTIVE
                +2           SMB0CN               DATA 0C0H ; ACTIVE
                +2           SMB0DAT              DATA 0C2H ; ACTIVE
                +2           SMB0TC               DATA 0ACH ; ACTIVE
                +2           SPI0CFG              DATA 0A1H ; ACTIVE
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    61

                +2           SPI0CKR              DATA 0A2H ; ACTIVE
                +2           SPI0CN               DATA 0F8H ; ACTIVE
                +2           SPI0DAT              DATA 0A3H ; ACTIVE
                +2           TCON                 DATA 088H ; ACTIVE
                +2           TH0                  DATA 08CH ; ACTIVE
                +2           TH1                  DATA 08DH ; ACTIVE
                +2           TL0                  DATA 08AH ; ACTIVE
                +2           TL1                  DATA 08BH ; ACTIVE
                +2           TMOD                 DATA 089H ; ACTIVE
                +2           TMR2CN               DATA 0C8H ;
                +2           TMR2H                DATA 0CDH ; ACTIVE
                +2           TMR2L                DATA 0CCH ; ACTIVE
                +2           TMR2RLH              DATA 0CBH ; ACTIVE
                +2           TMR2RLL              DATA 0CAH ; ACTIVE
                +2           TMR3CN               DATA 091H ; ACTIVE
                +2           TMR3H                DATA 095H ; ACTIVE
                +2           TMR3L                DATA 094H ; ACTIVE
                +2           TMR3RLH              DATA 093H ; ACTIVE
                +2           TMR3RLL              DATA 092H ; ACTIVE
                +2           SBUF0                DATA 099H ; ACTIVE
                +2           SCON0                DATA 098H ;
                +2           REF0CN               DATA 0D1H ; ACTIVE
                +2           REG0CN               DATA 0C9H ; ACTIVE
                +2           VDM0CN               DATA 0FFH ; ACTIVE
                +2           WDTCN                DATA 097H ;
                +2           ; SFR ADDRESSES END
                +2           
                +2           ; BIT DEFINITIONS
                +2           
                +2           ; ADC0CN0 0xE8
                +2           AD0EN                BIT  ADC0CN0.7   ;
                +2           BURSTEN              BIT  ADC0CN0.6   ;
                +2           AD0INT               BIT  ADC0CN0.5   ;
                +2           AD0BUSY              BIT  ADC0CN0.4   ;
                +2           AD0WINT              BIT  ADC0CN0.3   ;
                +2           ADC0M2               BIT  ADC0CN0.2   ;
                +2           ADC0M1               BIT  ADC0CN0.1   ;
                +2           ADC0M0               BIT  ADC0CN0.0   ;
                +2           
                +2           ; IE 0xA8
                +2           EA                   BIT  IE.7        ; Global Interrupt Enable
                +2           ESPI0                BIT  IE.6        ; Serial Peripheral Interface Enable
                +2           ET2                  BIT  IE.5        ; Timer 2 Interrupt Enable
                +2           ES0                  BIT  IE.4        ; Serial Port Interrupt Enable
                +2           ET1                  BIT  IE.3        ; Timer 1 Interrupt Enable
                +2           EX1                  BIT  IE.2        ; External Interrupt Enable
                +2           ET0                  BIT  IE.1        ; Timer 0 Interrupt Enable
                +2           EX0                  BIT  IE.0        ; External Interrupt 0 Enable
                +2           
                +2           ; IP 0xB8
                +2                                                 ; bit 7 UNUSED
                +2           PSPI0                BIT  IP.6        ; Serial Peripheral Interface Priority
                +2           PT2                  BIT  IP.5        ; Timer 2 Priority
                +2           PS0                  BIT  IP.4        ; Serial Port Priority
                +2           PT1                  BIT  IP.3        ; Timer 1 Priority
                +2           PX1                  BIT  IP.2        ; External Interrupt 1 Priority
                +2           PT0                  BIT  IP.1        ; Timer 0 Priority
                +2           PX0                  BIT  IP.0        ; External Interrupt 0 Priority
                +2           
                +2           ; PCA0CN 0xD8
                +2           CF                   BIT  PCA0CN.7    ; PCA 0 Counter Overflow Flag
                +2           CR                   BIT  PCA0CN.6    ; PCA 0 Counter Run Control Bit
                +2                                                 ; bit 5 UNUSED
                +2                                                 ; bit 4 UNUSED
                +2                                                 ; bit 3 UNUSED
                +2           CCF2                 BIT  PCA0CN.2    ; PCA 0 Module 2 Interrupt Flag
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    62

                +2           CCF1                 BIT  PCA0CN.1    ; PCA 0 Module 1 Interrupt Flag
                +2           CCF0                 BIT  PCA0CN.0    ; PCA 0 Module 0 Interrupt Flag
                +2           
                +2           ; PSW 0xD0
                +2           CY                   BIT  PSW.7       ; Carry Flag
                +2           AC                   BIT  PSW.6       ; Auxiliary Carry Flag
                +2           F0                   BIT  PSW.5       ; User Flag 0
                +2           RS1                  BIT  PSW.4       ; Register Bank Select 1
                +2           RS0                  BIT  PSW.3       ; Register Bank Select 0
                +2           OV                   BIT  PSW.2       ; Overflow Flag
                +2           F1                   BIT  PSW.1       ; User Flag 1
                +2           P                    BIT  PSW.0       ; Accumulator Parity Flag
                +2           
                +2           ; SCON0 0x98
                +2           S0MODE               BIT  SCON0.7     ; Serial Mode Control Bit 0
                +2                                                 ; bit 6 UNUSED
                +2           MCE0                 BIT  SCON0.5     ; Multiprocessor Communication Enable
                +2           REN0                 BIT  SCON0.4     ; Receive Enable
                +2           TB80                 BIT  SCON0.3     ; Transmit Bit 8
                +2           RB80                 BIT  SCON0.2     ; Receive Bit 8
                +2           TI0                  BIT  SCON0.1     ; Transmit Interrupt Flag
                +2           RI0                  BIT  SCON0.0     ; Receive Interrupt Flag
                +2           
                +2           ; SMB0CN 0xC0
                +2           MASTER0              BIT  SMB0CN.7    ; SMBus Master/Slave Indicator
                +2           TXMODE0              BIT  SMB0CN.6    ; SMBus Transmit Mode Indicator
                +2           STA0                 BIT  SMB0CN.5    ; SMBus Start Flag
                +2           STO0                 BIT  SMB0CN.4    ; SMBus Stop Flag
                +2           ACKRQ0               BIT  SMB0CN.3    ; SMBus Acknowledge Request
                +2           ARBLOST0             BIT  SMB0CN.2    ; SMBus Arbitration Lost Indicator
                +2           ACK0                 BIT  SMB0CN.1    ; SMBus Acknowledge
                +2           SI0                  BIT  SMB0CN.0    ; SMBus Interrupt
                +2           
                +2           ; SPI0CN 0xF8
                +2           SPIF                 BIT  SPI0CN.7    ; SPI 0 Interrupt Flag
                +2           WCOL                 BIT  SPI0CN.6    ; SPI 0 Write Collision Flag
                +2           MODF                 BIT  SPI0CN.5    ; SPI 0 Mode Fault Flag
                +2           RXOVRN               BIT  SPI0CN.4    ; SPI 0 RX Overrun Flag
                +2           NSSMD1               BIT  SPI0CN.3    ; SPI 0 NSS Mode Bit 1
                +2           NSSMD0               BIT  SPI0CN.2    ; SPI 0 NSS Mode Bit 0
                +2           TXBMT                BIT  SPI0CN.1    ; SPI 0 Transmit Buffer Empty Flag
                +2           SPIEN                BIT  SPI0CN.0    ; SPI 0 SPI Enable
                +2           
                +2           ; TCON 0x88
                +2           TF1                  BIT  TCON.7      ; Timer 1 Overflow Flag
                +2           TR1                  BIT  TCON.6      ; Timer 1 On/Off Control
                +2           TF0                  BIT  TCON.5      ; Timer 0 Overflow Flag
                +2           TR0                  BIT  TCON.4      ; Timer 0 On/Off Control
                +2           IE1                  BIT  TCON.3      ; Ext. Interrupt 1 Edge Flag
                +2           IT1                  BIT  TCON.2      ; Ext. Interrupt 1 Type
                +2           IE0                  BIT  TCON.1      ; Ext. Interrupt 0 Edge Flag
                +2           IT0                  BIT  TCON.0      ; Ext. Interrupt 0 Type
                +2           
                +2           ; TMR2CN 0xC8
                +2           TF2H                 BIT  TMR2CN.7    ; T2 High-Byte Overflow Flag
                +2           TF2L                 BIT  TMR2CN.6    ; T2 Low-Byte Overflow Flag
                +2           TF2LEN               BIT  TMR2CN.5    ; T2 Low Byte Interrupt Enable
                +2           TF2CEN               BIT  TMR2CN.4    ; T2 Input Capture Enable
                +2           T2SPLIT              BIT  TMR2CN.3    ; T2 Split-Mode Enable
                +2           TR2                  BIT  TMR2CN.2    ; Timer 2 On/Off Control
                +2                                                 ; bit 1 UNUSED
                +2           T2XCLK               BIT  TMR2CN.0    ; T2 External Clock Select
                +1           
                +1           
                +1           ;**** **** **** **** ****
                +1           ; Uses internal calibrated oscillator set to 24Mhz
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    63

                +1           ;**** **** **** **** ****
                +1           
                +1           ;**** **** **** **** ****
                +1           ; Constant definitions
                +1           ;**** **** **** **** ****
                +1           CSEG AT 1A40h
                +1           Eep_ESC_Layout:         DB      "#FC_FairyV2_30A#"      ; ESC layout tag
                +1           CSEG AT 1A50h
                +1           Eep_ESC_MCU:                    DB      "#BLHELI#F850#   "      ; Project and MCU tag (16 B
                             ytes)
                +1           
                +1           MCU_48MHZ                               EQU     0       ; Set to 1 if MCU can run at 48MHz
                +1           ONE_S_CAPABLE                   EQU     0       ; Set to 1 if ESC can operate at 1S
                +1           PORT3_EXIST                     EQU     0       ; Set to 1 if MCU has port3
                +1           COMP1_USED                      EQU     0       ; Set to 1 if MCU has comparator 1 and it i
                             s being used
                +1           LOCK_BYTE_ADDRESS_16K   EQU     3FFFh   ; Address of lock byte if 16k flash size
                +1           LOCK_BYTE_ADDRESS_8K    EQU     1FFFh   ; Address of lock byte if 8k flash size
                +1           HIGH_BEC_VOLTAGE                EQU     0       ; Set to 1 or more if high BEC voltage is s
                             upported
                +1           DAMPED_MODE_ENABLE              EQU     1       ; Damped mode enabled
                +1           NFETON_DELAY                    EQU     8       ; Wait delay from pfets off to nfets on
                +1           PFETON_DELAY                    EQU     8       ; Wait delay from nfets off to pfets on
                +1           ADC_LIMIT_L                     EQU     85      ; Power supply measurement ADC value for wh
                             ich main motor power is limited (low byte)
                +1           ADC_LIMIT_H                     EQU     0       ; Power supply measurement ADC value for wh
                             ich main motor power is limited (2 MSBs)
                +1           TEMP_LIMIT                      EQU     103     ; Temperature measurement ADC value for whi
                             ch main motor power is limited (low byte, assuming high byte is 1)
                +1           TEMP_LIMIT_STEP         EQU     4       ; Temperature measurement ADC value increment for w
                             hich main motor power is further limited
                +1           
                +1           ;**** **** **** **** ****
                +1           ; ESC specific defaults
                +1           ;**** **** **** **** ****
                +1           DEFAULT_PGM_MAIN_SPOOLUP_TIME           EQU 10  ; Main motor spoolup time
                +1           DEFAULT_PGM_MAIN_STARTUP_PWR            EQU 9   ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           DEFAULT_PGM_TAIL_STARTUP_PWR            EQU 9   ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           DEFAULT_PGM_MULTI_STARTUP_PWR           EQU 9   ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           
                +1           ;**** **** **** **** ****
                +1           ; Bootloader definitions
                +1           ;**** **** **** **** ****
                +1           RTX_PORT                                EQU P0          ; Receive/Transmit port
                +1           RTX_MDOUT                               EQU     P0MDOUT ; Set to 1 for PUSHPULL            
                                          
                +1           RTX_MDIN                                EQU     P0MDIN  ; Set to 1 for DIGITAL             
                                          
                +1           RTX_SKIP                                EQU     P0SKIP  ; Set to 1 for SKIP                
                                          
                +1           RTX_PIN                                 EQU 5           ; RTX pin
                +1           
                +1           SIGNATURE_001                   EQU     0f8h            ; Device signature
                +1           SIGNATURE_002                   EQU     050h
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 0 definitions *
                +1           ;*********************  
                +1           ;                       EQU     7       ;i (Temp)
                +1           Adc_Ip          EQU     6       ;i
                +1           Rcp_In          EQU     5       ;i
                +1           ;                       EQU     4       ;i (Rcp 1k)
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    64

                +1           Mux_C           EQU     3       ;i
                +1           Mux_B           EQU     2       ;i
                +1           Mux_A           EQU     1       ;i
                +1           Comp_Com        EQU     0       ;i
                +1           
                +1           P0_DIGITAL      EQU     NOT((1 SHL Mux_A)+(1 SHL Mux_B)+(1 SHL Mux_C)+(1 SHL Comp_Com)+(1 S
                             HL Adc_Ip))
                +1           P0_INIT         EQU     0FFh
                +1           P0_PUSHPULL     EQU     0
                +1           P0_SKIP         EQU     NOT(1 SHL Rcp_In) AND 0FFh
                +1           
                +1           Get_Rcp_Capture_Values MACRO
                +1                   mov     Temp1, PCA0CPL0                 ; Get PCA capture values
                +1                   mov     Temp2, PCA0CPH0
                +1           ENDM
                +1           Read_Rcp_Int MACRO
                +1                   mov     A, P0
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+4)   ; Is pwm polarity negative?
                +1                   cpl     A                                               ; Yes - invert
                +1           ENDM
                +1           Rcp_Int_Enable MACRO
                +1                   orl     PCA0CPM0, #01h                          ; Interrupt enabled
                +1           ENDM
                +1           Rcp_Int_Disable MACRO
                +1                   anl     PCA0CPM0, #0FEh                 ; Interrupt disabled
                +1           ENDM
                +1           Rcp_Int_First MACRO
                +1                   anl     PCA0CPM0, #0CFh                 
                +1                   jb      Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity positive?
                +1                   orl     PCA0CPM0, #20h                          ; Capture rising edge
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity negative?
                +1                   orl     PCA0CPM0, #10h                          ; Capture falling edge
                +1           ENDM
                +1           Rcp_Int_Second MACRO
                +1                   anl     PCA0CPM0, #0CFh                 
                +1                   jb      Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity positive?
                +1                   orl     PCA0CPM0, #10h                          ; Capture falling edge
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity negative?
                +1                   orl     PCA0CPM0, #20h                          ; Capture rising edge
                +1           ENDM
                +1           Rcp_Clear_Int_Flag MACRO
                +1                   clr     CCF0                                            ; Clear interrupt flag
                +1           ENDM            
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 1 definitions *
                +1           ;*********************
                +1           ;                       EQU     7       ;i
                +1           ;                       EQU     6       ;i
                +1           CnFET           EQU     5       ;o
                +1           CpFET           EQU     4       ;o
                +1           BnFET           EQU     3       ;o
                +1           BpFET           EQU     2       ;o
                +1           AnFET           EQU     1       ;o
                +1           ApFET           EQU     0       ;o
                +1           
                +1           P1_DIGITAL      EQU     (1 SHL AnFET)+(1 SHL BnFET)+(1 SHL CnFET)+(1 SHL ApFET)+(1 SHL BpFE
                             T)+(1 SHL CpFET)
                +1           P1_INIT         EQU     0               
                +1           P1_PUSHPULL     EQU     (1 SHL AnFET)+(1 SHL BnFET)+(1 SHL CnFET)+(1 SHL ApFET)+(1 SHL BpFE
                             T)+(1 SHL CpFET)
                +1           P1_SKIP         EQU     0
                +1           
                +1           AnFET_on MACRO
                +1                   setb    P1.AnFET
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    65

                +1           ENDM
                +1           AnFET_off MACRO
                +1                   clr     P1.AnFET
                +1           ENDM
                +1           BnFET_on MACRO
                +1                   setb    P1.BnFET
                +1           ENDM
                +1           BnFET_off MACRO
                +1                   clr     P1.BnFET
                +1           ENDM
                +1           CnFET_on MACRO
                +1                   setb    P1.CnFET
                +1           ENDM
                +1           CnFET_off MACRO
                +1                   clr     P1.CnFET
                +1           ENDM
                +1           All_nFETs_Off MACRO
                +1                   clr     P1.AnFET
                +1                   clr     P1.BnFET
                +1                   clr     P1.CnFET
                +1           ENDM
                +1           
                +1           ApFET_on MACRO
                +1                   setb    P1.ApFET
                +1           ENDM
                +1           ApFET_off MACRO
                +1                   clr     P1.ApFET
                +1           ENDM
                +1           BpFET_on MACRO
                +1                   setb    P1.BpFET
                +1           ENDM
                +1           BpFET_off MACRO
                +1                   clr     P1.BpFET
                +1           ENDM
                +1           CpFET_on MACRO
                +1                   setb    P1.CpFET
                +1           ENDM
                +1           CpFET_off MACRO
                +1                   clr     P1.CpFET
                +1           ENDM
                +1           All_pFETs_Off MACRO
                +1                   clr     P1.ApFET
                +1                   clr     P1.BpFET
                +1                   clr     P1.CpFET
                +1           ENDM
                +1           
                +1           Brake_FETs_On   MACRO
                +1                   AnFET_on
                +1                   BnFET_on
                +1                   CnFET_on
                +1           ENDM
                +1           Damping_FET_On MACRO
                +1                   mov     A, DampingFET
                +1                   orl     P1, A
                +1           ENDM
                +1           
                +1           Set_Comp_Phase_A MACRO
                +1                   mov     CPT0MX, #01h    ; Set comparator multiplexer to phase A
                +1           ENDM
                +1           Set_Comp_Phase_B MACRO
                +1                   mov     CPT0MX, #02h    ; Set comparator multiplexer to phase B
                +1           ENDM
                +1           Set_Comp_Phase_C MACRO
                +1                   mov     CPT0MX, #03h    ; Set comparator multiplexer to phase C
                +1           ENDM
                +1           Read_Comp_Out MACRO
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    66

                +1                   mov     A, CPT0CN               ; Read comparator output
                +1           ENDM
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 2 definitions *
                +1           ;*********************
                +1           DebugPin                EQU     0       ;o
                +1           
                +1           P2_PUSHPULL     EQU     (1 SHL DebugPin)
                +1           
                +1           
                +1           ;**********************
                +1           ; MCU specific macros *
                +1           ;**********************
                +1           Interrupt_Table_Definition MACRO
                +1           CSEG AT 0                               ; Code segment start
                +1                   jmp reset
                +1           CSEG AT 0Bh                     ; Timer0 interrupt      
                +1                   jmp     t0_int  
                +1           CSEG AT 2Bh                     ; Timer2 interrupt      
                +1                   jmp     t2_int  
                +1           CSEG AT 5Bh                     ; PCA interrupt 
                +1                   jmp     pca_int 
                +1           CSEG AT 73h                     ; Timer3 interrupt      
                +1                   jmp     t3_int  
                +1           ENDM
                +1           
                +1           Initialize_Xbar MACRO
                +1                   mov     XBR2, #40h      ; Xbar enabled                  
                +1                   mov     XBR1, #01h      ; CEX0 routed to pin Rcp_In                     
                +1           ENDM
                +1           
                +1           Initialize_Adc MACRO
                +1                   mov     REF0CN, #0Ch    ; Set vdd (3.3V) as reference. Enable temp sensor and bias
                +1                   mov     ADC0CF, #59h    ; ADC clock 2MHz, PGA gain 1
                +1                   mov     ADC0MX, #Adc_Ip; Select ADC input
                +1                   mov     ADC0CN0, #80h   ; ADC enabled 
                +1                   mov     ADC0CN1, #01h   ; Common mode buffer enabled
                +1           ENDM
                +1           Set_Adc_Ip_Volt MACRO
                +1                   mov     ADC0MX, #Adc_Ip; Select ADC input
                +1           ENDM
                +1           Set_Adc_Ip_Temp MACRO
                +1                   mov     ADC0MX, #10h    ; Select temp sensor input
                +1           ENDM
                +1           Start_Adc MACRO
                +1                   mov     ADC0CN0, #90h   ; ADC start
                +1           ENDM
                +1           Read_Adc_Result MACRO
                +1                   mov     Temp1, ADC0L
                +1                   mov     Temp2, ADC0H
                +1           ENDM
                +1           Stop_Adc MACRO
                +1           ENDM
                +1           Set_RPM_Out MACRO
                +1           ENDM
                +1           Clear_RPM_Out MACRO
                +1           ENDM
                +1           Set_MCU_Clk_24MHz MACRO
                +1           ENDM
                +1           Set_MCU_Clk_48MHz MACRO
                +1           ENDM
                             ENDIF
                    4201     
                    4202     IF BESCNO == Flycolor_Fairy_V2_30A_Multi
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    67

                             MODE    EQU     2                               ; Choose mode. Set to 2 for multirotor
                             ;$include (Flycolor_Fairy_V2_30A.inc) ; Select Flycolor Fairy V2 30A pinout
                +1           ;**** **** **** **** ****
                +1           ;
                +1           ; BLHeli program for controlling brushless motors in helicopters and multirotors
                +1           ;
                +1           ; Copyright 2011, 2012 Steffen Skaug
                +1           ; This program is distributed under the terms of the GNU General Public License
                +1           ;
                +1           ; This file is part of BLHeli.
                +1           ;
                +1           ; BLHeli is free software: you can redistribute it and/or modify
                +1           ; it under the terms of the GNU General Public License as published by
                +1           ; the Free Software Foundation, either version 3 of the License, or
                +1           ; (at your option) any later version.
                +1           ;
                +1           ; BLHeli is distributed in the hope that it will be useful,
                +1           ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                +1           ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                +1           ; GNU General Public License for more details.
                +1           ;
                +1           ; You should have received a copy of the GNU General Public License
                +1           ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                +1           ;
                +1           ;**** **** **** **** ****
                +1           ;
                +1           ; Flycolor Fairy V2 30A hardware definition file
                +1           ;
                +1           ;**** **** **** **** ****
                +1           
                +1           
                +1           
                +1           ;*********************
                +1           ; Device SiLabs F850
                +1           ;*********************
                +1           ;$include (c8051f850.inc)
                +2           ; PAGE DEFINITIONS
                +2           ACTIVE_PAGE          EQU 000H
                +2           DEBUG_PAGE           EQU 001H
                +2           
                +2           ; SFR ADDRESSES BEGIN
                +2           ADC0AC               DATA 0B3H ; ACTIVE
                +2           ADC0CF               DATA 0BCH ; ACTIVE
                +2           ADC0CN0              DATA 0E8H ; ACTIVE
                +2           ADC0CN1              DATA 0B2H ; ACTIVE
                +2           ADC0GTH              DATA 0C4H ; ACTIVE
                +2           ADC0GTL              DATA 0C3H ; ACTIVE
                +2           ADC0H                DATA 0BEH ; ACTIVE
                +2           ADC0L                DATA 0BDH ; ACTIVE
                +2           ADC0LTH              DATA 0C6H ; ACTIVE
                +2           ADC0LTL              DATA 0C5H ; ACTIVE
                +2           ADC0MX               DATA 0BBH ; ACTIVE
                +2           ADC0PWR              DATA 0DFH ; ACTIVE
                +2           ADC0TK               DATA 0B9H ; ACTIVE
                +2           ACC                  DATA 0E0H ;
                +2           B                    DATA 0F0H ;
                +2           DPH                  DATA 083H ;
                +2           DPL                  DATA 082H ;
                +2           PCON                 DATA 087H ;
                +2           PSW                  DATA 0D0H ;
                +2           SP                   DATA 081H ;
                +2           CRC0AUTO             DATA 0D2H ; ACTIVE
                +2           CRC0CN               DATA 0CEH ; ACTIVE
                +2           CRC0CNT              DATA 0D3H ; ACTIVE
                +2           CRC0DAT              DATA 0DEH ; ACTIVE
                +2           CRC0FLIP             DATA 0CFH ; ACTIVE
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    68

                +2           CRC0IN               DATA 0DDH ; ACTIVE
                +2           CPT0CN               DATA 09BH ; ACTIVE
                +2           CPT0MD               DATA 09DH ; ACTIVE
                +2           CPT0MX               DATA 09FH ; ACTIVE
                +2           CPT1CN               DATA 0BFH ; ACTIVE
                +2           CPT1MD               DATA 0ABH ; ACTIVE
                +2           CPT1MX               DATA 0AAH ; ACTIVE
                +2           DERIVID              DATA 0ADH ; ACTIVE
                +2           DEVICEID             DATA 0B5H ; ACTIVE
                +2           FLSCL                DATA 09AH ; ACTIVE
                +2           REVID                DATA 0B6H ; ACTIVE
                +2           FLKEY                DATA 0B7H ;
                +2           PSCTL                DATA 08FH ;
                +2           EIE1                 DATA 0E6H ;
                +2           EIP1                 DATA 0F3H ; ACTIVE
                +2           IE                   DATA 0A8H ;
                +2           IP                   DATA 0B8H ;
                +2           IT01CF               DATA 0E4H ; ACTIVE
                +2           CKCON                DATA 08EH ; ACTIVE
                +2           CLKSEL               DATA 0A9H ;
                +2           OSCLCN               DATA 0B1H ; ACTIVE
                +2           OSCICL               DATA 0C7H ; ACTIVE
                +2           PCA0CENT             DATA 09EH ; ACTIVE
                +2           PCA0CLR              DATA 09CH ; ACTIVE
                +2           PCA0CN               DATA 0D8H ; ACTIVE
                +2           PCA0CPH0             DATA 0FCH ; ACTIVE
                +2           PCA0CPH1             DATA 0EAH ; ACTIVE
                +2           PCA0CPH2             DATA 0ECH ; ACTIVE
                +2           PCA0CPL0             DATA 0FBH ; ACTIVE
                +2           PCA0CPL1             DATA 0E9H ; ACTIVE
                +2           PCA0CPL2             DATA 0EBH ; ACTIVE
                +2           PCA0CPM0             DATA 0DAH ; ACTIVE
                +2           PCA0CPM1             DATA 0DBH ; ACTIVE
                +2           PCA0CPM2             DATA 0DCH ; ACTIVE
                +2           PCA0H                DATA 0FAH ; ACTIVE
                +2           PCA0L                DATA 0F9H ; ACTIVE
                +2           PCA0MD               DATA 0D9H ; ACTIVE
                +2           PCA0POL              DATA 096H ; ACTIVE
                +2           PCA0PWM              DATA 0F7H ; ACTIVE
                +2           P0                   DATA 080H ;
                +2           P0MASK               DATA 0FEH ; ACTIVE
                +2           P0MAT                DATA 0FDH ; ACTIVE
                +2           P0MDIN               DATA 0F1H ; ACTIVE
                +2           P0MDOUT              DATA 0A4H ; ACTIVE
                +2           P0SKIP               DATA 0D4H ; ACTIVE
                +2           P1                   DATA 090H ; ACTIVE
                +2           P1MASK               DATA 0EEH ; ACTIVE
                +2           P1MAT                DATA 0EDH ; ACTIVE
                +2           P1MDIN               DATA 0F2H ; ACTIVE
                +2           P1MDOUT              DATA 0A5H ; ACTIVE
                +2           P1SKIP               DATA 0D5H ; ACTIVE
                +2           P2                   DATA 0A0H ;
                +2           P2MDOUT              DATA 0A6H ; ACTIVE
                +2           PRTDRV               DATA 0F6H ; ACTIVE
                +2           XBR0                 DATA 0E1H ; ACTIVE
                +2           XBR1                 DATA 0E2H ; ACTIVE
                +2           XBR2                 DATA 0E3H ; ACTIVE
                +2           RSTSRC               DATA 0EFH ; ACTIVE
                +2           SMB0ADM              DATA 0D6H ; ACTIVE
                +2           SMB0ADR              DATA 0D7H ; ACTIVE
                +2           SMB0CF               DATA 0C1H ; ACTIVE
                +2           SMB0CN               DATA 0C0H ; ACTIVE
                +2           SMB0DAT              DATA 0C2H ; ACTIVE
                +2           SMB0TC               DATA 0ACH ; ACTIVE
                +2           SPI0CFG              DATA 0A1H ; ACTIVE
                +2           SPI0CKR              DATA 0A2H ; ACTIVE
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    69

                +2           SPI0CN               DATA 0F8H ; ACTIVE
                +2           SPI0DAT              DATA 0A3H ; ACTIVE
                +2           TCON                 DATA 088H ; ACTIVE
                +2           TH0                  DATA 08CH ; ACTIVE
                +2           TH1                  DATA 08DH ; ACTIVE
                +2           TL0                  DATA 08AH ; ACTIVE
                +2           TL1                  DATA 08BH ; ACTIVE
                +2           TMOD                 DATA 089H ; ACTIVE
                +2           TMR2CN               DATA 0C8H ;
                +2           TMR2H                DATA 0CDH ; ACTIVE
                +2           TMR2L                DATA 0CCH ; ACTIVE
                +2           TMR2RLH              DATA 0CBH ; ACTIVE
                +2           TMR2RLL              DATA 0CAH ; ACTIVE
                +2           TMR3CN               DATA 091H ; ACTIVE
                +2           TMR3H                DATA 095H ; ACTIVE
                +2           TMR3L                DATA 094H ; ACTIVE
                +2           TMR3RLH              DATA 093H ; ACTIVE
                +2           TMR3RLL              DATA 092H ; ACTIVE
                +2           SBUF0                DATA 099H ; ACTIVE
                +2           SCON0                DATA 098H ;
                +2           REF0CN               DATA 0D1H ; ACTIVE
                +2           REG0CN               DATA 0C9H ; ACTIVE
                +2           VDM0CN               DATA 0FFH ; ACTIVE
                +2           WDTCN                DATA 097H ;
                +2           ; SFR ADDRESSES END
                +2           
                +2           ; BIT DEFINITIONS
                +2           
                +2           ; ADC0CN0 0xE8
                +2           AD0EN                BIT  ADC0CN0.7   ;
                +2           BURSTEN              BIT  ADC0CN0.6   ;
                +2           AD0INT               BIT  ADC0CN0.5   ;
                +2           AD0BUSY              BIT  ADC0CN0.4   ;
                +2           AD0WINT              BIT  ADC0CN0.3   ;
                +2           ADC0M2               BIT  ADC0CN0.2   ;
                +2           ADC0M1               BIT  ADC0CN0.1   ;
                +2           ADC0M0               BIT  ADC0CN0.0   ;
                +2           
                +2           ; IE 0xA8
                +2           EA                   BIT  IE.7        ; Global Interrupt Enable
                +2           ESPI0                BIT  IE.6        ; Serial Peripheral Interface Enable
                +2           ET2                  BIT  IE.5        ; Timer 2 Interrupt Enable
                +2           ES0                  BIT  IE.4        ; Serial Port Interrupt Enable
                +2           ET1                  BIT  IE.3        ; Timer 1 Interrupt Enable
                +2           EX1                  BIT  IE.2        ; External Interrupt Enable
                +2           ET0                  BIT  IE.1        ; Timer 0 Interrupt Enable
                +2           EX0                  BIT  IE.0        ; External Interrupt 0 Enable
                +2           
                +2           ; IP 0xB8
                +2                                                 ; bit 7 UNUSED
                +2           PSPI0                BIT  IP.6        ; Serial Peripheral Interface Priority
                +2           PT2                  BIT  IP.5        ; Timer 2 Priority
                +2           PS0                  BIT  IP.4        ; Serial Port Priority
                +2           PT1                  BIT  IP.3        ; Timer 1 Priority
                +2           PX1                  BIT  IP.2        ; External Interrupt 1 Priority
                +2           PT0                  BIT  IP.1        ; Timer 0 Priority
                +2           PX0                  BIT  IP.0        ; External Interrupt 0 Priority
                +2           
                +2           ; PCA0CN 0xD8
                +2           CF                   BIT  PCA0CN.7    ; PCA 0 Counter Overflow Flag
                +2           CR                   BIT  PCA0CN.6    ; PCA 0 Counter Run Control Bit
                +2                                                 ; bit 5 UNUSED
                +2                                                 ; bit 4 UNUSED
                +2                                                 ; bit 3 UNUSED
                +2           CCF2                 BIT  PCA0CN.2    ; PCA 0 Module 2 Interrupt Flag
                +2           CCF1                 BIT  PCA0CN.1    ; PCA 0 Module 1 Interrupt Flag
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    70

                +2           CCF0                 BIT  PCA0CN.0    ; PCA 0 Module 0 Interrupt Flag
                +2           
                +2           ; PSW 0xD0
                +2           CY                   BIT  PSW.7       ; Carry Flag
                +2           AC                   BIT  PSW.6       ; Auxiliary Carry Flag
                +2           F0                   BIT  PSW.5       ; User Flag 0
                +2           RS1                  BIT  PSW.4       ; Register Bank Select 1
                +2           RS0                  BIT  PSW.3       ; Register Bank Select 0
                +2           OV                   BIT  PSW.2       ; Overflow Flag
                +2           F1                   BIT  PSW.1       ; User Flag 1
                +2           P                    BIT  PSW.0       ; Accumulator Parity Flag
                +2           
                +2           ; SCON0 0x98
                +2           S0MODE               BIT  SCON0.7     ; Serial Mode Control Bit 0
                +2                                                 ; bit 6 UNUSED
                +2           MCE0                 BIT  SCON0.5     ; Multiprocessor Communication Enable
                +2           REN0                 BIT  SCON0.4     ; Receive Enable
                +2           TB80                 BIT  SCON0.3     ; Transmit Bit 8
                +2           RB80                 BIT  SCON0.2     ; Receive Bit 8
                +2           TI0                  BIT  SCON0.1     ; Transmit Interrupt Flag
                +2           RI0                  BIT  SCON0.0     ; Receive Interrupt Flag
                +2           
                +2           ; SMB0CN 0xC0
                +2           MASTER0              BIT  SMB0CN.7    ; SMBus Master/Slave Indicator
                +2           TXMODE0              BIT  SMB0CN.6    ; SMBus Transmit Mode Indicator
                +2           STA0                 BIT  SMB0CN.5    ; SMBus Start Flag
                +2           STO0                 BIT  SMB0CN.4    ; SMBus Stop Flag
                +2           ACKRQ0               BIT  SMB0CN.3    ; SMBus Acknowledge Request
                +2           ARBLOST0             BIT  SMB0CN.2    ; SMBus Arbitration Lost Indicator
                +2           ACK0                 BIT  SMB0CN.1    ; SMBus Acknowledge
                +2           SI0                  BIT  SMB0CN.0    ; SMBus Interrupt
                +2           
                +2           ; SPI0CN 0xF8
                +2           SPIF                 BIT  SPI0CN.7    ; SPI 0 Interrupt Flag
                +2           WCOL                 BIT  SPI0CN.6    ; SPI 0 Write Collision Flag
                +2           MODF                 BIT  SPI0CN.5    ; SPI 0 Mode Fault Flag
                +2           RXOVRN               BIT  SPI0CN.4    ; SPI 0 RX Overrun Flag
                +2           NSSMD1               BIT  SPI0CN.3    ; SPI 0 NSS Mode Bit 1
                +2           NSSMD0               BIT  SPI0CN.2    ; SPI 0 NSS Mode Bit 0
                +2           TXBMT                BIT  SPI0CN.1    ; SPI 0 Transmit Buffer Empty Flag
                +2           SPIEN                BIT  SPI0CN.0    ; SPI 0 SPI Enable
                +2           
                +2           ; TCON 0x88
                +2           TF1                  BIT  TCON.7      ; Timer 1 Overflow Flag
                +2           TR1                  BIT  TCON.6      ; Timer 1 On/Off Control
                +2           TF0                  BIT  TCON.5      ; Timer 0 Overflow Flag
                +2           TR0                  BIT  TCON.4      ; Timer 0 On/Off Control
                +2           IE1                  BIT  TCON.3      ; Ext. Interrupt 1 Edge Flag
                +2           IT1                  BIT  TCON.2      ; Ext. Interrupt 1 Type
                +2           IE0                  BIT  TCON.1      ; Ext. Interrupt 0 Edge Flag
                +2           IT0                  BIT  TCON.0      ; Ext. Interrupt 0 Type
                +2           
                +2           ; TMR2CN 0xC8
                +2           TF2H                 BIT  TMR2CN.7    ; T2 High-Byte Overflow Flag
                +2           TF2L                 BIT  TMR2CN.6    ; T2 Low-Byte Overflow Flag
                +2           TF2LEN               BIT  TMR2CN.5    ; T2 Low Byte Interrupt Enable
                +2           TF2CEN               BIT  TMR2CN.4    ; T2 Input Capture Enable
                +2           T2SPLIT              BIT  TMR2CN.3    ; T2 Split-Mode Enable
                +2           TR2                  BIT  TMR2CN.2    ; Timer 2 On/Off Control
                +2                                                 ; bit 1 UNUSED
                +2           T2XCLK               BIT  TMR2CN.0    ; T2 External Clock Select
                +1           
                +1           
                +1           ;**** **** **** **** ****
                +1           ; Uses internal calibrated oscillator set to 24Mhz
                +1           ;**** **** **** **** ****
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    71

                +1           
                +1           ;**** **** **** **** ****
                +1           ; Constant definitions
                +1           ;**** **** **** **** ****
                +1           CSEG AT 1A40h
                +1           Eep_ESC_Layout:         DB      "#FC_FairyV2_30A#"      ; ESC layout tag
                +1           CSEG AT 1A50h
                +1           Eep_ESC_MCU:                    DB      "#BLHELI#F850#   "      ; Project and MCU tag (16 B
                             ytes)
                +1           
                +1           MCU_48MHZ                               EQU     0       ; Set to 1 if MCU can run at 48MHz
                +1           ONE_S_CAPABLE                   EQU     0       ; Set to 1 if ESC can operate at 1S
                +1           PORT3_EXIST                     EQU     0       ; Set to 1 if MCU has port3
                +1           COMP1_USED                      EQU     0       ; Set to 1 if MCU has comparator 1 and it i
                             s being used
                +1           LOCK_BYTE_ADDRESS_16K   EQU     3FFFh   ; Address of lock byte if 16k flash size
                +1           LOCK_BYTE_ADDRESS_8K    EQU     1FFFh   ; Address of lock byte if 8k flash size
                +1           HIGH_BEC_VOLTAGE                EQU     0       ; Set to 1 or more if high BEC voltage is s
                             upported
                +1           DAMPED_MODE_ENABLE              EQU     1       ; Damped mode enabled
                +1           NFETON_DELAY                    EQU     8       ; Wait delay from pfets off to nfets on
                +1           PFETON_DELAY                    EQU     8       ; Wait delay from nfets off to pfets on
                +1           ADC_LIMIT_L                     EQU     85      ; Power supply measurement ADC value for wh
                             ich main motor power is limited (low byte)
                +1           ADC_LIMIT_H                     EQU     0       ; Power supply measurement ADC value for wh
                             ich main motor power is limited (2 MSBs)
                +1           TEMP_LIMIT                      EQU     103     ; Temperature measurement ADC value for whi
                             ch main motor power is limited (low byte, assuming high byte is 1)
                +1           TEMP_LIMIT_STEP         EQU     4       ; Temperature measurement ADC value increment for w
                             hich main motor power is further limited
                +1           
                +1           ;**** **** **** **** ****
                +1           ; ESC specific defaults
                +1           ;**** **** **** **** ****
                +1           DEFAULT_PGM_MAIN_SPOOLUP_TIME           EQU 10  ; Main motor spoolup time
                +1           DEFAULT_PGM_MAIN_STARTUP_PWR            EQU 9   ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           DEFAULT_PGM_TAIL_STARTUP_PWR            EQU 9   ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           DEFAULT_PGM_MULTI_STARTUP_PWR           EQU 9   ; 1=0.031 2=0.047 3=0.063 4=0.094 5=0.125 6
                             =0.188       7=0.25  8=0.38  9=0.50  10=0.75 11=1.00 12=1.25 13=1.50
                +1           
                +1           ;**** **** **** **** ****
                +1           ; Bootloader definitions
                +1           ;**** **** **** **** ****
                +1           RTX_PORT                                EQU P0          ; Receive/Transmit port
                +1           RTX_MDOUT                               EQU     P0MDOUT ; Set to 1 for PUSHPULL            
                                          
                +1           RTX_MDIN                                EQU     P0MDIN  ; Set to 1 for DIGITAL             
                                          
                +1           RTX_SKIP                                EQU     P0SKIP  ; Set to 1 for SKIP                
                                          
                +1           RTX_PIN                                 EQU 5           ; RTX pin
                +1           
                +1           SIGNATURE_001                   EQU     0f8h            ; Device signature
                +1           SIGNATURE_002                   EQU     050h
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 0 definitions *
                +1           ;*********************  
                +1           ;                       EQU     7       ;i (Temp)
                +1           Adc_Ip          EQU     6       ;i
                +1           Rcp_In          EQU     5       ;i
                +1           ;                       EQU     4       ;i (Rcp 1k)
                +1           Mux_C           EQU     3       ;i
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    72

                +1           Mux_B           EQU     2       ;i
                +1           Mux_A           EQU     1       ;i
                +1           Comp_Com        EQU     0       ;i
                +1           
                +1           P0_DIGITAL      EQU     NOT((1 SHL Mux_A)+(1 SHL Mux_B)+(1 SHL Mux_C)+(1 SHL Comp_Com)+(1 S
                             HL Adc_Ip))
                +1           P0_INIT         EQU     0FFh
                +1           P0_PUSHPULL     EQU     0
                +1           P0_SKIP         EQU     NOT(1 SHL Rcp_In) AND 0FFh
                +1           
                +1           Get_Rcp_Capture_Values MACRO
                +1                   mov     Temp1, PCA0CPL0                 ; Get PCA capture values
                +1                   mov     Temp2, PCA0CPH0
                +1           ENDM
                +1           Read_Rcp_Int MACRO
                +1                   mov     A, P0
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+4)   ; Is pwm polarity negative?
                +1                   cpl     A                                               ; Yes - invert
                +1           ENDM
                +1           Rcp_Int_Enable MACRO
                +1                   orl     PCA0CPM0, #01h                          ; Interrupt enabled
                +1           ENDM
                +1           Rcp_Int_Disable MACRO
                +1                   anl     PCA0CPM0, #0FEh                 ; Interrupt disabled
                +1           ENDM
                +1           Rcp_Int_First MACRO
                +1                   anl     PCA0CPM0, #0CFh                 
                +1                   jb      Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity positive?
                +1                   orl     PCA0CPM0, #20h                          ; Capture rising edge
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity negative?
                +1                   orl     PCA0CPM0, #10h                          ; Capture falling edge
                +1           ENDM
                +1           Rcp_Int_Second MACRO
                +1                   anl     PCA0CPM0, #0CFh                 
                +1                   jb      Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity positive?
                +1                   orl     PCA0CPM0, #10h                          ; Capture falling edge
                +1                   jnb     Flags3.PGM_RCP_PWM_POL, ($+6)   ; Is pwm polarity negative?
                +1                   orl     PCA0CPM0, #20h                          ; Capture rising edge
                +1           ENDM
                +1           Rcp_Clear_Int_Flag MACRO
                +1                   clr     CCF0                                            ; Clear interrupt flag
                +1           ENDM            
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 1 definitions *
                +1           ;*********************
                +1           ;                       EQU     7       ;i
                +1           ;                       EQU     6       ;i
                +1           CnFET           EQU     5       ;o
                +1           CpFET           EQU     4       ;o
                +1           BnFET           EQU     3       ;o
                +1           BpFET           EQU     2       ;o
                +1           AnFET           EQU     1       ;o
                +1           ApFET           EQU     0       ;o
                +1           
                +1           P1_DIGITAL      EQU     (1 SHL AnFET)+(1 SHL BnFET)+(1 SHL CnFET)+(1 SHL ApFET)+(1 SHL BpFE
                             T)+(1 SHL CpFET)
                +1           P1_INIT         EQU     0               
                +1           P1_PUSHPULL     EQU     (1 SHL AnFET)+(1 SHL BnFET)+(1 SHL CnFET)+(1 SHL ApFET)+(1 SHL BpFE
                             T)+(1 SHL CpFET)
                +1           P1_SKIP         EQU     0
                +1           
                +1           AnFET_on MACRO
                +1                   setb    P1.AnFET
                +1           ENDM
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    73

                +1           AnFET_off MACRO
                +1                   clr     P1.AnFET
                +1           ENDM
                +1           BnFET_on MACRO
                +1                   setb    P1.BnFET
                +1           ENDM
                +1           BnFET_off MACRO
                +1                   clr     P1.BnFET
                +1           ENDM
                +1           CnFET_on MACRO
                +1                   setb    P1.CnFET
                +1           ENDM
                +1           CnFET_off MACRO
                +1                   clr     P1.CnFET
                +1           ENDM
                +1           All_nFETs_Off MACRO
                +1                   clr     P1.AnFET
                +1                   clr     P1.BnFET
                +1                   clr     P1.CnFET
                +1           ENDM
                +1           
                +1           ApFET_on MACRO
                +1                   setb    P1.ApFET
                +1           ENDM
                +1           ApFET_off MACRO
                +1                   clr     P1.ApFET
                +1           ENDM
                +1           BpFET_on MACRO
                +1                   setb    P1.BpFET
                +1           ENDM
                +1           BpFET_off MACRO
                +1                   clr     P1.BpFET
                +1           ENDM
                +1           CpFET_on MACRO
                +1                   setb    P1.CpFET
                +1           ENDM
                +1           CpFET_off MACRO
                +1                   clr     P1.CpFET
                +1           ENDM
                +1           All_pFETs_Off MACRO
                +1                   clr     P1.ApFET
                +1                   clr     P1.BpFET
                +1                   clr     P1.CpFET
                +1           ENDM
                +1           
                +1           Brake_FETs_On   MACRO
                +1                   AnFET_on
                +1                   BnFET_on
                +1                   CnFET_on
                +1           ENDM
                +1           Damping_FET_On MACRO
                +1                   mov     A, DampingFET
                +1                   orl     P1, A
                +1           ENDM
                +1           
                +1           Set_Comp_Phase_A MACRO
                +1                   mov     CPT0MX, #01h    ; Set comparator multiplexer to phase A
                +1           ENDM
                +1           Set_Comp_Phase_B MACRO
                +1                   mov     CPT0MX, #02h    ; Set comparator multiplexer to phase B
                +1           ENDM
                +1           Set_Comp_Phase_C MACRO
                +1                   mov     CPT0MX, #03h    ; Set comparator multiplexer to phase C
                +1           ENDM
                +1           Read_Comp_Out MACRO
                +1                   mov     A, CPT0CN               ; Read comparator output
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    74

                +1           ENDM
                +1           
                +1           
                +1           ;*********************
                +1           ; PORT 2 definitions *
                +1           ;*********************
                +1           DebugPin                EQU     0       ;o
                +1           
                +1           P2_PUSHPULL     EQU     (1 SHL DebugPin)
                +1           
                +1           
                +1           ;**********************
                +1           ; MCU specific macros *
                +1           ;**********************
                +1           Interrupt_Table_Definition MACRO
                +1           CSEG AT 0                               ; Code segment start
                +1                   jmp reset
                +1           CSEG AT 0Bh                     ; Timer0 interrupt      
                +1                   jmp     t0_int  
                +1           CSEG AT 2Bh                     ; Timer2 interrupt      
                +1                   jmp     t2_int  
                +1           CSEG AT 5Bh                     ; PCA interrupt 
                +1                   jmp     pca_int 
                +1           CSEG AT 73h                     ; Timer3 interrupt      
                +1                   jmp     t3_int  
                +1           ENDM
                +1           
                +1           Initialize_Xbar MACRO
                +1                   mov     XBR2, #40h      ; Xbar enabled                  
                +1                   mov     XBR1, #01h      ; CEX0 routed to pin Rcp_In                     
                +1           ENDM
                +1           
                +1           Initialize_Adc MACRO
                +1                   mov     REF0CN, #0Ch    ; Set vdd (3.3V) as reference. Enable temp sensor and bias
                +1                   mov     ADC0CF, #59h    ; ADC clock 2MHz, PGA gain 1
                +1                   mov     ADC0MX, #Adc_Ip; Select ADC input
                +1                   mov     ADC0CN0, #80h   ; ADC enabled 
                +1                   mov     ADC0CN1, #01h   ; Common mode buffer enabled
                +1           ENDM
                +1           Set_Adc_Ip_Volt MACRO
                +1                   mov     ADC0MX, #Adc_Ip; Select ADC input
                +1           ENDM
                +1           Set_Adc_Ip_Temp MACRO
                +1                   mov     ADC0MX, #10h    ; Select temp sensor input
                +1           ENDM
                +1           Start_Adc MACRO
                +1                   mov     ADC0CN0, #90h   ; ADC start
                +1           ENDM
                +1           Read_Adc_Result MACRO
                +1                   mov     Temp1, ADC0L
                +1                   mov     Temp2, ADC0H
                +1           ENDM
                +1           Stop_Adc MACRO
                +1           ENDM
                +1           Set_RPM_Out MACRO
                +1           ENDM
                +1           Clear_RPM_Out MACRO
                +1           ENDM
                +1           Set_MCU_Clk_24MHz MACRO
                +1           ENDM
                +1           Set_MCU_Clk_48MHz MACRO
                +1           ENDM
                             ENDIF
                    4712     
                    4713     
                    4714     ;**** **** **** **** ****
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    75

                    4715     ; TX programming defaults
                    4716     ;
                    4717     ; Parameter dependencies:
                    4718     ; - Governor P gain, I gain and Range is only used if one of the three governor modes is se
                             lected
                    4719     ; - Governor setup target is only used if Setup governor mode is selected (or closed loop m
                             ode is on for multi)
                    4720     ;
                    4721     ; MAIN
  0007              4722     DEFAULT_PGM_MAIN_P_GAIN                         EQU 7   ; 1=0.13                2=0.17     
                                  3=0.25          4=0.38          5=0.50  6=0.75  7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0007              4723     DEFAULT_PGM_MAIN_I_GAIN                         EQU 7   ; 1=0.13                2=0.17     
                                  3=0.25          4=0.38          5=0.50  6=0.75  7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0001              4724     DEFAULT_PGM_MAIN_GOVERNOR_MODE          EQU 1   ; 1=Tx          2=Arm           3=Setup    
                                  4=Off
  0001              4725     DEFAULT_PGM_MAIN_GOVERNOR_RANGE         EQU 1   ; 1=High                2=Middle           
                                  3=Low
  0004              4726     DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM        EQU 4   ; 1=Off         2=3.0V/c                3=3
                             .1V/c                4=3.2V/c                5=3.3V/c        6=3.4V/c
  0003              4727     DEFAULT_PGM_MAIN_COMM_TIMING            EQU 3   ; 1=Low                 2=MediumLow     3=M
                             edium                4=MediumHigh    5=High
                    4728     IF DAMPED_MODE_ENABLE == 1
  0002              4729     DEFAULT_PGM_MAIN_PWM_FREQ                       EQU 2   ; 1=High                2=Low      
                                  3=DampedLight
                    4730     ELSE
                             DEFAULT_PGM_MAIN_PWM_FREQ                       EQU 2   ; 1=High                2=Low   
                             ENDIF
  0001              4733     DEFAULT_PGM_MAIN_DEMAG_COMP             EQU 1   ; 1=Disabled    2=Low           3=High
  0001              4734     DEFAULT_PGM_MAIN_DIRECTION                      EQU 1   ; 1=Normal      2=Reversed
  0001              4735     DEFAULT_PGM_MAIN_RCP_PWM_POL            EQU 1   ; 1=Positive    2=Negative
  00B4              4736     DEFAULT_PGM_MAIN_GOV_SETUP_TARGET       EQU 180 ; Target for governor in setup mode. Corres
                             ponds to 70% throttle
  0000              4737     DEFAULT_PGM_MAIN_REARM_START            EQU 0   ; 1=Enabled     0=Disabled
  0078              4738     DEFAULT_PGM_MAIN_BEEP_STRENGTH          EQU 120 ; Beep strength
  00C8              4739     DEFAULT_PGM_MAIN_BEACON_STRENGTH        EQU 200 ; Beacon strength
  0004              4740     DEFAULT_PGM_MAIN_BEACON_DELAY           EQU 4   ; 1=1m          2=2m                    3=5
                             m                    4=10m           5=Infinite
                    4741     
                    4742     ; TAIL
  0003              4743     DEFAULT_PGM_TAIL_GAIN                           EQU 3   ; 1=0.75                2=0.88     
                                  3=1.00          4=1.12          5=1.25
  0004              4744     DEFAULT_PGM_TAIL_IDLE_SPEED             EQU 4   ; 1=Low                 2=MediumLow     3=M
                             edium                4=MediumHigh    5=High
  0003              4745     DEFAULT_PGM_TAIL_COMM_TIMING            EQU 3   ; 1=Low                 2=MediumLow     3=M
                             edium                4=MediumHigh    5=High
                    4746     IF DAMPED_MODE_ENABLE == 1
  0003              4747     DEFAULT_PGM_TAIL_PWM_FREQ                       EQU 3   ; 1=High                2=Low      
                                  3=DampedLight 
                    4748     ELSE
                             DEFAULT_PGM_TAIL_PWM_FREQ                       EQU 1   ; 1=High                2=Low      
                                  
                             ENDIF
  0001              4751     DEFAULT_PGM_TAIL_DEMAG_COMP             EQU 1   ; 1=Disabled    2=Low           3=High
  0001              4752     DEFAULT_PGM_TAIL_DIRECTION                      EQU 1   ; 1=Normal      2=Reversed      3=B
                             idirectional
  0001              4753     DEFAULT_PGM_TAIL_RCP_PWM_POL            EQU 1   ; 1=Positive    2=Negative
  00FA              4754     DEFAULT_PGM_TAIL_BEEP_STRENGTH          EQU 250 ; Beep strength
  00FA              4755     DEFAULT_PGM_TAIL_BEACON_STRENGTH        EQU 250 ; Beacon strength
  0004              4756     DEFAULT_PGM_TAIL_BEACON_DELAY           EQU 4   ; 1=1m          2=2m                    3=5
                             m                    4=10m           5=Infinite
  0003              4757     DEFAULT_PGM_TAIL_PWM_DITHER                     EQU 3   ; 1=Off         2=3                
                                  3=7                     4=15                    5=31
                    4758     
                    4759     ; MULTI
  0009              4760     DEFAULT_PGM_MULTI_P_GAIN                        EQU 9   ; 1=0.13                2=0.17     
                                  3=0.25          4=0.38          5=0.50  6=0.75  7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    76

  0009              4761     DEFAULT_PGM_MULTI_I_GAIN                        EQU 9   ; 1=0.13                2=0.17     
                                  3=0.25          4=0.38          5=0.50  6=0.75  7=1.00 8=1.5 9=2.0 10=3.0 11=4.0 12=6.0 13=8.0
  0004              4762     DEFAULT_PGM_MULTI_GOVERNOR_MODE         EQU 4   ; 1=HiRange     2=MidRange      3=LoRange  
                                          4=Off
  0003              4763     DEFAULT_PGM_MULTI_GAIN                          EQU 3   ; 1=0.75                2=0.88     
                                  3=1.00          4=1.12          5=1.25
  0003              4764     DEFAULT_PGM_MULTI_COMM_TIMING           EQU 3   ; 1=Low                 2=MediumLow     3=M
                             edium                4=MediumHigh    5=High
                    4765     IF DAMPED_MODE_ENABLE == 1
  0003              4766     DEFAULT_PGM_MULTI_PWM_FREQ                      EQU 3   ; 1=High                2=Low      
                                  3=DampedLight 
                    4767     ELSE
                             DEFAULT_PGM_MULTI_PWM_FREQ                      EQU 1   ; 1=High                2=Low
                             ENDIF
  0002              4770     DEFAULT_PGM_MULTI_DEMAG_COMP            EQU 2   ; 1=Disabled    2=Low           3=High
  0001              4771     DEFAULT_PGM_MULTI_DIRECTION                     EQU 1   ; 1=Normal      2=Reversed      3=B
                             idirectional
  0001              4772     DEFAULT_PGM_MULTI_RCP_PWM_POL           EQU 1   ; 1=Positive    2=Negative
  0028              4773     DEFAULT_PGM_MULTI_BEEP_STRENGTH         EQU 40  ; Beep strength
  0050              4774     DEFAULT_PGM_MULTI_BEACON_STRENGTH       EQU 80  ; Beacon strength
  0004              4775     DEFAULT_PGM_MULTI_BEACON_DELAY          EQU 4   ; 1=1m          2=2m                    3=5
                             m                    4=10m           5=Infinite
  0003              4776     DEFAULT_PGM_MULTI_PWM_DITHER            EQU 3   ; 1=Off         2=3                     3=7
                                                  4=15                    5=31
                    4777     
                    4778     ; COMMON
  0001              4779     DEFAULT_PGM_ENABLE_TX_PROGRAM           EQU 1   ; 1=Enabled     0=Disabled
  0025              4780     DEFAULT_PGM_PPM_MIN_THROTTLE            EQU 37  ; 4*37+1000=1148
  00D0              4781     DEFAULT_PGM_PPM_MAX_THROTTLE            EQU 208 ; 4*208+1000=1832
  007A              4782     DEFAULT_PGM_PPM_CENTER_THROTTLE         EQU 122 ; 4*122+1000=1488 (used in bidirectional mo
                             de)
  0000              4783     DEFAULT_PGM_BEC_VOLTAGE_HIGH            EQU 0   ; 0=Low         1+= High or higher      
  0001              4784     DEFAULT_PGM_ENABLE_TEMP_PROT            EQU 1   ; 1=Enabled     0=Disabled
  0001              4785     DEFAULT_PGM_ENABLE_POWER_PROT           EQU 1   ; 1=Enabled     0=Disabled
  0000              4786     DEFAULT_PGM_ENABLE_PWM_INPUT            EQU 0   ; 1=Enabled     0=Disabled
  0000              4787     DEFAULT_PGM_BRAKE_ON_STOP                       EQU 0   ; 1=Enabled     0=Disabled
                    4788     
                    4789     ;**** **** **** **** ****
                    4790     ; Constant definitions for main
                    4791     IF MODE == 0
                    4792     
  0002              4793     GOV_SPOOLRATE           EQU     2       ; Number of steps for governor requested pwm per 32
                             ms
  000A              4794     RCP_TIMEOUT_PPM         EQU     10      ; Number of timer2H overflows (about 32ms) before c
                             onsidering rc pulse lost
  0040              4795     RCP_TIMEOUT                     EQU     64      ; Number of timer2L overflows (about 128us)
                              before considering rc pulse lost
  0020              4796     RCP_SKIP_RATE           EQU 32  ; Number of timer2L overflows (about 128us) before reenabli
                             ng rc pulse detection
  0000              4797     RCP_MIN                         EQU 0   ; This is minimum RC pulse length
  00FF              4798     RCP_MAX                         EQU 255 ; This is maximum RC pulse length
  0002              4799     RCP_VALIDATE            EQU 2   ; Require minimum this pulse length to validate RC pulse
  0001              4800     RCP_STOP                        EQU 1   ; Stop motor at or below this pulse length
  00FA              4801     RCP_STOP_LIMIT          EQU 250 ; Stop motor if this many timer2H overflows (~32ms) are bel
                             ow stop limit
                    4802     
  0032              4803     PWM_START                       EQU     50      ; PWM used as max power during start
                    4804     
  0001              4805     COMM_TIME_MIN           EQU 1   ; Minimum time (in us) for commutation wait
                    4806     
  0008              4807     TEMP_CHECK_RATE         EQU 8   ; Number of adc conversions for each check of temperature (
                             the other conversions are used for voltage)
                    4808     
                    4809     ENDIF
                    4810     ; Constant definitions for tail
                    4811     IF MODE == 1
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    77

                             
                             GOV_SPOOLRATE           EQU     1       ; Number of steps for governor requested pwm per 32
                             ms
                             RCP_TIMEOUT_PPM         EQU     10      ; Number of timer2H overflows (about 32ms) before c
                             onsidering rc pulse lost
                             RCP_TIMEOUT                     EQU 24  ; Number of timer2L overflows (about 128us) before 
                             considering rc pulse lost
                             RCP_SKIP_RATE           EQU 6   ; Number of timer2L overflows (about 128us) before reenabli
                             ng rc pulse detection
                             RCP_MIN                         EQU 0   ; This is minimum RC pulse length
                             RCP_MAX                         EQU 255 ; This is maximum RC pulse length
                             RCP_VALIDATE            EQU 2   ; Require minimum this pulse length to validate RC pulse
                             RCP_STOP                        EQU 1   ; Stop motor at or below this pulse length
                             RCP_STOP_LIMIT          EQU 130 ; Stop motor if this many timer2H overflows (~32ms) are bel
                             ow stop limit
                             
                             PWM_START                       EQU     50      ; PWM used as max power during start
                             
                             COMM_TIME_MIN           EQU 1   ; Minimum time (in us) for commutation wait
                             
                             TEMP_CHECK_RATE         EQU 8   ; Number of adc conversions for each check of temperature (
                             the other conversions are used for voltage)
                             
                             ENDIF
                    4830     ; Constant definitions for multi
                    4831     IF MODE == 2
                             
                             GOV_SPOOLRATE           EQU     1       ; Number of steps for governor requested pwm per 32
                             ms
                             RCP_TIMEOUT_PPM         EQU     10      ; Number of timer2H overflows (about 32ms) before c
                             onsidering rc pulse lost
                             RCP_TIMEOUT                     EQU 24  ; Number of timer2L overflows (about 128us) before 
                             considering rc pulse lost
                             RCP_SKIP_RATE           EQU 6   ; Number of timer2L overflows (about 128us) before reenabli
                             ng rc pulse detection
                             RCP_MIN                         EQU 0   ; This is minimum RC pulse length
                             RCP_MAX                         EQU 255 ; This is maximum RC pulse length
                             RCP_VALIDATE            EQU 2   ; Require minimum this pulse length to validate RC pulse
                             RCP_STOP                        EQU 1   ; Stop motor at or below this pulse length
                             RCP_STOP_LIMIT          EQU 250 ; Stop motor if this many timer2H overflows (~32ms) are bel
                             ow stop limit
                             
                             PWM_START                       EQU     50      ; PWM used as max power during start
                             
                             COMM_TIME_MIN           EQU 1   ; Minimum time (in us) for commutation wait
                             
                             TEMP_CHECK_RATE         EQU 8   ; Number of adc conversions for each check of temperature (
                             the other conversions are used for voltage)
                             
                             ENDIF
                    4850     
                    4851     ;**** **** **** **** ****
                    4852     ; Temporary register definitions
  REG               4853     Temp1           EQU     R0
  REG               4854     Temp2           EQU     R1
  REG               4855     Temp3           EQU     R2
  REG               4856     Temp4           EQU     R3
  REG               4857     Temp5           EQU     R4
  REG               4858     Temp6           EQU     R5
  REG               4859     Temp7           EQU     R6
  REG               4860     Temp8           EQU     R7
                    4861     
                    4862     ;**** **** **** **** ****
                    4863     ; Register definitions
----                4864     DSEG AT 20h                                     ; Variables segment 
                    4865     
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    78

0020                4866     Bit_Access:                                     DS      1               ; MUST BE AT THIS A
                             DDRESS. Variable at bit accessible address (for non interrupt routines)
0021                4867     Bit_Access_Int:                         DS      1               ; Variable at bit accessibl
                             e address (for interrupts)
                    4868     
0022                4869     Requested_Pwm:                          DS      1               ; Requested pwm (from RC pu
                             lse value)
0023                4870     Governor_Req_Pwm:                       DS      1               ; Governor requested pwm (s
                             ets governor target)
0024                4871     Current_Pwm:                            DS      1               ; Current pwm
0025                4872     Current_Pwm_Limited:            DS      1               ; Current pwm that is limited
0026                4873     Current_Pwm_Lim_Dith:           DS      1               ; Current pwm that is limited and d
                             ithered (applied to the motor output)
0027                4874     Rcp_Prev_Edge_L:                        DS      1               ; RC pulse previous edge ti
                             mer3 timestamp (lo byte)
0028                4875     Rcp_Prev_Edge_H:                        DS      1               ; RC pulse previous edge ti
                             mer3 timestamp (hi byte)
0029                4876     Rcp_Outside_Range_Cnt:          DS      1               ; RC pulse outside range counter (i
                             ncrementing) 
002A                4877     Rcp_Timeout_Cntd:                       DS      1               ; RC pulse timeout counter 
                             (decrementing) 
002B                4878     Rcp_Skip_Cntd:                          DS      1               ; RC pulse skip counter (de
                             crementing) 
                    4879     
002C                4880     Flags0:                                         DS      1       ; State flags. Reset upon i
                             nit_start
  0000              4881     T3_PENDING                                      EQU 0           ; Timer3 pending flag
  0001              4882     RCP_MEAS_PWM_FREQ                       EQU     1               ; Measure RC pulse pwm freq
                             uency
  0002              4883     PWM_ON                                          EQU     2               ; Set in on part of
                              pwm cycle
  0003              4884     PWM_TIMER0_OVERFLOW                     EQU     3               ; Set for 48MHz MCUs when P
                             WM timer 0 overflows
  0004              4885     DEMAG_DETECTED                          EQU 4           ; Set when excessive demag time is 
                             detected
  0005              4886     DEMAG_CUT_POWER                         EQU 5           ; Set when demag compensation cuts 
                             power
  0006              4887     HIGH_RPM                                        EQU 6           ; Set when motor rpm is hig
                             h (Comm_Period4x_H less than 2)
                    4888     ;                                                       EQU 7   
                    4889     
002D                4890     Flags1:                                         DS      1       ; State flags. Reset upon i
                             nit_start 
  0000              4891     MOTOR_SPINNING                          EQU     0               ; Set when in motor is spin
                             ning
  0001              4892     STARTUP_PHASE                           EQU 1           ; Set when in startup phase
  0002              4893     INITIAL_RUN_PHASE                       EQU     2               ; Set when in initial run p
                             hase, before synchronized run is achieved
  0003              4894     MOTOR_STARTED                           EQU 3           ; Set when motor is started
  0004              4895     DIR_CHANGE_BRAKE                        EQU 4           ; Set when braking before direction
                              change
  0005              4896     COMP_TIMED_OUT                          EQU 5           ; Set when comparator reading timed
                              out
  0006              4897     GOV_ACTIVE                                      EQU 6           ; Set when governor is acti
                             ve (enabled when speed is above minimum)
  0007              4898     SKIP_DAMP_ON                            EQU 7           ; Set when turning damping fet on i
                             s skipped
                    4899     
002E                4900     Flags2:                                         DS      1               ; State flags. NOT 
                             reset upon init_start
  0000              4901     RCP_UPDATED                                     EQU 0           ; New RC pulse length value
                              available
  0001              4902     RCP_EDGE_NO                                     EQU 1           ; RC pulse edge no. 0=risin
                             g, 1=falling
  0002              4903     PGM_PWMOFF_DAMPED                       EQU     2               ; Programmed pwm off damped
                              mode
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    79

  0003              4904     PGM_PWM_HIGH_FREQ                       EQU     3               ; Progremmed pwm high frequ
                             ency
  0004              4905     RCP_PPM                                         EQU 4           ; RC pulse ppm type input (
                             set also when oneshot is set)
  0005              4906     RCP_PPM_ONESHOT125                      EQU 5           ; RC pulse ppm type input is OneSho
                             t125
  0006              4907     RCP_DIR_REV                                     EQU 6           ; RC pulse direction in bid
                             irectional mode
                    4908     ;                                                       EQU 7   
                    4909     
002F                4910     Flags3:                                         DS      1               ; State flags. NOT 
                             reset upon init_start
  0000              4911     RCP_PWM_FREQ_1KHZ                       EQU 0           ; RC pulse pwm frequency is 1kHz
  0001              4912     RCP_PWM_FREQ_2KHZ                       EQU 1           ; RC pulse pwm frequency is 2kHz
  0002              4913     RCP_PWM_FREQ_4KHZ                       EQU 2           ; RC pulse pwm frequency is 4kHz
  0003              4914     RCP_PWM_FREQ_8KHZ                       EQU 3           ; RC pulse pwm frequency is 8kHz
  0004              4915     RCP_PWM_FREQ_12KHZ                      EQU 4           ; RC pulse pwm frequency is 12kHz
  0005              4916     PGM_DIR_REV                                     EQU 5           ; Programmed direction. 0=n
                             ormal, 1=reversed
  0006              4917     PGM_RCP_PWM_POL                         EQU     6               ; Programmed RC pulse pwm p
                             olarity. 0=positive, 1=negative
  0007              4918     FULL_THROTTLE_RANGE                     EQU 7           ; When set full throttle range is u
                             sed (1000-2000us) and stored calibration values are ignored
                    4919     
                    4920     
                    4921     ;**** **** **** **** ****
                    4922     ; RAM definitions
----                4923     DSEG AT 30h                                             ; Ram data segment, direct addressi
                             ng
                    4924     
0030                4925     Initial_Arm:                            DS      1               ; Variable that is set duri
                             ng the first arm sequence after power on
                    4926     
0031                4927     Power_On_Wait_Cnt_L:            DS      1               ; Power on wait counter (lo byte)
0032                4928     Power_On_Wait_Cnt_H:            DS      1               ; Power on wait counter (hi byte)
                    4929     
0033                4930     Startup_Cnt:                            DS      1               ; Startup phase commutation
                             s counter (incrementing)
0034                4931     Startup_Zc_Timeout_Cntd:        DS      1               ; Startup zero cross timeout counte
                             r (decrementing)
0035                4932     Initial_Run_Rot_Cntd:           DS      1               ; Initial run rotations counter (de
                             crementing)
0036                4933     Stall_Cnt:                                      DS      1               ; Counts start/run 
                             attempts that resulted in stall. Reset upon a proper stop
0037                4934     Demag_Detected_Metric:          DS      1               ; Metric used to gauge demag event 
                             frequency
0038                4935     Demag_Pwr_Off_Thresh:           DS      1               ; Metric threshold above which powe
                             r is cut
0039                4936     Low_Rpm_Pwr_Slope:                      DS      1               ; Sets the slope of power i
                             ncrease for low rpms
                    4937     
003A                4938     Timer2_X:                                       DS      1               ; Timer 2 extended 
                             byte
003B                4939     Prev_Comm_L:                            DS      1               ; Previous commutation time
                             r3 timestamp (lo byte)
003C                4940     Prev_Comm_H:                            DS      1               ; Previous commutation time
                             r3 timestamp (hi byte)
003D                4941     Prev_Comm_X:                            DS      1               ; Previous commutation time
                             r3 timestamp (ext byte)
003E                4942     Prev_Prev_Comm_L:                       DS      1               ; Pre-previous commutation 
                             timer3 timestamp (lo byte)
003F                4943     Prev_Prev_Comm_H:                       DS      1               ; Pre-previous commutation 
                             timer3 timestamp (hi byte)
0040                4944     Comm_Period4x_L:                        DS      1               ; Timer3 counts between the
                              last 4 commutations (lo byte)
0041                4945     Comm_Period4x_H:                        DS      1               ; Timer3 counts between the
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    80

                              last 4 commutations (hi byte)
0042                4946     Comm_Phase:                                     DS      1               ; Current commutati
                             on phase
0043                4947     Comparator_Read_Cnt:            DS      1               ; Number of comparator reads done
                    4948     
0044                4949     Gov_Target_L:                           DS      1               ; Governor target (lo byte)
0045                4950     Gov_Target_H:                           DS      1               ; Governor target (hi byte)
0046                4951     Gov_Integral_L:                         DS      1               ; Governor integral error (
                             lo byte)
0047                4952     Gov_Integral_H:                         DS      1               ; Governor integral error (
                             hi byte)
0048                4953     Gov_Integral_X:                         DS      1               ; Governor integral error (
                             ex byte)
0049                4954     Gov_Proportional_L:                     DS      1               ; Governor proportional err
                             or (lo byte)
004A                4955     Gov_Proportional_H:                     DS      1               ; Governor proportional err
                             or (hi byte)
004B                4956     Gov_Prop_Pwm:                           DS      1               ; Governor calculated new p
                             wm based upon proportional error
004C                4957     Gov_Arm_Target:                         DS      1               ; Governor arm target value
                    4958     
004D                4959     Wt_Adv_Start_L:                         DS      1               ; Timer3 start point for co
                             mmutation advance timing (lo byte)
004E                4960     Wt_Adv_Start_H:                         DS      1               ; Timer3 start point for co
                             mmutation advance timing (hi byte)
004F                4961     Wt_Zc_Scan_Start_L:                     DS      1               ; Timer3 start point from c
                             ommutation to zero cross scan (lo byte)
0050                4962     Wt_Zc_Scan_Start_H:                     DS      1               ; Timer3 start point from c
                             ommutation to zero cross scan (hi byte)
0051                4963     Wt_Zc_Tout_Start_L:                     DS      1               ; Timer3 start point for ze
                             ro cross scan timeout (lo byte)
0052                4964     Wt_Zc_Tout_Start_H:                     DS      1               ; Timer3 start point for ze
                             ro cross scan timeout (hi byte)
0053                4965     Wt_Comm_Start_L:                        DS      1               ; Timer3 start point from z
                             ero cross to commutation (lo byte)
0054                4966     Wt_Comm_Start_H:                        DS      1               ; Timer3 start point from z
                             ero cross to commutation (hi byte)
                    4967     
0055                4968     Rcp_PrePrev_Edge_L:                     DS      1               ; RC pulse pre previous edg
                             e pca timestamp (lo byte)
0056                4969     Rcp_PrePrev_Edge_H:                     DS      1               ; RC pulse pre previous edg
                             e pca timestamp (hi byte)
0057                4970     Rcp_Edge_L:                                     DS      1               ; RC pulse edge pca
                              timestamp (lo byte)
0058                4971     Rcp_Edge_H:                                     DS      1               ; RC pulse edge pca
                              timestamp (hi byte)
0059                4972     Rcp_Prev_Period_L:                      DS      1               ; RC pulse previous period 
                             (lo byte)
005A                4973     Rcp_Prev_Period_H:                      DS      1               ; RC pulse previous period 
                             (hi byte)
005B                4974     Rcp_Period_Diff_Accepted:       DS      1               ; RC pulse period difference accept
                             able
005C                4975     New_Rcp:                                        DS      1               ; New RC pulse valu
                             e in pca counts
005D                4976     Prev_Rcp_Pwm_Freq:                      DS      1               ; Previous RC pulse pwm fre
                             quency (used during pwm frequency measurement)
005E                4977     Curr_Rcp_Pwm_Freq:                      DS      1               ; Current RC pulse pwm freq
                             uency (used during pwm frequency measurement)
005F                4978     Rcp_Stop_Cnt:                           DS      1               ; Counter for RC pulses bel
                             ow stop value
0060                4979     Auto_Bailout_Armed:                     DS      1               ; Set when auto rotation ba
                             ilout is armed 
                    4980     
0061                4981     Pwm_Limit:                                      DS      1               ; Maximum allowed p
                             wm 
0062                4982     Pwm_Limit_Spoolup:                      DS      1               ; Maximum allowed pwm durin
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    81

                             g spoolup
0063                4983     Pwm_Limit_By_Rpm:                       DS      1               ; Maximum allowed pwm for l
                             ow or high rpms
0064                4984     Pwm_Spoolup_Beg:                        DS      1               ; Pwm to begin main spoolup
                              with
0065                4985     Pwm_Motor_Idle:                         DS      1               ; Motor idle speed pwm
0066                4986     Pwm_Dither_Decoded:                     DS      1               ; Decoded pwm dither value
0067                4987     Pwm_Dither_Excess_Power:        DS      1               ; Excess power (above max) from pwm
                              dither
0068                4988     Random:                                         DS      1               ; Random number fro
                             m LFSR 
                    4989     
0069                4990     Spoolup_Limit_Cnt:                      DS      1               ; Interrupt count for spool
                             up limit
006A                4991     Spoolup_Limit_Skip:                     DS      1               ; Interrupt skips for spool
                             up limit increment (1=no skips, 2=skip one etc)
006B                4992     Main_Spoolup_Time_3x:           DS      1               ; Main spoolup time x3
006C                4993     Main_Spoolup_Time_10x:          DS      1               ; Main spoolup time x10
006D                4994     Main_Spoolup_Time_15x:          DS      1               ; Main spoolup time x15
                    4995     
006E                4996     Lipo_Adc_Limit_L:                       DS      1               ; Low voltage limit adc val
                             ue (lo byte)
006F                4997     Lipo_Adc_Limit_H:                       DS      1               ; Low voltage limit adc val
                             ue (hi byte)
0070                4998     Adc_Conversion_Cnt:                     DS      1               ; Adc conversion counter
                    4999     
0071                5000     Current_Average_Temp:           DS      1               ; Current average temperature (lo b
                             yte ADC reading, assuming hi byte is 1)
                    5001     
0072                5002     Ppm_Throttle_Gain:                      DS      1               ; Gain to be applied to RCP
                              value for PPM input
0073                5003     Beep_Strength:                          DS      1               ; Strength of beeps
                    5004     
0074                5005     Tx_Pgm_Func_No:                         DS      1               ; Function number when doin
                             g programming by tx
0075                5006     Tx_Pgm_Paraval_No:                      DS      1               ; Parameter value number wh
                             en doing programming by tx
0076                5007     Tx_Pgm_Beep_No:                         DS      1               ; Beep number when doing pr
                             ogramming by tx
                    5008     
0077                5009     Skip_T2_Int:                            DS      1               ; Set for 48MHz MCUs when t
                             imer 2 interrupt shall be ignored 
0078                5010     Skip_T2h_Int:                           DS      1               ; Set for 48MHz MCUs when t
                             imer 2 high interrupt shall be ignored 
0079                5011     Timer0_Overflow_Value:          DS      1               ; Remaining timer 0 wait time used 
                             with 48MHz MCUs
007A                5012     Clock_Set_At_48MHz:                     DS      1               ; Variable set if 48MHz MCU
                             s run at 48MHz
007B                5013     DampingFET:                                     DS      1               ; Port position of 
                             fet used for damping
                    5014     
007C                5015     Flash_Key_1:                            DS      1               ; Flash key one
007D                5016     Flash_Key_2:                            DS      1               ; Flash key two
                    5017     
                    5018     ; Indirect addressing data segment. The variables below must be in this sequence
----                5019     ISEG AT 080h                                    
0080                5020     Pgm_Gov_P_Gain:                         DS      1               ; Programmed governor P gain
0081                5021     Pgm_Gov_I_Gain:                         DS      1               ; Programmed governor I gain
0082                5022     Pgm_Gov_Mode:                           DS      1               ; Programmed governor mode
0083                5023     Pgm_Low_Voltage_Lim:            DS      1               ; Programmed low voltage limit
0084                5024     Pgm_Motor_Gain:                         DS      1               ; Programmed motor gain
0085                5025     Pgm_Motor_Idle:                         DS      1               ; Programmed motor idle spe
                             ed
0086                5026     Pgm_Startup_Pwr:                        DS      1               ; Programmed startup power
0087                5027     Pgm_Pwm_Freq:                           DS      1               ; Programmed pwm frequency
0088                5028     Pgm_Direction:                          DS      1               ; Programmed rotation direc
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    82

                             tion
0089                5029     Pgm_Input_Pol:                          DS      1               ; Programmed input pwm pola
                             rity
008A                5030     Initialized_L_Dummy:            DS      1               ; Place holder
008B                5031     Initialized_H_Dummy:            DS      1               ; Place holder
008C                5032     Pgm_Enable_TX_Program:          DS      1               ; Programmed enable/disable value f
                             or TX programming
008D                5033     Pgm_Main_Rearm_Start:           DS      1               ; Programmed enable/disable re-armi
                             ng main every start 
008E                5034     Pgm_Gov_Setup_Target:           DS      1               ; Programmed main governor setup ta
                             rget
008F                5035     _Pgm_Startup_Rpm:                       DS      1               ; Programmed startup rpm (u
                             nused - place holder)
0090                5036     _Pgm_Startup_Accel:                     DS      1               ; Programmed startup accele
                             ration (unused - place holder)
0091                5037     _Pgm_Volt_Comp:                         DS      1               ; Place holder
0092                5038     Pgm_Comm_Timing:                        DS      1               ; Programmed commutation ti
                             ming
0093                5039     _Pgm_Damping_Force:                     DS      1               ; Programmed damping force 
                             (unused - place holder)
0094                5040     Pgm_Gov_Range:                          DS      1               ; Programmed governor range
0095                5041     _Pgm_Startup_Method:            DS      1               ; Programmed startup method (unused
                              - place holder)
0096                5042     Pgm_Ppm_Min_Throttle:           DS      1               ; Programmed throttle minimum
0097                5043     Pgm_Ppm_Max_Throttle:           DS      1               ; Programmed throttle maximum
0098                5044     Pgm_Beep_Strength:                      DS      1               ; Programmed beep strength
0099                5045     Pgm_Beacon_Strength:            DS      1               ; Programmed beacon strength
009A                5046     Pgm_Beacon_Delay:                       DS      1               ; Programmed beacon delay
009B                5047     _Pgm_Throttle_Rate:                     DS      1               ; Programmed throttle rate 
                             (unused - place holder)
009C                5048     Pgm_Demag_Comp:                         DS      1               ; Programmed demag compensa
                             tion
009D                5049     Pgm_BEC_Voltage_High:           DS      1               ; Programmed BEC voltage
009E                5050     Pgm_Ppm_Center_Throttle:        DS      1               ; Programmed throttle center (in bi
                             directional mode)
009F                5051     Pgm_Main_Spoolup_Time:          DS      1               ; Programmed main spoolup time
00A0                5052     Pgm_Enable_Temp_Prot:           DS      1               ; Programmed temperature protection
                              enable
00A1                5053     Pgm_Enable_Power_Prot:          DS      1               ; Programmed low rpm power protecti
                             on enable
00A2                5054     Pgm_Enable_Pwm_Input:           DS      1               ; Programmed PWM input signal enable
00A3                5055     Pgm_Pwm_Dither:                         DS      1               ; Programmed output PWM dit
                             her
00A4                5056     Pgm_Brake_On_Stop:                      DS      1               ; Programmed braking when t
                             hrottle is zero
                    5057     
                    5058     ; The sequence of the variables below is no longer of importance
00A5                5059     Pgm_Gov_P_Gain_Decoded:         DS      1               ; Programmed governor decoded P gain
00A6                5060     Pgm_Gov_I_Gain_Decoded:         DS      1               ; Programmed governor decoded I gain
00A7                5061     Pgm_Startup_Pwr_Decoded:        DS      1               ; Programmed startup power decoded
                    5062     
                    5063     
                    5064     ; Indirect addressing data segment
----                5065     ISEG AT 0D0h                                    
00D0                5066     Tag_Temporary_Storage:          DS      48              ; Temporary storage for tags when u
                             pdating "Eeprom"
                    5067     
                    5068     
                    5069     ;**** **** **** **** ****
----                5070     CSEG AT 1A00h            ; "Eeprom" segment
  000E              5071     EEPROM_FW_MAIN_REVISION         EQU     14              ; Main revision of the firmware
  0009              5072     EEPROM_FW_SUB_REVISION          EQU     9               ; Sub revision of the firmware
  0015              5073     EEPROM_LAYOUT_REVISION          EQU     21              ; Revision of the EEPROM layout
                    5074     
1A00 0E             5075     Eep_FW_Main_Revision:           DB      EEPROM_FW_MAIN_REVISION                 ; EEPROM fi
                             rmware main revision number
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    83

1A01 09             5076     Eep_FW_Sub_Revision:            DB      EEPROM_FW_SUB_REVISION                  ; EEPROM fi
                             rmware sub revision number
1A02 15             5077     Eep_Layout_Revision:            DB      EEPROM_LAYOUT_REVISION                  ; EEPROM la
                             yout revision number
                    5078     
                    5079     IF MODE == 0
1A03 07             5080     Eep_Pgm_Gov_P_Gain:                     DB      DEFAULT_PGM_MAIN_P_GAIN                 ; E
                             EPROM copy of programmed governor P gain
1A04 07             5081     Eep_Pgm_Gov_I_Gain:                     DB      DEFAULT_PGM_MAIN_I_GAIN                 ; E
                             EPROM copy of programmed governor I gain
1A05 01             5082     Eep_Pgm_Gov_Mode:                       DB      DEFAULT_PGM_MAIN_GOVERNOR_MODE  ; EEPROM co
                             py of programmed governor mode
1A06 04             5083     Eep_Pgm_Low_Voltage_Lim:                DB      DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM        ; E
                             EPROM copy of programmed low voltage limit
1A07 FF             5084     _Eep_Pgm_Motor_Gain:            DB      0FFh                                               
                                  
1A08 FF             5085     _Eep_Pgm_Motor_Idle:            DB      0FFh                                               
                                  
1A09 09             5086     Eep_Pgm_Startup_Pwr:            DB      DEFAULT_PGM_MAIN_STARTUP_PWR            ; EEPROM co
                             py of programmed startup power
1A0A 02             5087     Eep_Pgm_Pwm_Freq:                       DB      DEFAULT_PGM_MAIN_PWM_FREQ               ; E
                             EPROM copy of programmed pwm frequency
1A0B 01             5088     Eep_Pgm_Direction:                      DB      DEFAULT_PGM_MAIN_DIRECTION              ; E
                             EPROM copy of programmed rotation direction
1A0C 01             5089     Eep_Pgm_Input_Pol:                      DB      DEFAULT_PGM_MAIN_RCP_PWM_POL            ; E
                             EPROM copy of programmed input polarity
1A0D A5             5090     Eep_Initialized_L:                      DB      0A5h                                       
                                          ; EEPROM initialized signature low byte
1A0E 5A             5091     Eep_Initialized_H:                      DB      05Ah                                       
                                          ; EEPROM initialized signature high byte
1A0F 01             5092     Eep_Enable_TX_Program:          DB      DEFAULT_PGM_ENABLE_TX_PROGRAM           ; EEPROM TX
                              programming enable
1A10 00             5093     Eep_Main_Rearm_Start:           DB      DEFAULT_PGM_MAIN_REARM_START            ; EEPROM re
                             -arming main enable
1A11 B4             5094     Eep_Pgm_Gov_Setup_Target:       DB      DEFAULT_PGM_MAIN_GOV_SETUP_TARGET       ; EEPROM ma
                             in governor setup target
1A12 FF             5095     _Eep_Pgm_Startup_Rpm:           DB      0FFh    
1A13 FF             5096     _Eep_Pgm_Startup_Accel:         DB      0FFh    
1A14 FF             5097     _Eep_Pgm_Volt_Comp:                     DB      0FFh    
1A15 03             5098     Eep_Pgm_Comm_Timing:            DB      DEFAULT_PGM_MAIN_COMM_TIMING            ; EEPROM co
                             py of programmed commutation timing
1A16 FF             5099     _Eep_Pgm_Damping_Force:         DB      0FFh                                            
1A17 01             5100     Eep_Pgm_Gov_Range:                      DB      DEFAULT_PGM_MAIN_GOVERNOR_RANGE ; EEPROM co
                             py of programmed governor range
1A18 FF             5101     _Eep_Pgm_Startup_Method:                DB      0FFh    
1A19 25             5102     Eep_Pgm_Ppm_Min_Throttle:       DB      DEFAULT_PGM_PPM_MIN_THROTTLE            ; EEPROM co
                             py of programmed minimum throttle (final value is 4x+1000=1148)
1A1A D0             5103     Eep_Pgm_Ppm_Max_Throttle:       DB      DEFAULT_PGM_PPM_MAX_THROTTLE            ; EEPROM co
                             py of programmed minimum throttle (final value is 4x+1000=1832)
1A1B 78             5104     Eep_Pgm_Beep_Strength:          DB      DEFAULT_PGM_MAIN_BEEP_STRENGTH  ; EEPROM copy of pr
                             ogrammed beep strength
1A1C C8             5105     Eep_Pgm_Beacon_Strength:                DB      DEFAULT_PGM_MAIN_BEACON_STRENGTH        ; E
                             EPROM copy of programmed beacon strength
1A1D 04             5106     Eep_Pgm_Beacon_Delay:           DB      DEFAULT_PGM_MAIN_BEACON_DELAY           ; EEPROM co
                             py of programmed beacon delay
1A1E FF             5107     _Eep_Pgm_Throttle_Rate:         DB      0FFh    
1A1F 01             5108     Eep_Pgm_Demag_Comp:                     DB      DEFAULT_PGM_MAIN_DEMAG_COMP             ; E
                             EPROM copy of programmed demag compensation
1A20 00             5109     Eep_Pgm_BEC_Voltage_High:       DB      DEFAULT_PGM_BEC_VOLTAGE_HIGH            ; EEPROM co
                             py of programmed BEC voltage
1A21 FF             5110     _Eep_Pgm_Ppm_Center_Throttle:   DB      0FFh                                               
                                  
1A22 0A             5111     Eep_Pgm_Main_Spoolup_Time:      DB      DEFAULT_PGM_MAIN_SPOOLUP_TIME           ; EEPROM co
                             py of programmed main spoolup time
1A23 01             5112     Eep_Pgm_Temp_Prot_Enable:       DB      DEFAULT_PGM_ENABLE_TEMP_PROT            ; EEPROM co
                             py of programmed temperature protection enable
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    84

1A24 01             5113     Eep_Pgm_Enable_Power_Prot:      DB      DEFAULT_PGM_ENABLE_POWER_PROT           ; EEPROM co
                             py of programmed low rpm power protection enable
1A25 00             5114     Eep_Pgm_Enable_Pwm_Input:       DB      DEFAULT_PGM_ENABLE_PWM_INPUT            ; EEPROM co
                             py of programmed PWM input signal enable
1A26 FF             5115     _Eep_Pgm_Pwm_Dither:            DB      0FFh    
1A27 00             5116     Eep_Pgm_Brake_On_Stop:          DB      DEFAULT_PGM_BRAKE_ON_STOP               ; EEPROM co
                             py of programmed braking when throttle is zero
                    5117     ENDIF 
                    5118     
                    5119     IF MODE == 1
                             _Eep_Pgm_Gov_P_Gain:            DB      0FFh                                               
                                  
                             _Eep_Pgm_Gov_I_Gain:            DB      0FFh                                               
                                  
                             _Eep_Pgm_Gov_Mode:                      DB      0FFh                                       
                                          
                             _Eep_Pgm_Low_Voltage_Lim:       DB      0FFh                                               
                                  
                             Eep_Pgm_Motor_Gain:                     DB      DEFAULT_PGM_TAIL_GAIN                   ; E
                             EPROM copy of programmed tail gain
                             Eep_Pgm_Motor_Idle:                     DB      DEFAULT_PGM_TAIL_IDLE_SPEED             ; E
                             EPROM copy of programmed tail idle speed
                             Eep_Pgm_Startup_Pwr:            DB      DEFAULT_PGM_TAIL_STARTUP_PWR            ; EEPROM co
                             py of programmed startup power
                             Eep_Pgm_Pwm_Freq:                       DB      DEFAULT_PGM_TAIL_PWM_FREQ               ; E
                             EPROM copy of programmed pwm frequency
                             Eep_Pgm_Direction:                      DB      DEFAULT_PGM_TAIL_DIRECTION              ; E
                             EPROM copy of programmed rotation direction
                             Eep_Pgm_Input_Pol:                      DB      DEFAULT_PGM_TAIL_RCP_PWM_POL            ; E
                             EPROM copy of programmed input polarity
                             Eep_Initialized_L:                      DB      05Ah                                       
                                          ; EEPROM initialized signature low byte
                             Eep_Initialized_H:                      DB      0A5h                                       
                                          ; EEPROM initialized signature high byte
                             Eep_Enable_TX_Program:          DB      DEFAULT_PGM_ENABLE_TX_PROGRAM           ; EEPROM TX
                              programming enable
                             _Eep_Main_Rearm_Start:          DB      0FFh                                               
                                  
                             _Eep_Pgm_Gov_Setup_Target:      DB      0FFh                                               
                                  
                             _Eep_Pgm_Startup_Rpm:           DB      0FFh
                             _Eep_Pgm_Startup_Accel:         DB      0FFh
                             _Eep_Pgm_Volt_Comp:                     DB      0FFh    
                             Eep_Pgm_Comm_Timing:            DB      DEFAULT_PGM_TAIL_COMM_TIMING            ; EEPROM co
                             py of programmed commutation timing
                             _Eep_Pgm_Damping_Force:         DB      0FFh
                             _Eep_Pgm_Gov_Range:                     DB      0FFh    
                             _Eep_Pgm_Startup_Method:                DB      0FFh
                             Eep_Pgm_Ppm_Min_Throttle:       DB      DEFAULT_PGM_PPM_MIN_THROTTLE            ; EEPROM co
                             py of programmed minimum throttle (final value is 4x+1000=1148)
                             Eep_Pgm_Ppm_Max_Throttle:       DB      DEFAULT_PGM_PPM_MAX_THROTTLE            ; EEPROM co
                             py of programmed minimum throttle (final value is 4x+1000=1832)
                             Eep_Pgm_Beep_Strength:          DB      DEFAULT_PGM_TAIL_BEEP_STRENGTH  ; EEPROM copy of pr
                             ogrammed beep strength
                             Eep_Pgm_Beacon_Strength:                DB      DEFAULT_PGM_TAIL_BEACON_STRENGTH        ; E
                             EPROM copy of programmed beacon strength
                             Eep_Pgm_Beacon_Delay:           DB      DEFAULT_PGM_TAIL_BEACON_DELAY           ; EEPROM co
                             py of programmed beacon delay
                             _Eep_Pgm_Throttle_Rate:         DB      0FFh
                             Eep_Pgm_Demag_Comp:                     DB      DEFAULT_PGM_TAIL_DEMAG_COMP             ; E
                             EPROM copy of programmed demag compensation
                             Eep_Pgm_BEC_Voltage_High:       DB      DEFAULT_PGM_BEC_VOLTAGE_HIGH            ; EEPROM co
                             py of programmed BEC voltage
                             Eep_Pgm_Ppm_Center_Throttle:    DB      DEFAULT_PGM_PPM_CENTER_THROTTLE ; EEPROM copy of pr
                             ogrammed center throttle (final value is 4x+1000=1488)
                             _Eep_Pgm_Main_Spoolup_Time:     DB      0FFh
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    85

                             Eep_Pgm_Temp_Prot_Enable:       DB      DEFAULT_PGM_ENABLE_TEMP_PROT            ; EEPROM co
                             py of programmed temperature protection enable
                             Eep_Pgm_Enable_Power_Prot:      DB      DEFAULT_PGM_ENABLE_POWER_PROT           ; EEPROM co
                             py of programmed low rpm power protection enable
                             Eep_Pgm_Enable_Pwm_Input:       DB      DEFAULT_PGM_ENABLE_PWM_INPUT            ; EEPROM co
                             py of programmed PWM input signal enable
                             Eep_Pgm_Pwm_Dither:                     DB      DEFAULT_PGM_TAIL_PWM_DITHER             ; E
                             EPROM copy of programmed output PWM dither
                             Eep_Pgm_Brake_On_Stop:          DB      DEFAULT_PGM_BRAKE_ON_STOP               ; EEPROM co
                             py of programmed braking when throttle is zero
                             ENDIF
                    5158     
                    5159     IF MODE == 2
                             Eep_Pgm_Gov_P_Gain:                     DB      DEFAULT_PGM_MULTI_P_GAIN                   
                                  ; EEPROM copy of programmed closed loop P gain
                             Eep_Pgm_Gov_I_Gain:                     DB      DEFAULT_PGM_MULTI_I_GAIN                   
                                  ; EEPROM copy of programmed closed loop I gain
                             Eep_Pgm_Gov_Mode:                       DB      DEFAULT_PGM_MULTI_GOVERNOR_MODE ; EEPROM co
                             py of programmed closed loop mode
                             _Eep_Pgm_Low_Voltage_Lim:       DB      0FFh                                               
                                  
                             Eep_Pgm_Motor_Gain:                     DB      DEFAULT_PGM_MULTI_GAIN                  ; E
                             EPROM copy of programmed tail gain
                             _Eep_Pgm_Motor_Idle:            DB      0FFh                                               
                                  ; EEPROM copy of programmed tail idle speed
                             Eep_Pgm_Startup_Pwr:            DB      DEFAULT_PGM_MULTI_STARTUP_PWR           ; EEPROM co
                             py of programmed startup power
                             Eep_Pgm_Pwm_Freq:                       DB      DEFAULT_PGM_MULTI_PWM_FREQ              ; E
                             EPROM copy of programmed pwm frequency
                             Eep_Pgm_Direction:                      DB      DEFAULT_PGM_MULTI_DIRECTION             ; E
                             EPROM copy of programmed rotation direction
                             Eep_Pgm_Input_Pol:                      DB      DEFAULT_PGM_MULTI_RCP_PWM_POL           ; E
                             EPROM copy of programmed input polarity
                             Eep_Initialized_L:                      DB      055h                                       
                                          ; EEPROM initialized signature low byte
                             Eep_Initialized_H:                      DB      0AAh                                       
                                          ; EEPROM initialized signature high byte
                             Eep_Enable_TX_Program:          DB      DEFAULT_PGM_ENABLE_TX_PROGRAM           ; EEPROM TX
                              programming enable
                             _Eep_Main_Rearm_Start:          DB      0FFh                                               
                                  
                             _Eep_Pgm_Gov_Setup_Target:      DB      0FFh                                               
                                  
                             _Eep_Pgm_Startup_Rpm:           DB      0FFh
                             _Eep_Pgm_Startup_Accel:         DB      0FFh
                             _Eep_Pgm_Volt_Comp:                     DB      0FFh    
                             Eep_Pgm_Comm_Timing:            DB      DEFAULT_PGM_MULTI_COMM_TIMING           ; EEPROM co
                             py of programmed commutation timing
                             _Eep_Pgm_Damping_Force:         DB      0FFh
                             _Eep_Pgm_Gov_Range:                     DB      0FFh    
                             _Eep_Pgm_Startup_Method:        DB      0FFh
                             Eep_Pgm_Ppm_Min_Throttle:       DB      DEFAULT_PGM_PPM_MIN_THROTTLE            ; EEPROM co
                             py of programmed minimum throttle (final value is 4x+1000=1148)
                             Eep_Pgm_Ppm_Max_Throttle:       DB      DEFAULT_PGM_PPM_MAX_THROTTLE            ; EEPROM co
                             py of programmed minimum throttle (final value is 4x+1000=1832)
                             Eep_Pgm_Beep_Strength:          DB      DEFAULT_PGM_MULTI_BEEP_STRENGTH ; EEPROM copy of pr
                             ogrammed beep strength
                             Eep_Pgm_Beacon_Strength:        DB      DEFAULT_PGM_MULTI_BEACON_STRENGTH       ; EEPROM co
                             py of programmed beacon strength
                             Eep_Pgm_Beacon_Delay:           DB      DEFAULT_PGM_MULTI_BEACON_DELAY  ; EEPROM copy of pr
                             ogrammed beacon delay
                             _Eep_Pgm_Throttle_Rate:         DB      0FFh
                             Eep_Pgm_Demag_Comp:                     DB      DEFAULT_PGM_MULTI_DEMAG_COMP            ; E
                             EPROM copy of programmed demag compensation
                             Eep_Pgm_BEC_Voltage_High:       DB      DEFAULT_PGM_BEC_VOLTAGE_HIGH            ; EEPROM co
                             py of programmed BEC voltage
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    86

                             Eep_Pgm_Ppm_Center_Throttle:DB  DEFAULT_PGM_PPM_CENTER_THROTTLE ; EEPROM copy of programmed
                              center throttle (final value is 4x+1000=1488)
                             _Eep_Pgm_Main_Spoolup_Time:     DB      0FFh
                             Eep_Pgm_Temp_Prot_Enable:       DB      DEFAULT_PGM_ENABLE_TEMP_PROT            ; EEPROM co
                             py of programmed temperature protection enable
                             Eep_Pgm_Enable_Power_Prot:      DB      DEFAULT_PGM_ENABLE_POWER_PROT           ; EEPROM co
                             py of programmed low rpm power protection enable
                             Eep_Pgm_Enable_Pwm_Input:       DB      DEFAULT_PGM_ENABLE_PWM_INPUT            ; EEPROM co
                             py of programmed PWM input signal enable
                             Eep_Pgm_Pwm_Dither:                     DB      DEFAULT_PGM_MULTI_PWM_DITHER            ; E
                             EPROM copy of programmed output PWM dither
                             Eep_Pgm_Brake_On_Stop:          DB      DEFAULT_PGM_BRAKE_ON_STOP               ; EEPROM co
                             py of programmed braking when throttle is zero
                             ENDIF
                    5198     
1A28 FF             5199     Eep_Dummy:                                      DB      0FFh                               
                                                  ; EEPROM address for safety reason
                    5200     
----                5201     CSEG AT 1A60h
1A60 20202020       5202     Eep_Name:                                       DB      "                "                 
                                          ; Name tag (16 Bytes)
1A64 20202020                
1A68 20202020                
1A6C 20202020                
                    5203     
                    5204     ;**** **** **** **** ****
                    5205                     Interrupt_Table_Definition              ; SiLabs interrupts
----                5216     CSEG AT 80h                     ; Code segment after interrupt vectors 
                    5217     
                    5218     ;**** **** **** **** ****
                    5219     
                    5220     ; Table definitions
0080 02030406       5221     GOV_GAIN_TABLE:                         DB      02h, 03h, 04h, 06h, 08h, 0Ch, 10h, 18h, 20h
                             , 30h, 40h, 60h, 80h
0084 080C1018                
0088 20304060                
008C 80                      
008D 0406080C       5222     STARTUP_POWER_TABLE:            DB      04h, 06h, 08h, 0Ch, 10h, 18h, 20h, 30h, 40h, 60h, 8
                             0h, 0A0h, 0C0h
0091 10182030                
0095 406080A0                
0099 C0                      
009A 0003070F       5223     PWM_DITHER_TABLE:                       DB      00h, 03h, 07h, 0Fh, 1Fh
009E 1F                      
                    5224     IF MODE == 0
                    5225       IF DAMPED_MODE_ENABLE == 1
009F 0D0D0403       5226             TX_PGM_PARAMS_MAIN:     DB      13, 13, 4, 3, 6, 13, 5, 3, 3, 2, 2
00A3 060D0503                
00A7 030202                  
                    5227       ENDIF
                    5228       IF DAMPED_MODE_ENABLE == 0
                                     TX_PGM_PARAMS_MAIN:     DB      13, 13, 4, 3, 6, 13, 5, 2, 3, 2, 2
                               ENDIF
                    5231     ENDIF
                    5232     IF MODE == 1
                               IF DAMPED_MODE_ENABLE == 1
                             TX_PGM_PARAMS_TAIL:             DB      5, 5, 13, 5, 3, 5, 3, 3, 2
                               ENDIF
                               IF DAMPED_MODE_ENABLE == 0
                             TX_PGM_PARAMS_TAIL:             DB      5, 5, 13, 5, 2, 5, 3, 3, 2
                               ENDIF
                             ENDIF
                    5240     IF MODE == 2
                               IF DAMPED_MODE_ENABLE == 1
                             TX_PGM_PARAMS_MULTI:            DB      13, 13, 4, 5, 13, 5, 3, 5, 3, 3, 2
                               ENDIF
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    87

                               IF DAMPED_MODE_ENABLE == 0
                             TX_PGM_PARAMS_MULTI:            DB      13, 13, 4, 5, 13, 5, 2, 5, 3, 3, 2
                               ENDIF 
                             ENDIF
                    5248     
                    5249     
                    5250     
                    5251     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    5252     ;
                    5253     ; Timer0 interrupt routine
                    5254     ;
                    5255     ; Assumptions: DPTR register must be set to desired pwm_nfet_on label
                    5256     ; Requirements: Temp variables can NOT be used since PSW.3 is not set
                    5257     ;
                    5258     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
00AA                5259     t0_int: ; Used for pwm control
00AA C2AF           5260             clr     EA                      ; Disable all interrupts
                    5261     IF MCU_48MHZ == 1
                                     ; Check overflow flag
                                     jnb     Flags0.PWM_TIMER0_OVERFLOW, t0_int_start; Execute this interrupt
                             
                                     clr     Flags0.PWM_TIMER0_OVERFLOW
                                     mov     TL0, Timer0_Overflow_Value      ; Set timer 
                                     setb    EA                      ; Enable all interrupts
                                     reti
                             
                             t0_int_start:
                             ENDIF
00AC C0D0           5272             push    PSW                     ; Preserve registers through interrupt
00AE C0E0           5273             push    ACC             
                    5274             ; Check if pwm is on
00B0 206214         5275             jb      Flags0.PWM_ON, t0_int_pwm_off   ; Is pwm on?
                    5276     
                    5277             ; Pwm on cycle
00B3 E525           5278             mov     A, Current_Pwm_Limited
00B5 6009           5279             jz      t0_int_pwm_on_ret
                    5280     
00B7 E4             5281             clr     A                                       
00B8 73             5282             jmp     @A+DPTR                                 ; Jump to pwm on routines. DPTR sho
                             uld be set to one of the pwm_nfet_on labels
                    5283     
00B9                5284     t0_int_pwm_on_exit:
                    5285             ; Set timer for coming on cycle length
00B9 E525           5286             mov     A, Current_Pwm_Limited          ; Load current pwm
00BB F4             5287             cpl     A                                               ; cpl is 255-x
                    5288     IF MCU_48MHZ == 0
00BC F58A           5289             mov     TL0, A                                  ; Write start point for timer
                    5290     ELSE
                                     clr     C
                                     rlc     A
                                     jc      t0_int_pwm_on_set_timer
                             
                                     mov     TL0, #0
                                     setb    Flags0.PWM_TIMER0_OVERFLOW
                                     mov     Timer0_Overflow_Value, A
                                     ajmp    t0_int_pwm_on_timer_set
                             
                             t0_int_pwm_on_set_timer:
                                     mov     TL0, A
                             t0_int_pwm_on_timer_set:
                             ENDIF
                    5304             ; Set other variables
00BE D262           5305             setb    Flags0.PWM_ON                           ; Set pwm on flag
00C0                5306     t0_int_pwm_on_ret:
                    5307             ; Exit interrupt
00C0 D0E0           5308             pop     ACC                     ; Restore preserved registers
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    88

00C2 D0D0           5309             pop     PSW
00C4 D2AF           5310             setb    EA                      ; Enable all interrupts
00C6 32             5311             reti
                    5312     
                    5313     
                    5314             ; Pwm off cycle
00C7                5315     t0_int_pwm_off:
                    5316     IF MCU_48MHZ == 0
00C7 85268A         5317             mov     TL0, Current_Pwm_Lim_Dith       ; Load new timer setting
                    5318     ELSE
                                     clr     C
                                     mov     A, Current_Pwm_Lim_Dith
                                     rlc     A
                                     jc      t0_int_pwm_off_set_timer 
                             
                                     mov     TL0, #0
                                     setb    Flags0.PWM_TIMER0_OVERFLOW
                                     mov     Timer0_Overflow_Value, A
                                     ajmp    t0_int_pwm_off_timer_set
                             
                             t0_int_pwm_off_set_timer:
                                     mov     TL0, A
                             t0_int_pwm_off_timer_set:
                             ENDIF
                    5333             ; Clear pwm on flag
00CA C262           5334             clr     Flags0.PWM_ON   
                    5335             ; Set full PWM (on all the time) if current PWM near max. This will give full power
                             , but at the cost of a small "jump" in power
00CC E526           5336             mov     A, Current_Pwm_Lim_Dith         ; Load current pwm
00CE F4             5337             cpl     A                                               ; Full pwm?
00CF 6030           5338             jz      t0_int_pwm_off_fullpower_exit   ; Yes - exit
                    5339     
                    5340     IF DAMPED_MODE_ENABLE == 1
                    5341             ; Do not execute pwm off when stopped
00D1 306826         5342             jnb     Flags1.MOTOR_SPINNING, t0_int_pwm_off_exit
                    5343     
                    5344             ; If damped operation, set pFETs on in pwm_off
00D4 20720D         5345             jb      Flags2.PGM_PWMOFF_DAMPED, t0_int_pwm_off_damped ; Damped operation?
                    5346     ENDIF
                    5347     
00D7                5348     t0_int_pwm_off_exit_nfets_off:  
                    5349             ; Separate exit commands here for minimum delay
                    5350     IF NFETON_DELAY == 0
                                     En_Off                  ; For EN/PWM style drivers. Uses accumulator
                             ENDIF
00D7 D0E0           5353             pop     ACC                     ; Restore preserved registers
00D9 D0D0           5354             pop     PSW
                    5355     IF NFETON_DELAY NE 0
                    5356             All_nFETs_Off           ; Switch off all nfets
                    5360     ENDIF
00E1 D2AF           5361             setb    EA                      ; Enable all interrupts
00E3 32             5362             reti
                    5363     
00E4                5364     t0_int_pwm_off_damped:
                    5365     IF PFETON_DELAY < 128
                    5366     IF PFETON_DELAY NE 0
                    5367             All_nFETs_Off                           ; Switch off all nfets
                    5371     ELSE
                                     En_Off
                             ENDIF
00EA 206F0D         5374             jb      Flags1.SKIP_DAMP_ON, t0_int_pwm_off_damp_done 
00ED 20650A         5375             jb      Flags0.DEMAG_CUT_POWER, t0_int_pwm_off_damp_done 
                    5376     IF PFETON_DELAY NE 0
00F0 7401           5377             mov     A, #PFETON_DELAY
00F2 D5E0FD         5378             djnz    ACC, $  
                    5379     ENDIF
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    89

                    5380             Damping_FET_on
00FA                5384     t0_int_pwm_off_damp_done:
                    5385     ENDIF
                    5386     IF PFETON_DELAY >= 128                  ; "Negative", 1's complement
                                     jb      Flags1.SKIP_DAMP_ON, t0_int_pwm_off_damp_done
                                     jb      Flags0.DEMAG_CUT_POWER, t0_int_pwm_off_damp_done 
                                     Damping_FET_on                          ; Damping fet on
                                     mov     A, #PFETON_DELAY
                                     cpl     A
                                     djnz    ACC, $  
                             t0_int_pwm_off_damp_done:
                                     All_nFETs_Off                           ; Switch off all nfets
                             ENDIF
00FA                5396     t0_int_pwm_off_exit:    
00FA D0E0           5397             pop     ACC                     ; Restore preserved registers
00FC D0D0           5398             pop     PSW
00FE D2AF           5399             setb    EA                      ; Enable all interrupts
0100 32             5400             reti
                    5401     
0101                5402     t0_int_pwm_off_fullpower_exit: 
0101 758A00         5403             mov     TL0, #0         ; Set long time till next interrupt
                    5404     IF MCU_48MHZ == 1
                                     setb    Flags0.PWM_TIMER0_OVERFLOW
                                     mov     Timer0_Overflow_Value, #0
                             ENDIF
0104 C28D           5408             clr     TF0                     ; Clear interrupt flag
0106 D262           5409             setb    Flags0.PWM_ON   
0108 01FA           5410             ajmp    t0_int_pwm_off_exit
                    5411     
                    5412     
010A                5413     pwm_nofet:      ; Dummy pwm on cycle
010A 01B9           5414             ajmp    t0_int_pwm_on_exit
                    5415     
010C                5416     pwm_afet:               ; Pwm on cycle afet on
010C 306805         5417             jnb     Flags1.MOTOR_SPINNING, pwm_afet_exit
010F 206502         5418             jb      Flags0.DEMAG_CUT_POWER, pwm_afet_exit 
                    5419             AnFET_on        
0114                5421     pwm_afet_exit:
0114 01B9           5422             ajmp    t0_int_pwm_on_exit
                    5423     
0116                5424     pwm_bfet:               ; Pwm on cycle bfet on
0116 306805         5425             jnb     Flags1.MOTOR_SPINNING, pwm_bfet_exit
0119 206502         5426             jb      Flags0.DEMAG_CUT_POWER, pwm_bfet_exit 
                    5427             BnFET_on
011E                5429     pwm_bfet_exit:
011E 01B9           5430             ajmp    t0_int_pwm_on_exit
                    5431     
0120                5432     pwm_cfet:               ; Pwm on cycle cfet on
0120 306805         5433             jnb     Flags1.MOTOR_SPINNING, pwm_cfet_exit
0123 206502         5434             jb      Flags0.DEMAG_CUT_POWER, pwm_cfet_exit 
                    5435             CnFET_on
0128                5437     pwm_cfet_exit:
0128 01B9           5438             ajmp    t0_int_pwm_on_exit
                    5439     
012A                5440     pwm_afet_damped:        
                    5441     IF NFETON_DELAY NE 0
                    5442             ApFET_off
                    5444     ENDIF
012C 30680A         5445             jnb     Flags1.MOTOR_SPINNING, pwm_afet_damped_exit
012F 206507         5446             jb      Flags0.DEMAG_CUT_POWER, pwm_afet_damped_exit 
                    5447     IF NFETON_DELAY NE 0
0132 7406           5448             mov     A, #NFETON_DELAY                                        ; Set delay
0134 D5E0FD         5449             djnz ACC,       $
                    5450     ENDIF
0137                5451     pwm_afet_damped_done:
                    5452             AnFET_on                                                                ; Switch nF
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    90

                             ET
0139                5454     pwm_afet_damped_exit:
0139 01B9           5455             ajmp    t0_int_pwm_on_exit
                    5456     
013B                5457     pwm_bfet_damped:
                    5458     IF NFETON_DELAY NE 0
                    5459             BpFET_off
                    5461     ENDIF
013D 30680A         5462             jnb     Flags1.MOTOR_SPINNING, pwm_bfet_damped_exit
0140 206507         5463             jb      Flags0.DEMAG_CUT_POWER, pwm_bfet_damped_exit 
                    5464     IF NFETON_DELAY NE 0
0143 7406           5465             mov     A, #NFETON_DELAY                                        ; Set delay
0145 D5E0FD         5466             djnz ACC,       $
                    5467     ENDIF
0148                5468     pwm_bfet_damped_done:
                    5469             BnFET_on                                                                ; Switch nF
                             ET
014A                5471     pwm_bfet_damped_exit:
014A 01B9           5472             ajmp    t0_int_pwm_on_exit
                    5473     
014C                5474     pwm_cfet_damped:        
                    5475     IF NFETON_DELAY NE 0
                    5476             CpFET_off
                    5478     ENDIF
014E 30680A         5479             jnb     Flags1.MOTOR_SPINNING, pwm_cfet_damped_exit
0151 206507         5480             jb      Flags0.DEMAG_CUT_POWER, pwm_cfet_damped_exit 
                    5481     IF NFETON_DELAY NE 0
0154 7406           5482             mov     A, #NFETON_DELAY                                        ; Set delay
0156 D5E0FD         5483             djnz ACC,       $
                    5484     ENDIF
0159                5485     pwm_cfet_damped_done:
                    5486             CnFET_on                                                                ; Switch nF
                             ET
015B                5488     pwm_cfet_damped_exit: 
015B 01B9           5489             ajmp    t0_int_pwm_on_exit
                    5490     
                    5491     
                    5492     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    5493     ;
                    5494     ; Timer2 interrupt routine
                    5495     ;
                    5496     ; No assumptions
                    5497     ;
                    5498     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
015D                5499     t2_int: ; Happens every 128us for low byte and every 32ms for high byte
015D C2AF           5500             clr     EA
015F C2AD           5501             clr     ET2                     ; Disable timer2 interrupts
0161 53E6EF         5502             anl     EIE1, #0EFh     ; Disable PCA0 interrupts
0164 C0D0           5503             push    PSW                     ; Preserve registers through interrupt
0166 C0E0           5504             push    ACC
0168 D2D3           5505             setb    PSW.3           ; Select register bank 1 for interrupt routines
016A D2AF           5506             setb    EA
                    5507     IF MCU_48MHZ == 1
                                     mov     A, Clock_Set_At_48MHz
                                     jz      t2_int_start
                             
                                     ; Check skip variable
                                     mov     A, Skip_T2_Int
                                     jz      t2_int_start                            ; Execute this interrupt
                             
                                     mov     Skip_T2_Int, #0
                                     ajmp    t2_int_exit
                             
                             t2_int_start:
                                     mov     Skip_T2_Int, #1                 ; Skip next interrupt
                             ENDIF
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    91

                    5521             ; Clear low byte interrupt flag
016C C2CE           5522             clr     TF2L                                            ; Clear interrupt flag
                    5523             ; Check RC pulse timeout counter
016E E52A           5524             mov     A, Rcp_Timeout_Cntd                     ; RC pulse timeout count zero?
0170 6007           5525             jz      t2_int_pulses_absent            ; Yes - pulses are absent
                    5526     
                    5527             ; Decrement timeout counter (if PWM)
0172 20744F         5528             jb      Flags2.RCP_PPM, t2_int_skip_start       ; If flag is set (PPM) - branch
                    5529     
0175 152A           5530             dec     Rcp_Timeout_Cntd                        ; No - decrement
0177 21C4           5531             ajmp    t2_int_skip_start
                    5532     
0179                5533     t2_int_pulses_absent:
                    5534             ; Timeout counter has reached zero, pulses are absent
0179 7800           5535             mov     Temp1, #RCP_MIN                 ; RCP_MIN as default
017B 7900           5536             mov     Temp2, #RCP_MIN                 
017D 20742E         5537             jb      Flags2.RCP_PPM, t2_int_pulses_absent_no_max     ; If flag is set (PPM) - br
                             anch
                    5538     
                    5539             Read_Rcp_Int                                    ; Look at value of Rcp_In
0186 30E502         5543             jnb     ACC.Rcp_In, ($+5)                       ; Is it high?
0189 78FF           5544             mov     Temp1, #RCP_MAX                 ; Yes - set RCP_MAX
                    5545             Rcp_Int_First                                   ; Set interrupt trig to first again
                    5551             Rcp_Clear_Int_Flag                              ; Clear interrupt flag
019C C271           5553             clr     Flags2.RCP_EDGE_NO                      ; Set first edge flag
                    5554             Read_Rcp_Int                                    ; Look once more at value of Rcp_In
01A4 30E502         5558             jnb     ACC.Rcp_In, ($+5)                       ; Is it high?
01A7 79FF           5559             mov     Temp2, #RCP_MAX                 ; Yes - set RCP_MAX
01A9 C3             5560             clr     C
01AA E8             5561             mov     A, Temp1
01AB 99             5562             subb    A, Temp2                                        ; Compare the two readings 
                             of Rcp_In
01AC 70CB           5563             jnz     t2_int_pulses_absent            ; Go back if they are not equal
                    5564     
01AE                5565     t2_int_pulses_absent_no_max:
01AE 306103         5566             jnb     Flags0.RCP_MEAS_PWM_FREQ, ($+6) ; Is measure RCP pwm frequency flag set?
                    5567     
01B1 752A40         5568             mov     Rcp_Timeout_Cntd, #RCP_TIMEOUT  ; Yes - set timeout count to start value
                    5569     
01B4 207403         5570             jb      Flags2.RCP_PPM, t2_int_ppm_timeout_set  ; If flag is set (PPM) - branch
                    5571     
01B7 752A40         5572             mov     Rcp_Timeout_Cntd, #RCP_TIMEOUT  ; For PWM, set timeout count to start value
                    5573     
01BA                5574     t2_int_ppm_timeout_set:
01BA 885C           5575             mov     New_Rcp, Temp1                          ; Store new pulse length
01BC D270           5576             setb    Flags2.RCP_UPDATED                      ; Set updated flag
                    5577             ; Check if zero
01BE E8             5578             mov     A, Temp1                                        ; Load new pulse value
01BF 6003           5579             jz      ($+5)                                   ; Check if pulse is zero
                    5580     
01C1 755F00         5581             mov     Rcp_Stop_Cnt, #0                        ; Reset rcp stop counter
                    5582     
01C4                5583     t2_int_skip_start:
01C4 20740D         5584             jb      Flags2.RCP_PPM, t2_int_rcp_update_start ; If flag is set (PPM) - branch
                    5585     
                    5586             ; Check RC pulse skip counter
01C7 E52B           5587             mov     A, Rcp_Skip_Cntd                        
01C9 6004           5588             jz      t2_int_skip_end                 ; If RC pulse skip count is zero - end skip
                             ping RC pulse detection
                    5589             
                    5590             ; Decrement skip counter (only if edge counter is zero)
01CB 152B           5591             dec     Rcp_Skip_Cntd                           ; Decrement
01CD 21D4           5592             ajmp    t2_int_rcp_update_start
                    5593     
01CF                5594     t2_int_skip_end:
                    5595             ; Skip counter has reached zero, start looking for RC pulses again
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    92

                    5596             Rcp_Int_Enable                          ; Enable RC pulse interrupt
                    5598             Rcp_Clear_Int_Flag                              ; Clear interrupt flag
                    5600             
01D4                5601     t2_int_rcp_update_start:
                    5602             ; Process updated RC pulse
01D4 207002         5603             jb      Flags2.RCP_UPDATED, ($+5)       ; Is there an updated RC pulse available?
01D7 21E7           5604             ajmp    t2_int_current_pwm_update       ; No - update pwm limits and exit
                    5605     
01D9 A85C           5606             mov     Temp1, New_Rcp                          ; Load new pulse value
01DB 206102         5607             jb      Flags0.RCP_MEAS_PWM_FREQ, ($+5) ; If measure RCP pwm frequency flag set - d
                             o not clear flag
                    5608     
01DE C270           5609             clr     Flags2.RCP_UPDATED                      ; Flag that pulse has been evaluated
                    5610     
                    5611             ; Use a gain of 1.0625x for pwm input if not governor mode
01E0 207402         5612             jb      Flags2.RCP_PPM, t2_int_pwm_min_run      ; If flag is set (PPM) - branch
                    5613     
                    5614     IF MODE == 0    ; Main - do not adjust gain
01E3 21E5           5615             ajmp    t2_int_pwm_min_run
                    5616     ELSE
                             
                             IF MODE == 2    ; Multi 
                                     mov     Temp2, #Pgm_Gov_Mode            ; Closed loop mode?
                                     cjne    @Temp2, #4, t2_int_pwm_min_run; Yes - branch
                             ENDIF
                             
                                     ; Limit the maximum value to avoid wrap when scaled to pwm range
                                     clr     C
                                     mov     A, Temp1
                                     subb    A, #240                 ; 240 = (255/1.0625) Needs to be updated according 
                             to multiplication factor below               
                                     jc      t2_int_rcp_update_mult
                             
                                     mov     A, #240                 ; Set requested pwm to max
                                     mov     Temp1, A                
                             
                             t2_int_rcp_update_mult: 
                                     ; Multiply by 1.0625 (optional adjustment gyro gain)
                                     mov     A, Temp1
                                     swap    A                       ; After this "0.0625"
                                     anl     A, #0Fh
                                     add     A, Temp1
                                     mov     Temp1, A                
                                     ; Adjust tail gain
                                     mov     Temp2, #Pgm_Motor_Gain
                                     cjne    @Temp2, #3, ($+5)                       ; Is gain 1?
                                     ajmp    t2_int_pwm_min_run                      ; Yes - skip adjustment
                             
                                     clr     C
                                     rrc     A                       ; After this "0.5"
                                     clr     C
                                     rrc     A                       ; After this "0.25"
                                     mov     Bit_Access_Int, @Temp2                          ; (Temp2 has #Pgm_Motor_Gai
                             n)
                                     jb      Bit_Access_Int.0, t2_int_rcp_gain_corr  ; Branch if bit 0 in gain is set
                             
                                     clr     C
                                     rrc     A                       ; After this "0.125"
                             
                             t2_int_rcp_gain_corr:
                                     jb      Bit_Access_Int.2, t2_int_rcp_gain_pos   ; Branch if bit 2 in gain is set
                             
                                     clr     C
                                     xch     A, Temp1
                                     subb    A, Temp1                                        ; Apply negative correction
                                     mov     Temp1, A
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    93

                                     ajmp    t2_int_pwm_min_run
                             
                             t2_int_rcp_gain_pos:
                                     add     A, Temp1                                        ; Apply positive correction
                                     mov     Temp1, A
                                     jnc     t2_int_pwm_min_run                      ; Above max?
                             
                                     mov     A, #0FFh                                        ; Yes - limit
                                     mov     Temp1, A
                             ENDIF
                    5671     
01E5                5672     t2_int_pwm_min_run: 
                    5673     IF MODE == 1    ; Tail - limit minimum pwm
                                     ; Limit minimum pwm
                                     clr     C
                                     mov     A, Temp1
                                     subb    A, Pwm_Motor_Idle                       ; Is requested pwm lower than minim
                             um?
                                     jnc     t2_int_pwm_update                       ; No - branch
                             
                                     mov     A, Pwm_Motor_Idle                       ; Yes - limit pwm to Pwm_Motor_Idle
                                  
                                     mov     Temp1, A
                             ENDIF
                    5683     
01E5                5684     t2_int_pwm_update: 
                    5685             ; Update requested_pwm
01E5 8822           5686             mov     Requested_Pwm, Temp1            ; Set requested pwm
                    5687     IF MODE >= 1    ; Tail or multi
                                     ; Boost pwm during direct start
                                     mov     A, Flags1
                                     anl     A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
                                     jz      t2_int_current_pwm_update
                             
                                     jb      Flags1.MOTOR_STARTED, t2_int_current_pwm_update ; Do not boost when changin
                             g direction in bidirectional mode
                             
                                     mov     A, Stall_Cnt                            ; Add an extra power boost for each
                              attempt
                                     clr     C
                                     rlc     A
                                     clr     C
                                     rlc     A
                                     mov     Temp1, A
                                     mov     A, Pwm_Spoolup_Beg                      ; Set 25% of max startup power as m
                             inimum power
                                     clr     C
                                     rrc     A
                                     clr     C
                                     rrc     A
                                     mov     Temp2, A
                                     clr     C
                                     subb    A, Requested_Pwm
                                     jc      ($+4)
                             
                                     mov     Requested_Pwm, Temp2
                             
                                     mov     A, Temp1
                                     add     A, Requested_Pwm                        
                                     mov     Requested_Pwm, A
                                     jnc     ($+5)
                             
                                     mov     Requested_Pwm, #0FFh
                             
                             ENDIF
01E7                5721     t2_int_current_pwm_update: 
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    94

                    5722     IF MODE == 0 OR MODE == 2       ; Main or multi
01E7 7882           5723             mov     Temp1, #Pgm_Gov_Mode            ; Governor mode?
01E9 B60403         5724             cjne    @Temp1, #4, t2_int_exit         ; Yes - branch
                    5725     ENDIF
                    5726     
01EC 852224         5727             mov     Current_Pwm, Requested_Pwm      ; Set equal as default
                    5728     IF MODE >= 1    ; Tail or multi
                                     ; Set current_pwm_limited
                                     mov     Temp1, Current_Pwm                      ; Default not limited
                                     clr     C
                                     mov     A, Current_Pwm                          ; Check against limit
                                     subb    A, Pwm_Limit
                                     jc      ($+4)                                   ; If current pwm below limit - bran
                             ch
                             
                                     mov     Temp1, Pwm_Limit                        ; Limit pwm
                             
                             IF MODE == 2    ; Multi
                                     ; Limit pwm for low rpms
                                     clr     C
                                     mov     A, Temp1                                        ; Check against limit
                                     subb    A, Pwm_Limit_By_Rpm
                                     jc      ($+4)                                   ; If current pwm below limit - bran
                             ch
                             
                                     mov     Temp1, Pwm_Limit_By_Rpm         ; Limit pwm
                             
                             ENDIF
                                     mov     Current_Pwm_Limited, Temp1
                                     ; Dither
                                     mov     A, Pwm_Dither_Decoded           ; Load pwm dither
                                     jnz     ($+4)                                   ; If active - branch
                                     ajmp    t2_int_current_pwm_no_dither
                             
                                     clr     C
                                     mov     A, Temp1
                                     mov     Temp3, Pwm_Dither_Decoded                               
                                     subb    A, Temp3                                        ; Calculate pwm minus dithe
                             r value
                                     jnc     t2_int_current_pwm_full_dither; If pwm more than dither value, then do full
                              dither
                             
                                     mov     A, Temp1                                        ; Set dither level to curre
                             nt pwm
                                     mov     Temp3, A                                
                                     clr     A                                               ; Set pwm minus dither
                             
                             t2_int_current_pwm_full_dither:
                                     mov     Temp2, A                                        ; Load pwm minus dither val
                             ue
                                     mov     A, Temp3                                        ; Load dither   
                                     clr     C
                                     rlc     A                                               ; Shift left once
                                     mov     Temp4, A
                                     mov     A, Random                                       ; Load random number
                                     cpl     A                                               ; Invert to create proper D
                             C bias in random code
                                     anl     A, Temp4                                        ; And with double dither va
                             lue
                                     add     A, Temp2                                        ; Add pwm minus dither
                                     jc      t2_int_current_pwm_dither_max_excess_power      ; If dither cause power abo
                             ve max - branch and increase excess 
                             
                                     add     A, Pwm_Dither_Excess_Power      ; Add excess power from previous cycles
                                     mov     Temp1, A
                                     mov     A, Pwm_Dither_Excess_Power      ; Decrement excess power
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    95

                                     jz      ($+4)
                                     dec     Pwm_Dither_Excess_Power
                                     jc      t2_int_current_pwm_dither_max_power; If dither cause power above max - bran
                             ch
                             
                                     ajmp    t2_int_current_pwm_no_dither
                             
                             t2_int_current_pwm_dither_max_excess_power:
                                     inc     Temp3                                   ; Add one to dither in order to alw
                             ays reach max power
                                     clr     C
                                     mov     A, Pwm_Dither_Excess_Power
                                     subb    A, Temp3                                        ; Limit excess power 
                                     jnc     ($+4)
                                     inc     Pwm_Dither_Excess_Power
                             
                             t2_int_current_pwm_dither_max_power:
                                     mov     Temp1, #255                             ; Set power to max
                             
                             t2_int_current_pwm_no_dither:
                                     mov     Current_Pwm_Lim_Dith, Temp1
                             IF DAMPED_MODE_ENABLE == 1
                                     ; Skip damping fet switching for high throttle
                                     clr     Flags1.SKIP_DAMP_ON
                                     clr     C
                                     mov     A, Current_Pwm_Lim_Dith
                                     subb    A, #248
                                     jc      t2_int_exit
                                     setb    Flags1.SKIP_DAMP_ON
                             ENDIF
                             ENDIF
01EF                5808     t2_int_exit:    
                    5809             ; Check if high byte flag is set
01EF 20CF0A         5810             jb      TF2H, t2h_int           
01F2 D0E0           5811             pop     ACC                     ; Restore preserved registers
01F4 D0D0           5812             pop     PSW
01F6 43E610         5813             orl     EIE1, #10h      ; Enable PCA0 interrupts
01F9 D2AD           5814             setb    ET2                     ; Enable timer2 interrupts
01FB 32             5815             reti
                    5816     
01FC                5817     t2h_int:
                    5818             ; High byte interrupt (happens every 32ms)
01FC C2CF           5819             clr     TF2H                                    ; Clear interrupt flag
01FE 053A           5820             inc     Timer2_X
                    5821     IF MCU_48MHZ == 1
                                     mov     A, Clock_Set_At_48MHz
                                     jz      t2h_int_start
                             
                                     ; Check skip variable
                                     mov     A, Skip_T2h_Int
                                     jz      t2h_int_start                           ; Execute this interrupt
                             
                                     mov     Skip_T2h_Int, #0
                                     ajmp    t2h_int_exit
                             
                             t2h_int_start:
                                     mov     Skip_T2h_Int, #1                        ; Skip next interrupt
                             ENDIF
0200 7802           5835             mov     Temp1, #GOV_SPOOLRATE   ; Load governor spool rate
                    5836             ; Check RC pulse timeout counter (used here for PPM only)
0202 E52A           5837             mov     A, Rcp_Timeout_Cntd                     ; RC pulse timeout count zero?
0204 6005           5838             jz      t2h_int_rcp_stop_check          ; Yes - do not decrement
                    5839     
                    5840             ; Decrement timeout counter (if PPM)
0206 307402         5841             jnb     Flags2.RCP_PPM, t2h_int_rcp_stop_check  ; If flag is not set (PWM) - branch
                    5842     
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    96

0209 152A           5843             dec     Rcp_Timeout_Cntd                        ; No flag set (PPM) - decrement
                    5844     
020B                5845     t2h_int_rcp_stop_check:
                    5846             ; Check RC pulse against stop value
020B C3             5847             clr     C
020C E55C           5848             mov     A, New_Rcp                              ; Load new pulse value
020E 9401           5849             subb    A, #RCP_STOP                            ; Check if pulse is below stop value
0210 4005           5850             jc      t2h_int_rcp_stop
                    5851     
                    5852             ; RC pulse higher than stop value, reset stop counter
0212 755F00         5853             mov     Rcp_Stop_Cnt, #0                        ; Reset rcp stop counter
0215 4128           5854             ajmp    t2h_int_rcp_gov_pwm
                    5855     
0217                5856     t2h_int_rcp_stop:       
                    5857             ; RC pulse less than stop value
0217 756000         5858             mov     Auto_Bailout_Armed, #0          ; Disarm bailout                
021A 756900         5859             mov     Spoolup_Limit_Cnt, #0
021D E55F           5860             mov     A, Rcp_Stop_Cnt                 ; Increment stop counter
021F 2401           5861             add     A, #1
0221 F55F           5862             mov     Rcp_Stop_Cnt, A
0223 5003           5863             jnc     t2h_int_rcp_gov_pwm                     ; Branch if counter has not wrapped
                    5864     
0225 755FFF         5865             mov     Rcp_Stop_Cnt, #0FFh                     ; Set stop counter to max
                    5866     
0228                5867     t2h_int_rcp_gov_pwm:
                    5868     IF MODE == 0    ; Main
                    5869             ; Update governor variables
0228 7982           5870             mov     Temp2, #Pgm_Gov_Mode                    ; Governor target by arm mode?
022A B7020D         5871             cjne    @Temp2, #2, t2h_int_rcp_gov_by_setup    ; No - branch
                    5872     
022D 306E1D         5873             jnb     Flags1.GOV_ACTIVE, t2h_int_rcp_gov_by_tx; If governor not active - branch (
                             this ensures soft spoolup by tx)
                    5874     
0230 C3             5875             clr     C
0231 E522           5876             mov     A, Requested_Pwm
0233 9432           5877             subb    A, #50                                          ; Is requested pwm below 20
                             %?
0235 4016           5878             jc      t2h_int_rcp_gov_by_tx                   ; Yes - branch (this enables a soft
                              spooldown)
                    5879     
0237 854C22         5880             mov     Requested_Pwm, Gov_Arm_Target           ; Yes - load arm target
                    5881     
023A                5882     t2h_int_rcp_gov_by_setup:
023A 7982           5883             mov     Temp2, #Pgm_Gov_Mode                    ; Governor target by setup mode?
023C B7030E         5884             cjne    @Temp2, #3, t2h_int_rcp_gov_by_tx               ; No - branch
                    5885     
023F 306E0B         5886             jnb     Flags1.GOV_ACTIVE, t2h_int_rcp_gov_by_tx; If governor not active - branch (
                             this ensures soft spoolup by tx)
                    5887     
0242 C3             5888             clr     C
0243 E522           5889             mov     A, Requested_Pwm
0245 9432           5890             subb    A, #50                                          ; Is requested pwm below 20
                             %?
0247 4004           5891             jc      t2h_int_rcp_gov_by_tx                   ; Yes - branch (this enables a soft
                              spooldown)
                    5892     
0249 798E           5893             mov     Temp2, #Pgm_Gov_Setup_Target            ; Gov by setup - load setup target
024B 8722           5894             mov     Requested_Pwm, @Temp2
                    5895     
024D                5896     t2h_int_rcp_gov_by_tx:
024D C3             5897             clr     C
024E E523           5898             mov     A, Governor_Req_Pwm
0250 9522           5899             subb    A, Requested_Pwm                                ; Is governor requested pwm
                              equal to requested pwm?
0252 6008           5900             jz      t2h_int_rcp_gov_pwm_done                        ; Yes - branch
                    5901     
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    97

0254 4004           5902             jc      t2h_int_rcp_gov_pwm_inc                 ; No - if lower, then increment
                    5903     
0256 1523           5904             dec     Governor_Req_Pwm                                ; No - if higher, then decr
                             ement
0258 415C           5905             ajmp    t2h_int_rcp_gov_pwm_done
                    5906     
025A                5907     t2h_int_rcp_gov_pwm_inc:
025A 0523           5908             inc     Governor_Req_Pwm                                ; Increment
                    5909     
025C                5910     t2h_int_rcp_gov_pwm_done:
025C D8CA           5911             djnz    Temp1, t2h_int_rcp_gov_pwm              ; If not number of steps processed 
                             - go back
                    5912     
025E 0569           5913             inc     Spoolup_Limit_Cnt                               ; Increment spoolup count
0260 E569           5914             mov     A, Spoolup_Limit_Cnt
0262 7002           5915             jnz     ($+4)                                           ; Wrapped?
                    5916     
0264 1569           5917             dec     Spoolup_Limit_Cnt                               ; Yes - decrement
                    5918     
0266 D56A67         5919             djnz    Spoolup_Limit_Skip, t2h_int_exit        ; Jump if skip count is not reached
                    5920     
0269 756A01         5921             mov     Spoolup_Limit_Skip, #1                  ; Reset skip count. Default is fast
                              spoolup
026C 7808           5922             mov     Temp1, #8                                               ; Default fast incr
                             ease for spoolup time of zero
026E E56B           5923             mov     A, Main_Spoolup_Time_3x
0270 6047           5924             jz      t2h_int_rcp_inc_limit                   ; Jump for spoolup time of zero
                    5925     
0272 7805           5926             mov     Temp1, #5                                               ; Default fast incr
                             ease
0274 C3             5927             clr     C
0275 E569           5928             mov     A, Spoolup_Limit_Cnt
0277 956B           5929             subb    A, Main_Spoolup_Time_3x                 ; No spoolup until 3*N*32ms
                    5930     
0279 4055           5931             jc      t2h_int_exit
                    5932     
027B C3             5933             clr     C
027C E569           5934             mov     A, Spoolup_Limit_Cnt
027E 956C           5935             subb    A, Main_Spoolup_Time_10x                        ; Slow spoolup until "100"*
                             N*32ms
0280 5007           5936             jnc     t2h_int_rcp_limit_middle_ramp
                    5937     
0282 7801           5938             mov     Temp1, #1                                               ; Slow initial spoo
                             lup
0284 756A03         5939             mov     Spoolup_Limit_Skip, #3                  
0287 800C           5940             jmp     t2h_int_rcp_set_limit
                    5941     
0289                5942     t2h_int_rcp_limit_middle_ramp:
0289 C3             5943             clr     C
028A E569           5944             mov     A, Spoolup_Limit_Cnt
028C 956D           5945             subb    A, Main_Spoolup_Time_15x                        ; Faster spoolup until "150
                             "*N*32ms
028E 5005           5946             jnc     t2h_int_rcp_set_limit
                    5947     
0290 7801           5948             mov     Temp1, #1                                               ; Faster middle spo
                             olup
0292 756A01         5949             mov     Spoolup_Limit_Skip, #1                  
                    5950     
0295                5951     t2h_int_rcp_set_limit:  
                    5952             ; Do not increment spoolup limit if higher pwm is not requested, unless governor is
                              active
0295 C3             5953             clr     C
0296 E562           5954             mov     A, Pwm_Limit_Spoolup
0298 9524           5955             subb    A, Current_Pwm
029A 401D           5956             jc      t2h_int_rcp_inc_limit                   ; If Current_Pwm is larger than Pwm
                             _Limit_Spoolup - branch
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    98

                    5957     
029C 7982           5958             mov     Temp2, #Pgm_Gov_Mode                    ; Governor mode?
029E B70402         5959             cjne    @Temp2, #4, ($+5)
02A1 41C5           5960             ajmp    t2h_int_rcp_bailout_arm                 ; No - branch
                    5961     
02A3 206E13         5962             jb      Flags1.GOV_ACTIVE, t2h_int_rcp_inc_limit        ; If governor active - bran
                             ch 
                    5963     
02A6 852462         5964             mov     Pwm_Limit_Spoolup, Current_Pwm  ; Set limit to what current pwm is
02A9 E569           5965             mov     A, Spoolup_Limit_Cnt                    ; Check if spoolup limit count is 2
                             55. If it is, then this is a "bailout" ramp
02AB 04             5966             inc     A
02AC 6003           5967             jz      ($+5)
                    5968     
02AE 856B69         5969             mov     Spoolup_Limit_Cnt, Main_Spoolup_Time_3x ; Stay in an early part of the spoo
                             lup sequence (unless "bailout" ramp)
                    5970     
02B1 756A01         5971             mov     Spoolup_Limit_Skip, #1                  ; Set skip count
02B4 75233C         5972             mov     Governor_Req_Pwm, #60                   ; Set governor requested speed to e
                             nsure that it requests higher speed
                    5973                                                                             ; 20=Fail on jerk w
                             hen governor activates
                    5974                                                                             ; 30=Ok
                    5975                                                                             ; 100=Fail on small
                              governor settling overshoot on low headspeeds
                    5976                                                                             ; 200=Fail on gover
                             nor settling overshoot
02B7 8017           5977             jmp     t2h_int_exit                                    ; Exit
                    5978     
02B9                5979     t2h_int_rcp_inc_limit:
02B9 E562           5980             mov     A, Pwm_Limit_Spoolup                    ; Increment spoolup pwm
02BB 28             5981             add     A, Temp1
02BC 5005           5982             jnc     t2h_int_rcp_no_limit                    ; If below 255 - branch
                    5983     
02BE 7562FF         5984             mov     Pwm_Limit_Spoolup, #0FFh
02C1 41C5           5985             ajmp    t2h_int_rcp_bailout_arm
                    5986     
02C3                5987     t2h_int_rcp_no_limit:
02C3 F562           5988             mov     Pwm_Limit_Spoolup, A
02C5                5989     t2h_int_rcp_bailout_arm:
02C5 E562           5990             mov     A, Pwm_Limit_Spoolup
02C7 04             5991             inc     A
02C8 7006           5992             jnz     t2h_int_exit
                    5993     
02CA 7560FF         5994             mov     Auto_Bailout_Armed, #255                        ; Arm bailout
02CD 7569FF         5995             mov     Spoolup_Limit_Cnt, #255                 
                    5996     
                    5997     ENDIF
02D0                5998     t2h_int_exit:
02D0 D0E0           5999             pop     ACC                     ; Restore preserved registers
02D2 D0D0           6000             pop     PSW
02D4 43E610         6001             orl     EIE1, #10h      ; Enable PCA0 interrupts
02D7 D2AD           6002             setb    ET2                     ; Enable timer2 interrupts
02D9 32             6003             reti
                    6004     
                    6005     
                    6006     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    6007     ;
                    6008     ; Timer3 interrupt routine
                    6009     ;
                    6010     ; No assumptions
                    6011     ;
                    6012     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
02DA                6013     t3_int: ; Used for commutation timing
02DA C2AF           6014             clr     EA                              ; Disable all interrupts
02DC 53E67F         6015             anl     EIE1, #7Fh              ; Disable timer3 interrupts
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE    99

02DF 7592FA         6016             mov     TMR3RLL, #0FAh          ; Set a short delay before next interrupt
02E2 7593FF         6017             mov     TMR3RLH, #0FFh
02E5 C260           6018             clr     Flags0.T3_PENDING       ; Flag that timer has wrapped
02E7 759104         6019             mov     TMR3CN, #04h            ; Timer3 enabled and interrupt flag cleared
02EA D2AF           6020             setb    EA                              ; Enable all interrupts
02EC 32             6021             reti
                    6022     
                    6023     
                    6024     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    6025     ;
                    6026     ; PCA interrupt routine
                    6027     ;
                    6028     ; No assumptions
                    6029     ;
                    6030     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
02ED                6031     pca_int:        ; Used for RC pulse timing
02ED C2AF           6032             clr     EA
02EF 53E6EF         6033             anl     EIE1, #0EFh     ; Disable PCA0 interrupts
02F2 C2AD           6034             clr     ET2                     ; Disable timer2 interrupts
02F4 C0D0           6035             push    PSW                     ; Preserve registers through interrupt
02F6 C0E0           6036             push    ACC
02F8 C0F0           6037             push    B
02FA D2D3           6038             setb    PSW.3           ; Select register bank 1 for interrupt routines
02FC D2AF           6039             setb    EA
                    6040             ; Get the PCA counter values
                    6041             Get_Rcp_Capture_Values
                    6044             ; Clear interrupt flag
                    6045             Rcp_Clear_Int_Flag                              
                    6047             ; Check which edge it is
0304 307102         6048             jnb     Flags2.RCP_EDGE_NO, ($+5)       ; Is it a first edge trig?
0307 6154           6049             ajmp pca_int_second_meas_pwm_freq       ; No - branch to second
                    6050     
                    6051             Rcp_Int_Second                                  ; Yes - set second edge trig
0318 D271           6057             setb    Flags2.RCP_EDGE_NO                      ; Set second edge flag
                    6058             ; Read RC signal level
                    6059             Read_Rcp_Int                    
                    6063             ; Test RC signal level
0320 20E502         6064             jb      ACC.Rcp_In, ($+5)                       ; Is it high?
0323 612B           6065             ajmp    pca_int_fail_minimum            ; No - jump to fail minimum
                    6066     
                    6067             ; RC pulse was high, store RC pulse start timestamp
0325 8827           6068             mov     Rcp_Prev_Edge_L, Temp1
0327 8928           6069             mov     Rcp_Prev_Edge_H, Temp2
0329 A137           6070             ajmp    pca_int_exit                            ; Exit
                    6071     
032B                6072     pca_int_fail_minimum:
                    6073             ; Prepare for next interrupt
                    6074             Rcp_Int_First                                   ; Set interrupt trig to first again
                    6080             Rcp_Clear_Int_Flag                              ; Clear interrupt flag
033C C271           6082             clr     Flags2.RCP_EDGE_NO                      ; Set first edge flag
033E 307402         6083             jnb     Flags2.RCP_PPM, ($+5)           ; If flag is not set (PWM) - branch
                    6084     
0341 A123           6085             ajmp    pca_int_set_timeout                     ; If PPM - ignore trig as noise
                    6086     
0343 7800           6087             mov     Temp1, #RCP_MIN                 ; Set RC pulse value to minimum
                    6088             Read_Rcp_Int                                    ; Test RC signal level again
034B 30E502         6092             jnb     ACC.Rcp_In, ($+5)                       ; Is it high?
                    6093     
034E A123           6094             ajmp    pca_int_set_timeout                     ; Yes - set new timeout and exit
                    6095     
0350 885C           6096             mov     New_Rcp, Temp1                          ; Store new pulse length
0352 A10B           6097             ajmp    pca_int_limited                 ; Set new RC pulse, new timeout and exit
                    6098     
0354                6099     pca_int_second_meas_pwm_freq:
                    6100             ; Prepare for next interrupt
                    6101             Rcp_Int_First                                   ; Set first edge trig
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   100

0363 C271           6107             clr     Flags2.RCP_EDGE_NO                      ; Set first edge flag
                    6108             ; Check if pwm frequency shall be measured
0365 206102         6109             jb      Flags0.RCP_MEAS_PWM_FREQ, ($+5) ; Is measure RCP pwm frequency flag set?
0368 812D           6110             ajmp    pca_int_fall                            ; No - skip measurements
                    6111     
                    6112             ; Set second edge trig only during pwm frequency measurement
                    6113             Rcp_Int_Second                          ; Set second edge trig
                    6119             Rcp_Clear_Int_Flag                              ; Clear interrupt flag
037B D271           6121             setb    Flags2.RCP_EDGE_NO                      ; Set second edge flag
                    6122             ; Store edge data to RAM
037D 8857           6123             mov     Rcp_Edge_L, Temp1
037F 8958           6124             mov     Rcp_Edge_H, Temp2
                    6125             ; Calculate pwm frequency
0381 C3             6126             clr     C
0382 E8             6127             mov     A, Temp1
0383 9555           6128             subb    A, Rcp_PrePrev_Edge_L   
0385 F8             6129             mov     Temp1, A
0386 E9             6130             mov     A, Temp2
0387 9556           6131             subb    A, Rcp_PrePrev_Edge_H
0389 F9             6132             mov     Temp2, A
038A 7B00           6133             mov     Temp4, #0
038C 7E08           6134             mov     Temp7, #8                                       ; Set default period tolera
                             nce requirement (MSB)
038E 7A00           6135             mov     Temp3, #0                                       ; (LSB)
                    6136             ; Check if pulse is too short
0390 C3             6137             clr     C
0391 E8             6138             mov     A, Temp1
0392 948C           6139             subb    A, #low(140)                            ; If pulse below 70us, not accepted
0394 E9             6140             mov     A, Temp2
0395 9400           6141             subb    A, #high(140)
0397 5005           6142             jnc     pca_int_check_12kHz
                    6143     
0399 755B00         6144             mov     Rcp_Period_Diff_Accepted, #0    ; Set not accepted 
039C 811F           6145             ajmp    pca_int_store_data
                    6146     
039E                6147     pca_int_check_12kHz:
039E 8821           6148             mov     Bit_Access_Int, Temp1
03A0 78A2           6149             mov     Temp1, #Pgm_Enable_PWM_Input    ; Check if PWM input is enabled
03A2 E6             6150             mov     A, @Temp1
03A3 A821           6151             mov     Temp1, Bit_Access_Int
03A5 6055           6152             jz      pca_int_restore_edge            ; If it is not - branch
                    6153     
                    6154             ; Check if pwm frequency is 12kHz
03A7 C3             6155             clr     C
03A8 E8             6156             mov     A, Temp1
03A9 94C8           6157             subb    A, #low(200)                            ; If below 100us, 12kHz pwm is assu
                             med
03AB E9             6158             mov     A, Temp2
03AC 9400           6159             subb    A, #high(200)
03AE 5008           6160             jnc     pca_int_check_8kHz
                    6161     
03B0 E4             6162             clr     A
03B1 D2E4           6163             setb    ACC.RCP_PWM_FREQ_12KHZ
03B3 FB             6164             mov     Temp4, A
03B4 7A0A           6165             mov     Temp3, #10                              ; Set period tolerance requirement 
                             (LSB)
03B6 61FA           6166             ajmp    pca_int_restore_edge_set_msb
                    6167     
03B8                6168     pca_int_check_8kHz:
                    6169             ; Check if pwm frequency is 8kHz
03B8 C3             6170             clr     C
03B9 E8             6171             mov     A, Temp1
03BA 9468           6172             subb    A, #low(360)                            ; If below 180us, 8kHz pwm is assum
                             ed
03BC E9             6173             mov     A, Temp2
03BD 9401           6174             subb    A, #high(360)
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   101

03BF 5008           6175             jnc     pca_int_check_4kHz
                    6176     
03C1 E4             6177             clr     A
03C2 D2E3           6178             setb    ACC.RCP_PWM_FREQ_8KHZ
03C4 FB             6179             mov     Temp4, A
03C5 7A0F           6180             mov     Temp3, #15                              ; Set period tolerance requirement 
                             (LSB)
03C7 61FA           6181             ajmp    pca_int_restore_edge_set_msb
                    6182     
03C9                6183     pca_int_check_4kHz:
                    6184             ; Check if pwm frequency is 4kHz
03C9 C3             6185             clr     C
03CA E8             6186             mov     A, Temp1
03CB 94D0           6187             subb    A, #low(720)                            ; If below 360us, 4kHz pwm is assum
                             ed
03CD E9             6188             mov     A, Temp2
03CE 9402           6189             subb    A, #high(720)
03D0 5008           6190             jnc     pca_int_check_2kHz
                    6191     
03D2 E4             6192             clr     A
03D3 D2E2           6193             setb    ACC.RCP_PWM_FREQ_4KHZ
03D5 FB             6194             mov     Temp4, A
03D6 7A1E           6195             mov     Temp3, #30                              ; Set period tolerance requirement 
                             (LSB)
03D8 61FA           6196             ajmp    pca_int_restore_edge_set_msb
                    6197     
03DA                6198     pca_int_check_2kHz:
                    6199             ; Check if pwm frequency is 2kHz
03DA C3             6200             clr     C
03DB E8             6201             mov     A, Temp1
03DC 94A0           6202             subb    A, #low(1440)                           ; If below 720us, 2kHz pwm is assum
                             ed
03DE E9             6203             mov     A, Temp2
03DF 9405           6204             subb    A, #high(1440)
03E1 5008           6205             jnc     pca_int_check_1kHz
                    6206     
03E3 E4             6207             clr     A
03E4 D2E1           6208             setb    ACC.RCP_PWM_FREQ_2KHZ
03E6 FB             6209             mov     Temp4, A
03E7 7A3C           6210             mov     Temp3, #60                              ; Set period tolerance requirement 
                             (LSB)
03E9 61FA           6211             ajmp    pca_int_restore_edge_set_msb
                    6212     
03EB                6213     pca_int_check_1kHz:
                    6214             ; Check if pwm frequency is 1kHz
03EB C3             6215             clr     C
03EC E8             6216             mov     A, Temp1
03ED 9498           6217             subb    A, #low(2200)                           ; If below 1100us, 1kHz pwm is assu
                             med
03EF E9             6218             mov     A, Temp2
03F0 9408           6219             subb    A, #high(2200)
03F2 5008           6220             jnc     pca_int_restore_edge
                    6221     
03F4 E4             6222             clr     A
03F5 D2E0           6223             setb    ACC.RCP_PWM_FREQ_1KHZ
03F7 FB             6224             mov     Temp4, A
03F8 7A78           6225             mov     Temp3, #120                             ; Set period tolerance requirement 
                             (LSB)
                    6226     
03FA                6227     pca_int_restore_edge_set_msb:
03FA 7E00           6228             mov     Temp7, #0                                       ; Set period tolerance requ
                             irement (MSB)
03FC                6229     pca_int_restore_edge:
                    6230             ; Calculate difference between this period and previous period
03FC C3             6231             clr     C
03FD E8             6232             mov     A, Temp1
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   102

03FE 9559           6233             subb    A, Rcp_Prev_Period_L
0400 FC             6234             mov     Temp5, A
0401 E9             6235             mov     A, Temp2
0402 955A           6236             subb    A, Rcp_Prev_Period_H
0404 FD             6237             mov     Temp6, A
                    6238             ; Make positive
0405 30E70A         6239             jnb     ACC.7, pca_int_check_diff
0408 EC             6240             mov     A, Temp5
0409 F4             6241             cpl     A
040A 2401           6242             add     A, #1
040C FC             6243             mov     Temp5, A
040D ED             6244             mov     A, Temp6
040E F4             6245             cpl     A
040F 3400           6246             addc    A, #0
0411 FD             6247             mov     Temp6, A
                    6248     
0412                6249     pca_int_check_diff:
                    6250             ; Check difference
0412 755B00         6251             mov     Rcp_Period_Diff_Accepted, #0            ; Set not accepted as default
0415 C3             6252             clr     C
0416 EC             6253             mov     A, Temp5
0417 9A             6254             subb    A, Temp3                                                ; Check difference
0418 ED             6255             mov     A, Temp6
0419 9E             6256             subb    A, Temp7                                                
041A 5003           6257             jnc     pca_int_store_data
                    6258     
041C 755B01         6259             mov     Rcp_Period_Diff_Accepted, #1            ; Set accepted
                    6260     
041F                6261     pca_int_store_data:
                    6262             ; Store previous period
041F 8859           6263             mov     Rcp_Prev_Period_L, Temp1
0421 895A           6264             mov     Rcp_Prev_Period_H, Temp2
                    6265             ; Store pre previous edge
0423 855755         6266             mov     Rcp_PrePrev_Edge_L, Rcp_Edge_L
0426 855856         6267             mov     Rcp_PrePrev_Edge_H, Rcp_Edge_H
0429 7802           6268             mov     Temp1, #RCP_VALIDATE
042B A10B           6269             ajmp    pca_int_limited
                    6270     
042D                6271     pca_int_fall:
                    6272             ; RC pulse edge was second, calculate new pulse length
042D C3             6273             clr     C
042E E8             6274             mov     A, Temp1
042F 9527           6275             subb    A, Rcp_Prev_Edge_L      
0431 F8             6276             mov     Temp1, A
0432 E9             6277             mov     A, Temp2
0433 9528           6278             subb    A, Rcp_Prev_Edge_H
0435 F9             6279             mov     Temp2, A
0436 307C02         6280             jnb     Flags3.RCP_PWM_FREQ_12KHZ, ($+5)        ; Is RC input pwm frequency 12kHz?
0439 81EF           6281             ajmp    pca_int_pwm_divide_done                 ; Yes - branch forward
                    6282     
043B 307B02         6283             jnb     Flags3.RCP_PWM_FREQ_8KHZ, ($+5) ; Is RC input pwm frequency 8kHz?
043E 81EF           6284             ajmp    pca_int_pwm_divide_done                 ; Yes - branch forward
                    6285     
0440 307A02         6286             jnb     Flags3.RCP_PWM_FREQ_4KHZ, ($+5) ; Is RC input pwm frequency 4kHz?
0443 81E8           6287             ajmp    pca_int_pwm_divide                              ; Yes - branch forward
                    6288     
0445 207502         6289             jb      Flags2.RCP_PPM_ONESHOT125, ($+5)
0448 8150           6290             ajmp    pca_int_fall_not_oneshot
                    6291     
044A E9             6292             mov     A, Temp2                                                ; Oneshot125 - move
                              to I_Temp5/6
044B FD             6293             mov     Temp6, A
044C E8             6294             mov     A, Temp1
044D FC             6295             mov     Temp5, A
044E 816F           6296             ajmp    pca_int_fall_check_range
                    6297     
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   103

0450                6298     pca_int_fall_not_oneshot:
0450 E9             6299             mov     A, Temp2                                                ; No - 2kHz. Divide
                              by 2
0451 C3             6300             clr     C
0452 13             6301             rrc     A
0453 F9             6302             mov     Temp2, A
0454 E8             6303             mov     A, Temp1                                        
0455 13             6304             rrc     A
0456 F8             6305             mov     Temp1, A
                    6306     
0457 307902         6307             jnb     Flags3.RCP_PWM_FREQ_2KHZ, ($+5) ; Is RC input pwm frequency 2kHz?
045A 81E8           6308             ajmp    pca_int_pwm_divide                              ; Yes - branch forward
                    6309     
045C E9             6310             mov     A, Temp2                                                ; No - 1kHz. Divide
                              by 2 again
045D C3             6311             clr     C
045E 13             6312             rrc     A
045F F9             6313             mov     Temp2, A
0460 E8             6314             mov     A, Temp1                                        
0461 13             6315             rrc     A
0462 F8             6316             mov     Temp1, A
                    6317     
0463 307802         6318             jnb     Flags3.RCP_PWM_FREQ_1KHZ, ($+5) ; Is RC input pwm frequency 1kHz?
0466 81E8           6319             ajmp    pca_int_pwm_divide                              ; Yes - branch forward
                    6320     
0468 E9             6321             mov     A, Temp2                                                ; No - PPM. Divide 
                             by 2 (to bring range to 256) and move to Temp5/6
0469 C3             6322             clr     C
046A 13             6323             rrc     A
046B FD             6324             mov     Temp6, A
046C E8             6325             mov     A, Temp1                                        
046D 13             6326             rrc     A
046E FC             6327             mov     Temp5, A
046F                6328     pca_int_fall_check_range:
                    6329             ; Skip range limitation if pwm frequency measurement
046F 20612C         6330             jb      Flags0.RCP_MEAS_PWM_FREQ, pca_int_ppm_check_full_range          
                    6331     
                    6332             ; Check if 2160us or above (in order to ignore false pulses)
0472 C3             6333             clr     C
0473 EC             6334             mov     A, Temp5                                                ; Is pulse 2160us o
                             r higher?
0474 941C           6335             subb    A, #28
0476 ED             6336             mov     A, Temp6
0477 9402           6337             subb A, #2
0479 4002           6338             jc      ($+4)                                           ; No - proceed
                    6339     
047B 8186           6340             ajmp    pca_int_ppm_outside_range               ; Yes - ignore pulse
                    6341     
047D                6342     pca_int_ppm_below_full_range:
                    6343             ; Check if below 800us (in order to ignore false pulses)
047D ED             6344             mov     A, Temp6
047E 701E           6345             jnz     pca_int_ppm_check_full_range
                    6346     
0480 C3             6347             clr     C
0481 EC             6348             mov     A, Temp5                                                ; Is pulse below 80
                             0us?
0482 94C8           6349             subb    A, #200
0484 5018           6350             jnc     pca_int_ppm_check_full_range            ; No - proceed
                    6351     
0486                6352     pca_int_ppm_outside_range:
0486 0529           6353             inc     Rcp_Outside_Range_Cnt
0488 E529           6354             mov     A, Rcp_Outside_Range_Cnt
048A 7002           6355             jnz     ($+4)
                    6356     
048C 1529           6357             dec     Rcp_Outside_Range_Cnt
                    6358     
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   104

048E C3             6359             clr     C
048F E529           6360             mov     A, Rcp_Outside_Range_Cnt
0491 940A           6361             subb    A, #10                                          ; Allow a given number of o
                             utside pulses
0493 5002           6362             jnc     ($+4)                   
0495 A123           6363             ajmp    pca_int_set_timeout                             ; If below limit - ignore p
                             ulse
                    6364     
0497 755C00         6365             mov     New_Rcp, #0                                     ; Set pulse length to zero
049A D270           6366             setb    Flags2.RCP_UPDATED                              ; Set updated flag
049C A123           6367             ajmp    pca_int_set_timeout                     
                    6368     
049E                6369     pca_int_ppm_check_full_range:
                    6370             ; Decrement outside range counter
049E E529           6371             mov     A, Rcp_Outside_Range_Cnt
04A0 6002           6372             jz      ($+4)
                    6373     
04A2 1529           6374             dec     Rcp_Outside_Range_Cnt
                    6375     
                    6376             ; Calculate "1000us" plus throttle minimum
                    6377     IF MODE >= 1    ; Tail or multi
                                     mov     Temp1, #Pgm_Direction                   ; Check if bidirectional operation 
                             (store in Temp2)
                                     mov     A, @Temp1                               
                                     mov     Temp2, A                                
                             ENDIF
04A4 7400           6382             mov     A, #0                                           ; Set 1000us as default min
                             imum
04A6 207F03         6383             jb      Flags3.FULL_THROTTLE_RANGE, pca_int_ppm_calculate       ; Check if full ran
                             ge is chosen
                    6384     
04A9 7896           6385             mov     Temp1, #Pgm_Ppm_Min_Throttle            ; Min throttle value is in 4us units
                    6386     IF MODE >= 1    ; Tail or multi
                                     cjne    Temp2, #3, ($+5)
                             
                                     mov     Temp1, #Pgm_Ppm_Center_Throttle ; Center throttle value is in 4us units
                             ENDIF
04AB E6             6391             mov     A, @Temp1                               
                    6392     
04AC                6393     pca_int_ppm_calculate:
04AC 24FA           6394             add     A, #250                                         ; Add 1000us to minimum
04AE FE             6395             mov     Temp7, A
04AF E4             6396             clr     A
04B0 3400           6397             addc    A, #0
04B2 FF             6398             mov     Temp8, A
                    6399     
04B3 C3             6400             clr     C
04B4 EC             6401             mov     A, Temp5                                                ; Subtract minimum
04B5 9E             6402             subb    A, Temp7
04B6 FC             6403             mov     Temp5, A
04B7 ED             6404             mov     A, Temp6                                        
04B8 9F             6405             subb    A, Temp8
04B9 FD             6406             mov     Temp6, A
                    6407     IF MODE >= 1    ; Tail or multi
                                     mov     Bit_Access_Int.0, C
                                     cjne    Temp2, #3, pca_int_ppm_bidir_dir_set; If not bidirectional operation - bran
                             ch
                             
                                     mov     C, Bit_Access_Int.0
                                     jnc     pca_int_ppm_bidir_fwd                   ; If result is positive - branch   
                                                          
                             
                                     jb      Flags2.RCP_DIR_REV, pca_int_ppm_bidir_dir_set   ; If same direction - branch
                             
                                     setb    Flags2.RCP_DIR_REV
                                     ajmp    pca_int_ppm_bidir_dir_set
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   105

                             
                             pca_int_ppm_bidir_fwd:
                                     jnb     Flags2.RCP_DIR_REV, pca_int_ppm_bidir_dir_set   ; If same direction - branch
                             
                                     clr     Flags2.RCP_DIR_REV
                             
                             pca_int_ppm_bidir_dir_set:
                                     mov     C, Bit_Access_Int.0
                             ENDIF
04BA 5006           6427             jnc     pca_int_ppm_neg_checked                 ; If result is positive - branch
                    6428     
                    6429     IF MODE >= 1    ; Tail or multi
                                     cjne    Temp2, #3, pca_int_ppm_unidir_neg       ; If not bidirectional operation - 
                             branch
                             
                                     mov     A, Temp5                                                ; Change sign      
                                  
                                     cpl     A
                                     add     A, #1
                                     mov     Temp5, A
                                     mov     A, Temp6                                                        
                                     cpl     A
                                     addc    A, #0
                                     mov     Temp6, A
                                     jmp     pca_int_ppm_neg_checked
                             
                             pca_int_ppm_unidir_neg:
                             ENDIF
04BC 7800           6444             mov     Temp1, #RCP_MIN                         ; Yes - set to minimum
04BE 7900           6445             mov     Temp2, #0
04C0 81EF           6446             ajmp    pca_int_pwm_divide_done
                    6447     
04C2                6448     pca_int_ppm_neg_checked:
                    6449     IF MODE >= 1    ; Tail or multi
                                     cjne    Temp2, #3, pca_int_ppm_bidir_done       ; If not bidirectional operation - 
                             branch
                             
                                     mov     A, Temp5                                                ; Multiply value by
                              2
                                     rlc     A
                                     mov     Temp5, A 
                                     mov     A, Temp6
                                     rlc     A
                                     mov     Temp6, A
                                     clr     C                                                       ; Subtract deadband
                                     mov     A, Temp5
                                     subb    A, #10          
                                     mov     Temp5, A
                                     mov     A, Temp6
                                     subb    A, #0
                                     mov     Temp6, A
                                     jnc     pca_int_ppm_bidir_done
                             
                                     mov     Temp5, #RCP_MIN
                                     mov     Temp6, #0
                             
                             pca_int_ppm_bidir_done:
                             ENDIF
04C2 C3             6472             clr     C                                                       ; Check that RC pul
                             se is within legal range (max 255)
04C3 EC             6473             mov     A, Temp5
04C4 94FF           6474             subb    A, #RCP_MAX                             
04C6 ED             6475             mov     A, Temp6
04C7 9400           6476             subb    A, #0
04C9 4006           6477             jc      pca_int_ppm_max_checked
                    6478     
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   106

04CB 78FF           6479             mov     Temp1, #RCP_MAX
04CD 7900           6480             mov     Temp2, #0
04CF 81EF           6481             ajmp    pca_int_pwm_divide_done
                    6482     
04D1                6483     pca_int_ppm_max_checked:
04D1 EC             6484             mov     A, Temp5                                                ; Multiply throttle
                              value by gain
04D2 8572F0         6485             mov     B, Ppm_Throttle_Gain
04D5 A4             6486             mul     AB
04D6 C5F0           6487             xch     A, B
04D8 A2F7           6488             mov     C, B.7                                          ; Multiply result by 2 (uni
                             ty gain is 128)
04DA 33             6489             rlc     A
04DB F8             6490             mov     Temp1, A                                                ; Transfer to Temp1
                             /2
04DC 7900           6491             mov     Temp2, #0
04DE 4002           6492             jc      pca_int_ppm_limit_after_mult
                    6493             
04E0 8029           6494             jmp     pca_int_limited                 
                    6495     
04E2                6496     pca_int_ppm_limit_after_mult:
04E2 78FF           6497             mov     Temp1, #RCP_MAX
04E4 7900           6498             mov     Temp2, #0
04E6 8023           6499             jmp     pca_int_limited                 
                    6500     
04E8                6501     pca_int_pwm_divide:
04E8 E9             6502             mov     A, Temp2                                                ; Divide by 2
04E9 C3             6503             clr     C
04EA 13             6504             rrc     A
04EB F9             6505             mov     Temp2, A
04EC E8             6506             mov     A, Temp1                                        
04ED 13             6507             rrc     A
04EE F8             6508             mov     Temp1, A
                    6509     
04EF                6510     pca_int_pwm_divide_done:
04EF 307C0E         6511             jnb     Flags3.RCP_PWM_FREQ_12KHZ, pca_int_check_legal_range    ; Is RC input pwm f
                             requency 12kHz?
04F2 E9             6512             mov     A, Temp2                                                ; Yes - check that 
                             value is not more than 255
04F3 6002           6513             jz      ($+4)
                    6514     
04F5 78FF           6515             mov     Temp1, #RCP_MAX
                    6516     
04F7 C3             6517             clr     C
04F8 E8             6518             mov     A, Temp1                                                ; Multiply by 1.5  
                                                          
04F9 13             6519             rrc     A
04FA 38             6520             addc    A, Temp1
04FB F8             6521             mov     Temp1, A
04FC E4             6522             clr     A
04FD 3400           6523             addc    A, #0
04FF F9             6524             mov     Temp2, A
                    6525     
0500                6526     pca_int_check_legal_range:
                    6527             ; Check that RC pulse is within legal range
0500 C3             6528             clr     C
0501 E8             6529             mov     A, Temp1
0502 94FF           6530             subb    A, #RCP_MAX                             
0504 E9             6531             mov     A, Temp2
0505 9400           6532             subb    A, #0
0507 4002           6533             jc      pca_int_limited
                    6534     
0509 78FF           6535             mov     Temp1, #RCP_MAX
                    6536     
050B                6537     pca_int_limited:
                    6538             ; RC pulse value accepted
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   107

050B 885C           6539             mov     New_Rcp, Temp1                          ; Store new pulse length
050D D270           6540             setb    Flags2.RCP_UPDATED                      ; Set updated flag
050F 206102         6541             jb      Flags0.RCP_MEAS_PWM_FREQ, ($+5) ; Is measure RCP pwm frequency flag set?
                    6542     
0512 A123           6543             ajmp    pca_int_set_timeout                     ; No - skip measurements
                    6544     
0514 741F           6545             mov     A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FRE
                             Q_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
0516 F4             6546             cpl     A
0517 552F           6547             anl     A, Flags3                                       ; Clear all pwm frequency f
                             lags
0519 4B             6548             orl     A, Temp4                                        ; Store pwm frequency value
                              in flags
051A F52F           6549             mov     Flags3, A
051C C274           6550             clr     Flags2.RCP_PPM                          ; Default, flag is not set (PWM)
051E EB             6551             mov     A, Temp4                                        ; Check if all flags are cl
                             eared
051F 7002           6552             jnz     pca_int_set_timeout
                    6553     
0521 D274           6554             setb    Flags2.RCP_PPM                          ; Set flag (PPM)
                    6555     
0523                6556     pca_int_set_timeout:
0523 752A40         6557             mov     Rcp_Timeout_Cntd, #RCP_TIMEOUT  ; Set timeout count to start value
0526 307403         6558             jnb     Flags2.RCP_PPM, pca_int_ppm_timeout_set ; If flag is not set (PWM) - branch
                    6559     
0529 752A0A         6560             mov     Rcp_Timeout_Cntd, #RCP_TIMEOUT_PPM      ; No flag set means PPM. Set timeou
                             t count
                    6561     
052C                6562     pca_int_ppm_timeout_set:
052C 306102         6563             jnb     Flags0.RCP_MEAS_PWM_FREQ, ($+5) ; Is measure RCP pwm frequency flag set?
                    6564     
052F A137           6565             ajmp pca_int_exit                               ; Yes - exit
                    6566     
0531 207403         6567             jb      Flags2.RCP_PPM, pca_int_exit    ; If flag is set (PPM) - branch
                    6568     
                    6569             Rcp_Int_Disable                                 ; Disable RC pulse interrupt
                    6571     
0537                6572     pca_int_exit:   ; Exit interrupt routine        
0537 207403         6573             jb      Flags2.RCP_PPM, ($+6)           ; If flag is set (PPP) - branch
                    6574     
053A 752B20         6575             mov     Rcp_Skip_Cntd, #RCP_SKIP_RATE   ; Load number of skips
                    6576     
053D D0F0           6577             pop     B                       ; Restore preserved registers
053F D0E0           6578             pop     ACC                     
0541 D0D0           6579             pop     PSW
0543 D2AD           6580             setb    ET2                     ; Enable timer2 interrupts
0545 43E610         6581             orl     EIE1, #10h      ; Enable PCA0 interrupts
0548 32             6582             reti
                    6583     
                    6584     
                    6585     
                    6586     
                    6587     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    6588     ;
                    6589     ; Wait xms ~(x*4*250)  (Different entry points) 
                    6590     ;
                    6591     ; No assumptions
                    6592     ;
                    6593     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
0549                6594     wait1ms:        
0549 7901           6595             mov     Temp2, #1
054B 8014           6596             jmp     waitxms_o
                    6597     
054D                6598     wait3ms:        
054D 7903           6599             mov     Temp2, #3
054F 8010           6600             jmp     waitxms_o
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   108

                    6601     
0551                6602     wait10ms:       
0551 790A           6603             mov     Temp2, #10
0553 800C           6604             jmp     waitxms_o
                    6605     
0555                6606     wait30ms:       
0555 791E           6607             mov     Temp2, #30
0557 8008           6608             jmp     waitxms_o
                    6609     
0559                6610     wait100ms:      
0559 7964           6611             mov     Temp2, #100
055B 8004           6612             jmp     waitxms_o
                    6613     
055D                6614     wait200ms:      
055D 79C8           6615             mov     Temp2, #200
055F 8000           6616             jmp     waitxms_o
                    6617     
0561                6618     waitxms_o:      ; Outer loop
0561 7817           6619             mov     Temp1, #23
0563                6620     waitxms_m:      ; Middle loop
0563 E4             6621             clr     A
0564 D5E0FD         6622             djnz    ACC, $  ; Inner loop (42.7us - 1024 cycles)
0567 D8FA           6623             djnz    Temp1, waitxms_m
0569 D9F6           6624             djnz    Temp2, waitxms_o
056B 22             6625             ret
                    6626     
                    6627     
                    6628     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    6629     ;
                    6630     ; Beeper routines (4 different entry points) 
                    6631     ;
                    6632     ; No assumptions
                    6633     ;
                    6634     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
056C                6635     beep_f1:        ; Entry point 1, load beeper frequency 1 settings
056C 7A14           6636             mov     Temp3, #20      ; Off wait loop length
056E 7B78           6637             mov     Temp4, #120     ; Number of beep pulses
0570 8012           6638             jmp     beep
                    6639     
0572                6640     beep_f2:        ; Entry point 2, load beeper frequency 2 settings
0572 7A10           6641             mov     Temp3, #16
0574 7B8C           6642             mov     Temp4, #140
0576 800C           6643             jmp     beep
                    6644     
0578                6645     beep_f3:        ; Entry point 3, load beeper frequency 3 settings
0578 7A0D           6646             mov     Temp3, #13
057A 7BB4           6647             mov     Temp4, #180
057C 8006           6648             jmp     beep
                    6649     
057E                6650     beep_f4:        ; Entry point 4, load beeper frequency 4 settings
057E 7A0B           6651             mov     Temp3, #11
0580 7BC8           6652             mov     Temp4, #200
0582 8000           6653             jmp     beep
                    6654     
0584                6655     beep:   ; Beep loop start
0584 E573           6656             mov     A, Beep_Strength
0586 D5E001         6657             djnz    ACC, beep_start 
0589 22             6658             ret
                    6659     
058A                6660     beep_start:    
058A 7902           6661             mov     Temp2, #2       
058C                6662     beep_onoff:
058C E4             6663             clr     A
                    6664             BpFET_off                       ; BpFET off
058F D5E0FD         6666             djnz    ACC, $          ; Allow some time after pfet is turned off
                    6667             BnFET_on                        ; BnFET on (in order to charge the driver of the Bp
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   109

                             FET)
0594 D5E0FD         6669             djnz    ACC, $          ; Let the nfet be turned on a while
                    6670             BnFET_off                       ; BnFET off again
0599 D5E0FD         6672             djnz    ACC, $          ; Allow some time after nfet is turned off
                    6673             BpFET_on                        ; BpFET on
059E D5E0FD         6675             djnz    ACC, $          ; Allow some time after pfet is turned on
                    6676             ; Turn on nfet
05A1 E9             6677             mov     A, Temp2
05A2 20E002         6678             jb      ACC.0, beep_anfet_on
                    6679             AnFET_on                        ; AnFET on
05A7                6681     beep_anfet_on:
05A7 30E002         6682             jnb     ACC.0, beep_cnfet_on
                    6683             CnFET_on                        ; CnFET on
05AC                6685     beep_cnfet_on:
05AC E573           6686             mov     A, Beep_Strength
05AE D5E0FD         6687             djnz    ACC, $          
                    6688             ; Turn off nfet
05B1 E9             6689             mov     A, Temp2
05B2 20E002         6690             jb      ACC.0, beep_anfet_off
                    6691             AnFET_off                       ; AnFET off
05B7                6693     beep_anfet_off:
05B7 30E002         6694             jnb     ACC.0, beep_cnfet_off
                    6695             CnFET_off                       ; CnFET off
05BC                6697     beep_cnfet_off:
05BC 7496           6698             mov     A, #150         ; 25s off
05BE D5E0FD         6699             djnz    ACC, $          
05C1 D9C9           6700             djnz    Temp2, beep_onoff
                    6701             ; Copy variable
05C3 EA             6702             mov     A, Temp3
05C4 F8             6703             mov     Temp1, A        
05C5                6704     beep_off:               ; Fets off loop
05C5 D5E0FD         6705             djnz    ACC, $
05C8 D8FB           6706             djnz    Temp1,  beep_off
05CA DBB8           6707             djnz    Temp4,  beep
                    6708             BpFET_off                       ; BpFET off
05CE 22             6710             ret
                    6711     
                    6712     
                    6713     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    6714     ;
                    6715     ; Division 16bit unsigned by 16bit unsigned
                    6716     ;
                    6717     ; Dividend shall be in Temp2/Temp1, divisor in Temp4/Temp3
                    6718     ; Result will be in Temp2/Temp1
                    6719     ;
                    6720     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
05CF                6721     div_u16_by_u16: 
05CF C3             6722             clr     C       
05D0 7C00           6723             mov     Temp5, #0
05D2 7D00           6724             mov     Temp6, #0
05D4 75F000         6725             mov     B, #0
05D7                6726     div_u16_by_u16_div1:
05D7 05F0           6727             inc     B                       ; Increment counter for each left shift
05D9 EA             6728             mov     A, Temp3                ; Shift left the divisor
05DA 33             6729             rlc     A               
05DB FA             6730             mov     Temp3, A        
05DC EB             6731             mov     A, Temp4        
05DD 33             6732             rlc     A               
05DE FB             6733             mov     Temp4, A        
05DF 50F6           6734             jnc     div_u16_by_u16_div1     ; Repeat until carry flag is set from high-byte
05E1                6735     div_u16_by_u16_div2:        
05E1 EB             6736             mov     A, Temp4                ; Shift right the divisor
05E2 13             6737             rrc     A      
05E3 FB             6738             mov     Temp4, A   
05E4 EA             6739             mov     A, Temp3   
05E5 13             6740             rrc     A      
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   110

05E6 FA             6741             mov     Temp3, A   
05E7 C3             6742             clr     C      
05E8 E9             6743             mov     A, Temp2                ; Make a safe copy of the dividend
05E9 FF             6744             mov     Temp8, A   
05EA E8             6745             mov     A, Temp1                
05EB FE             6746             mov     Temp7, A   
05EC E8             6747             mov     A, Temp1                ; Move low-byte of dividend into accumulator
05ED 9A             6748             subb    A, Temp3                ; Dividend - shifted divisor = result bit (no facto
                             r, only 0 or 1)
05EE F8             6749             mov     Temp1, A                ; Save updated dividend 
05EF E9             6750             mov     A, Temp2                ; Move high-byte of dividend into accumulator
05F0 9B             6751             subb    A, Temp4                ; Subtract high-byte of divisor (all together 16-bi
                             t substraction)
05F1 F9             6752             mov     Temp2, A                ; Save updated high-byte back in high-byte of divis
                             or
05F2 5004           6753             jnc     div_u16_by_u16_div3     ; If carry flag is NOT set, result is 1
05F4 EF             6754             mov     A, Temp8                ; Otherwise result is 0, save copy of divisor to un
                             do subtraction
05F5 F9             6755             mov     Temp2, A   
05F6 EE             6756             mov     A, Temp7                
05F7 F8             6757             mov     Temp1, A   
05F8                6758     div_u16_by_u16_div3:
05F8 B3             6759             cpl     C                       ; Invert carry, so it can be directly copied into r
                             esult
05F9 EC             6760             mov     A, Temp5 
05FA 33             6761             rlc     A                       ; Shift carry flag into temporary result
05FB FC             6762             mov     Temp5, A   
05FC ED             6763             mov     A, Temp6
05FD 33             6764             rlc     A
05FE FD             6765             mov     Temp6,A         
05FF D5F0DF         6766             djnz    B, div_u16_by_u16_div2  ;Now count backwards and repeat until "B" is zero
0602 ED             6767             mov     A, Temp6                ; Move result to Temp2/Temp1
0603 F9             6768             mov     Temp2, A   
0604 EC             6769             mov     A, Temp5                
0605 F8             6770             mov     Temp1, A   
0606 22             6771             ret
                    6772     
                    6773     
                    6774     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    6775     ;
                    6776     ; Multiplication 16bit signed by 8bit unsigned
                    6777     ;
                    6778     ; Multiplicand shall be in Temp2/Temp1, multiplicator in Temp3
                    6779     ; Result will be in Temp2/Temp1. Result will divided by 16
                    6780     ;
                    6781     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
0607                6782     mult_s16_by_u8_div_16:
0607 E8             6783             mov     A, Temp1                ; Read input to math registers
0608 89F0           6784             mov     B, Temp2
060A 8A20           6785             mov     Bit_Access, Temp3
060C D2D4           6786             setb    PSW.4           ; Select register bank 2 for math routines
060E F8             6787             mov     Temp1, A                ; Store in math registers
060F A9F0           6788             mov     Temp2, B                
0611 7B00           6789             mov     Temp4, #0               ; Set sign in Temp4 and test sign
0613 30F70B         6790             jnb     B.7, mult_s16_by_u8_positive    
                    6791     
0616 7BFF           6792             mov     Temp4, #0FFh
0618 F4             6793             cpl     A
0619 2401           6794             add     A, #1
061B F8             6795             mov     Temp1, A
061C E9             6796             mov     A, Temp2
061D F4             6797             cpl     A
061E 3400           6798             addc    A, #0
0620 F9             6799             mov     Temp2, A
0621                6800     mult_s16_by_u8_positive:
0621 E8             6801             mov     A, Temp1                ; Multiply LSB with multiplicator
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   111

0622 8520F0         6802             mov     B, Bit_Access
0625 A4             6803             mul     AB
0626 ADF0           6804             mov     Temp6, B                ; Place MSB in Temp6
0628 F8             6805             mov     Temp1, A                ; Place LSB in Temp1 (result)
0629 E9             6806             mov     A, Temp2                ; Multiply MSB with multiplicator
062A 8520F0         6807             mov     B, Bit_Access
062D A4             6808             mul     AB
062E AFF0           6809             mov     Temp8, B                ; Place in Temp8/7
0630 FE             6810             mov     Temp7, A
0631 ED             6811             mov     A, Temp6                ; Add up
0632 2E             6812             add     A, Temp7
0633 F9             6813             mov     Temp2, A
0634 7400           6814             mov     A, #0
0636 3F             6815             addc    A, Temp8
0637 FA             6816             mov     Temp3, A
0638 7C04           6817             mov     Temp5, #4               ; Set number of divisions
063A                6818     mult_s16_by_u8_div_loop:
063A C3             6819             clr     C                       ; Rotate right 
063B EA             6820             mov     A, Temp3
063C 13             6821             rrc     A
063D FA             6822             mov     Temp3, A
063E E9             6823             mov     A, Temp2
063F 13             6824             rrc     A
0640 F9             6825             mov     Temp2, A
0641 E8             6826             mov     A, Temp1
0642 13             6827             rrc     A
0643 F8             6828             mov     Temp1, A
0644 DCF4           6829             djnz    Temp5, mult_s16_by_u8_div_loop
                    6830     
0646 8BF0           6831             mov     B, Temp4                ; Test sign
0648 30F70A         6832             jnb     B.7, mult_s16_by_u8_exit        
                    6833     
064B E8             6834             mov     A, Temp1
064C F4             6835             cpl     A
064D 2401           6836             add     A, #1
064F F8             6837             mov     Temp1, A
0650 E9             6838             mov     A, Temp2
0651 F4             6839             cpl     A
0652 3400           6840             addc    A, #0
0654 F9             6841             mov     Temp2, A
                    6842     
0655                6843     mult_s16_by_u8_exit:
0655 E8             6844             mov     A, Temp1                ; Store output
0656 89F0           6845             mov     B, Temp2
0658 C2D4           6846             clr     PSW.4           ; Select normal register bank
065A F8             6847             mov     Temp1, A                
065B A9F0           6848             mov     Temp2, B
065D 22             6849             ret
                    6850     
                    6851     
                    6852     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    6853     ;
                    6854     ; Calculate governor routines
                    6855     ;
                    6856     ; No assumptions
                    6857     ;
                    6858     ; Governs headspeed based upon the Comm_Period4x variable and pwm
                    6859     ; The governor task is split into several routines in order to distribute processing time
                    6860     ;
                    6861     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    6862     ; First governor routine - calculate governor target
                    6863     IF MODE == 0    ; Main
065E                6864     calc_governor_target:
065E 7882           6865             mov     Temp1, #Pgm_Gov_Mode                    ; Governor mode?
0660 B60402         6866             cjne    @Temp1, #4, governor_speed_check        ; Yes
0663 C1F9           6867             jmp     calc_governor_target_exit               ; No
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   112

                    6868     
0665                6869     governor_speed_check:
                    6870             ; Stop governor for stop RC pulse       
0665 C3             6871             clr     C
0666 E55C           6872             mov     A, New_Rcp                              ; Check RC pulse against stop value
0668 9419           6873             subb    A, #(RCP_MAX/10)                        ; Is pulse below stop value?
066A 401E           6874             jc      governor_deactivate                     ; Yes - deactivate
                    6875     
066C E52D           6876             mov     A, Flags1
066E 5406           6877             anl     A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0670 7018           6878             jnz     governor_deactivate                     ; Deactivate if any startup phase s
                             et
                    6879     
                    6880             ; Skip speed check if governor is already active
0672 206E35         6881             jb      Flags1.GOV_ACTIVE, governor_target_calc
                    6882     
                    6883             ; Check speed (do not run governor for low speeds)
0675 7805           6884             mov     Temp1, #05h                             ; Default high range activation lim
                             it value (~62500 eRPM)
0677 7994           6885             mov     Temp2, #Pgm_Gov_Range
0679 E7             6886             mov     A, @Temp2                                       ; Check if high range (Temp
                             2 has #Pgm_Gov_Range)
067A 14             6887             dec     A
067B 6007           6888             jz      governor_act_lim_set            ; If high range - branch
                    6889     
067D 780A           6890             mov     Temp1, #0Ah                             ; Middle range activation limit val
                             ue (~31250 eRPM)
067F 14             6891             dec     A
0680 6002           6892             jz      governor_act_lim_set            ; If middle range - branch
                    6893             
0682 7812           6894             mov     Temp1, #12h                             ; Low range activation limit value 
                             (~17400 eRPM)
                    6895     
0684                6896     governor_act_lim_set:
0684 C3             6897             clr     C
0685 E541           6898             mov     A, Comm_Period4x_H
0687 98             6899             subb    A, Temp1
0688 401E           6900             jc      governor_activate                       ; If speed above min limit  - run g
                             overnor
                    6901     
068A                6902     governor_deactivate:
068A 306E09         6903             jnb     Flags1.GOV_ACTIVE, governor_first_deactivate_done; This code is executed co
                             ntinuously. Only execute the code below the first time
                    6904      
068D 856462         6905             mov     Pwm_Limit_Spoolup, Pwm_Spoolup_Beg
0690 7569FF         6906             mov     Spoolup_Limit_Cnt, #255
0693 756A01         6907             mov     Spoolup_Limit_Skip, #1                  
                    6908     
0696                6909     governor_first_deactivate_done:
0696 852224         6910             mov     Current_Pwm, Requested_Pwm      ; Set current pwm to requested
0699 E4             6911             clr     A
069A F544           6912             mov     Gov_Target_L, A                 ; Set target to zero
069C F545           6913             mov     Gov_Target_H, A
069E F546           6914             mov     Gov_Integral_L, A                       ; Set integral to zero
06A0 F547           6915             mov     Gov_Integral_H, A
06A2 F548           6916             mov     Gov_Integral_X, A
06A4 C26E           6917             clr     Flags1.GOV_ACTIVE
06A6 8051           6918             jmp     calc_governor_target_exit
                    6919     
06A8                6920     governor_activate:
06A8 D26E           6921             setb    Flags1.GOV_ACTIVE
                    6922     
06AA                6923     governor_target_calc:
                    6924             ; Governor calculations
06AA 7994           6925             mov     Temp2, #Pgm_Gov_Range
06AC E7             6926             mov     A, @Temp2                               ; Check high, middle or low range
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   113

06AD 14             6927             dec     A
06AE 7012           6928             jnz     calc_governor_target_middle
                    6929     
06B0 E523           6930             mov     A, Governor_Req_Pwm             ; Load governor requested pwm
06B2 F4             6931             cpl     A                                       ; Calculate 255-pwm (invert pwm) 
                    6932             ; Calculate comm period target (1 + 2*((255-Requested_Pwm)/256) - 0.25)
06B3 33             6933             rlc     A                                       ; Msb to carry
06B4 33             6934             rlc     A                                       ; To bit0
06B5 F9             6935             mov     Temp2, A                                ; Now 1 lsb is valid for H
06B6 13             6936             rrc     A                                       
06B7 F8             6937             mov     Temp1, A                                ; Now 7 msbs are valid for L
06B8 E9             6938             mov     A, Temp2
06B9 5401           6939             anl     A, #01h                         ; Calculate H byte
06BB 04             6940             inc     A                                       ; Add 1
06BC F9             6941             mov     Temp2, A
06BD E8             6942             mov     A, Temp1
06BE 54FE           6943             anl     A, #0FEh                                ; Calculate L byte
06C0 802B           6944             jmp     calc_governor_subtract_025
                    6945     
06C2                6946     calc_governor_target_middle:
06C2 E7             6947             mov     A, @Temp2                               ; Check middle or low range (Temp2 
                             has #Pgm_Gov_Range)
06C3 14             6948             dec     A
06C4 14             6949             dec     A
06C5 7013           6950             jnz     calc_governor_target_low
                    6951     
06C7 E523           6952             mov     A, Governor_Req_Pwm             ; Load governor requested pwm
06C9 F4             6953             cpl     A                                       ; Calculate 255-pwm (invert pwm) 
                    6954             ; Calculate comm period target (1 + 4*((255-Requested_Pwm)/256))
06CA 33             6955             rlc     A                                       ; Msb to carry
06CB 33             6956             rlc     A                                       ; To bit0
06CC 33             6957             rlc     A                                       ; To bit1
06CD F9             6958             mov     Temp2, A                                ; Now 2 lsbs are valid for H
06CE 13             6959             rrc     A                                       
06CF F8             6960             mov     Temp1, A                                ; Now 6 msbs are valid for L
06D0 E9             6961             mov     A, Temp2
06D1 5403           6962             anl     A, #03h                         ; Calculate H byte
06D3 04             6963             inc     A                                       ; Add 1
06D4 F9             6964             mov     Temp2, A
06D5 E8             6965             mov     A, Temp1
06D6 54FC           6966             anl     A, #0FCh                                ; Calculate L byte
06D8 801B           6967             jmp     calc_governor_store_target
                    6968     
06DA                6969     calc_governor_target_low:
06DA E523           6970             mov     A, Governor_Req_Pwm             ; Load governor requested pwm
06DC F4             6971             cpl     A                                       ; Calculate 255-pwm (invert pwm) 
                    6972             ; Calculate comm period target (2 + 8*((255-Requested_Pwm)/256) - 0.25)
06DD 33             6973             rlc     A                                       ; Msb to carry
06DE 33             6974             rlc     A                                       ; To bit0
06DF 33             6975             rlc     A                                       ; To bit1
06E0 33             6976             rlc     A                                       ; To bit2
06E1 F9             6977             mov     Temp2, A                                ; Now 3 lsbs are valid for H
06E2 13             6978             rrc     A                                       
06E3 F8             6979             mov     Temp1, A                                ; Now 5 msbs are valid for L
06E4 E9             6980             mov     A, Temp2
06E5 5407           6981             anl     A, #07h                         ; Calculate H byte
06E7 04             6982             inc     A                                       ; Add 1
06E8 04             6983             inc     A                                       ; Add 1 more
06E9 F9             6984             mov     Temp2, A
06EA E8             6985             mov     A, Temp1
06EB 54F8           6986             anl     A, #0F8h                                ; Calculate L byte
06ED                6987     calc_governor_subtract_025:
06ED C3             6988             clr     C
06EE 9440           6989             subb    A, #40h                         ; Subtract 0.25
06F0 F8             6990             mov     Temp1, A
06F1 E9             6991             mov     A, Temp2
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   114

06F2 9400           6992             subb    A, #0
06F4 F9             6993             mov     Temp2, A
06F5                6994     calc_governor_store_target:
                    6995             ; Store governor target
06F5 8844           6996             mov     Gov_Target_L, Temp1
06F7 8945           6997             mov     Gov_Target_H, Temp2
06F9                6998     calc_governor_target_exit:
06F9 22             6999             ret                                             
                    7000     ENDIF
                    7001     IF MODE == 1    ; Tail
                             calc_governor_target:
                                     ret                                             
                             ENDIF
                    7005     IF MODE == 2    ; Multi
                             calc_governor_target:
                                     mov     Temp1, #Pgm_Gov_Mode                    ; Closed loop mode?
                                     cjne    @Temp1, #4, governor_target_calc        ; Yes - branch
                                     jmp     calc_governor_target_exit               ; No
                             
                             governor_target_calc:
                                     ; Stop governor for stop RC pulse       
                                     clr     C
                                     mov     A, New_Rcp                              ; Check RC pulse against stop value
                                     subb    A, #RCP_STOP                            ; Is pulse below stop value?
                                     jc      governor_deactivate                     ; Yes - deactivate
                             
                                     jmp     governor_activate                       ; No - activate
                             
                             governor_deactivate:
                                     mov     Current_Pwm, Requested_Pwm      ; Set current pwm to requested
                                     clr     A
                                     mov     Gov_Target_L, A                 ; Set target to zero
                                     mov     Gov_Target_H, A
                                     mov     Gov_Integral_L, A                       ; Set integral to zero
                                     mov     Gov_Integral_H, A
                                     mov     Gov_Integral_X, A
                                     clr     Flags1.GOV_ACTIVE
                                     jmp     calc_governor_target_exit
                             
                             governor_activate:
                                     mov     Temp1, #Pgm_Gov_Mode            ; Store gov mode
                                     mov     A, @Temp1
                                     mov     Temp5, A
                                     setb    Flags1.GOV_ACTIVE
                                     mov     A, Requested_Pwm                        ; Load requested pwm
                                     mov     Governor_Req_Pwm, A                     ; Set governor requested pwm
                                     ; Calculate comm period target 2*(51000/Requested_Pwm)
                                     mov     Temp1, #38h                             ; Load 51000
                                     mov     Temp2, #0C7h
                                     mov     Temp3, Comm_Period4x_L          ; Load comm period
                                     mov     Temp4, Comm_Period4x_H          
                                     ; Set speed range 
                                     clr     C
                                     mov     A, Temp4
                                     rrc     A
                                     mov     Temp4, A
                                     mov     A, Temp3
                                     rrc     A
                                     mov     Temp3, A                                ; 200k eRPM range here
                                     ; Check range
                                     mov     A, Temp5
                                     dec     A
                                     jz      governor_activate_range_set     ; 200k eRPM? - branch
                             governor_activate_100k:
                                     clr     C
                                     mov     A, Temp4
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   115

                                     rrc     A
                                     mov     Temp4, A
                                     mov     A, Temp3
                                     rrc     A
                                     mov     Temp3, A                                ; 100k eRPM range here
                                     mov     A, Temp5                                        ; Check range again
                                     dec     A
                                     dec     A
                                     jz      governor_activate_range_set     ; 100k eRPM? - branch
                             governor_activate_50k:
                                     clr     C
                                     mov     A, Temp4
                                     rrc     A
                                     mov     Temp4, A
                                     mov     A, Temp3
                                     rrc     A
                                     mov     Temp3, A                                ; 50k eRPM range here
                             governor_activate_range_set:
                                     call    div_u16_by_u16
                                     ; Store governor target
                                     mov     Gov_Target_L, Temp1
                                     mov     Gov_Target_H, Temp2
                             calc_governor_target_exit:
                                     ret                                             
                             ENDIF
                    7083     
                    7084     
                    7085     ; Second governor routine - calculate governor proportional error
06FA                7086     calc_governor_prop_error:
                    7087     IF MODE <= 1    ; Main or tail
                    7088             ; Load comm period and divide by 2
06FA C3             7089             clr     C
06FB E541           7090             mov     A, Comm_Period4x_H
06FD 13             7091             rrc     A
06FE F9             7092             mov     Temp2, A
06FF E540           7093             mov     A, Comm_Period4x_L
0701 13             7094             rrc     A
0702 F8             7095             mov     Temp1, A
                    7096             ; Calculate error
0703 C3             7097             clr     C
0704 E544           7098             mov     A, Gov_Target_L
0706 98             7099             subb    A, Temp1
0707 F8             7100             mov     Temp1, A
0708 E545           7101             mov     A, Gov_Target_H
070A 99             7102             subb    A, Temp2
070B F9             7103             mov     Temp2, A
                    7104     ENDIF
                    7105     IF MODE == 2    ; Multi
                                     ; Calculate error
                                     clr     C
                                     mov     A, Gov_Target_L
                                     subb    A, Governor_Req_Pwm
                                     mov     Temp1, A
                                     mov     A, Gov_Target_H
                                     subb    A, #0
                                     mov     Temp2, A
                             ENDIF
                    7115             ; Check error and limit
070C 500B           7116             jnc     governor_check_prop_limit_pos   ; Check carry
                    7117     
070E C3             7118             clr     C
070F E8             7119             mov     A, Temp1
0710 9480           7120             subb    A, #80h                                 ; Is error too negative?
0712 E9             7121             mov     A, Temp2
0713 94FF           7122             subb    A, #0FFh
0715 4013           7123             jc      governor_limit_prop_error_neg   ; Yes - limit
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   116

0717 8015           7124             jmp     governor_store_prop_error
                    7125     
0719                7126     governor_check_prop_limit_pos:
0719 C3             7127             clr     C
071A E8             7128             mov     A, Temp1
071B 947F           7129             subb    A, #7Fh                                 ; Is error too positive?
071D E9             7130             mov     A, Temp2
071E 9400           7131             subb    A, #00h
0720 5002           7132             jnc     governor_limit_prop_error_pos   ; Yes - limit
0722 800A           7133             jmp     governor_store_prop_error
                    7134     
0724                7135     governor_limit_prop_error_pos:
0724 787F           7136             mov     Temp1, #7Fh                             ; Limit to max positive (2's comple
                             ment)
0726 7900           7137             mov     Temp2, #00h
0728 8004           7138             jmp     governor_store_prop_error
                    7139     
072A                7140     governor_limit_prop_error_neg:
072A 7880           7141             mov     Temp1, #80h                             ; Limit to max negative (2's comple
                             ment)
072C 79FF           7142             mov     Temp2, #0FFh
                    7143     
072E                7144     governor_store_prop_error:
                    7145             ; Store proportional
072E 8849           7146             mov     Gov_Proportional_L, Temp1
0730 894A           7147             mov     Gov_Proportional_H, Temp2
0732                7148     calc_governor_prop_error_exit:
0732 22             7149             ret                                             
                    7150     
                    7151     
                    7152     ; Third governor routine - calculate governor integral error
0733                7153     calc_governor_int_error:
                    7154             ; Add proportional to integral
0733 E549           7155             mov     A, Gov_Proportional_L
0735 2546           7156             add     A, Gov_Integral_L
0737 F8             7157             mov     Temp1, A
0738 E54A           7158             mov     A, Gov_Proportional_H
073A 3547           7159             addc    A, Gov_Integral_H
073C F9             7160             mov     Temp2, A
073D 854A20         7161             mov     Bit_Access, Gov_Proportional_H          ; Sign extend high byte
0740 E4             7162             clr     A
0741 300701         7163             jnb     Bit_Access.7, ($+4)                     
0744 F4             7164             cpl     A
0745 3548           7165             addc    A, Gov_Integral_X
0747 FA             7166             mov     Temp3, A
                    7167             ; Check integral and limit
0748 30E708         7168             jnb     ACC.7, governor_check_int_limit_pos     ; Check sign bit
                    7169     
074B C3             7170             clr     C
074C EA             7171             mov     A, Temp3
074D 94F0           7172             subb    A, #0F0h                                        ; Is error too negative?
074F 4012           7173             jc      governor_limit_int_error_neg    ; Yes - limit
0751 8016           7174             jmp     governor_check_pwm
                    7175     
0753                7176     governor_check_int_limit_pos:
0753 C3             7177             clr     C
0754 EA             7178             mov     A, Temp3
0755 940F           7179             subb    A, #0Fh                                 ; Is error too positive?
0757 5002           7180             jnc     governor_limit_int_error_pos    ; Yes - limit
0759 800E           7181             jmp     governor_check_pwm
                    7182     
075B                7183     governor_limit_int_error_pos:
075B 78FF           7184             mov     Temp1, #0FFh                            ; Limit to max positive (2's comple
                             ment)
075D 79FF           7185             mov     Temp2, #0FFh
075F 7A0F           7186             mov     Temp3, #0Fh
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   117

0761 8006           7187             jmp     governor_check_pwm
                    7188     
0763                7189     governor_limit_int_error_neg:
0763 7800           7190             mov     Temp1, #00h                             ; Limit to max negative (2's comple
                             ment)
0765 7900           7191             mov     Temp2, #00h
0767 7AF0           7192             mov     Temp3, #0F0h
                    7193     
0769                7194     governor_check_pwm:
                    7195             ; Check current pwm
0769 C3             7196             clr     C
076A E524           7197             mov     A, Current_Pwm
076C 9561           7198             subb    A, Pwm_Limit                            ; Is current pwm at or above pwm li
                             mit?
076E 5009           7199             jnc     governor_int_max_pwm            ; Yes - branch
                    7200     
0770 C3             7201             clr     C
0771 7401           7202             mov     A, #1
0773 9524           7203             subb    A, Current_Pwm                          ; Is current pwm at minimum?
0775 5009           7204             jnc     governor_int_min_pwm            ; Yes - branch
                    7205     
0777 800C           7206             jmp     governor_store_int_error                ; No - store integral error
                    7207     
0779                7208     governor_int_max_pwm:
0779 E54A           7209             mov     A, Gov_Proportional_H
077B 20E70D         7210             jb      ACC.7, calc_governor_int_error_exit     ; Is proportional error negative - 
                             branch (high byte is always zero)
                    7211     
077E 8005           7212             jmp     governor_store_int_error                ; Positive - store integral error
                    7213     
0780                7214     governor_int_min_pwm:
0780 E54A           7215             mov     A, Gov_Proportional_H
0782 30E706         7216             jnb     ACC.7, calc_governor_int_error_exit     ; Is proportional error positive - 
                             branch (high byte is always zero)
                    7217     
0785                7218     governor_store_int_error:
                    7219             ; Store integral
0785 8846           7220             mov     Gov_Integral_L, Temp1
0787 8947           7221             mov     Gov_Integral_H, Temp2
0789 8A48           7222             mov     Gov_Integral_X, Temp3
078B                7223     calc_governor_int_error_exit:
078B 22             7224             ret                                             
                    7225     
                    7226     
                    7227     ; Fourth governor routine - calculate governor proportional correction
078C                7228     calc_governor_prop_correction:
                    7229             ; Load proportional gain
078C 78A5           7230             mov     Temp1, #Pgm_Gov_P_Gain_Decoded; Load proportional gain
078E E6             7231             mov     A, @Temp1                               
078F FA             7232             mov     Temp3, A                                        ; Store in Temp3
                    7233             ; Load proportional
0790 C3             7234             clr     C
0791 E549           7235             mov     A, Gov_Proportional_L           ; Nominal multiply by 2
0793 33             7236             rlc     A
0794 F8             7237             mov     Temp1, A
0795 E54A           7238             mov     A, Gov_Proportional_H
0797 33             7239             rlc     A
0798 F9             7240             mov     Temp2, A
                    7241             ; Apply gain
0799 D107           7242             call    mult_s16_by_u8_div_16
                    7243             ; Check error and limit (to low byte)
079B E9             7244             mov     A, Temp2
079C 30E70B         7245             jnb     ACC.7, governor_check_prop_corr_limit_pos       ; Check sign bit
                    7246     
079F C3             7247             clr     C
07A0 E8             7248             mov     A, Temp1
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   118

07A1 9480           7249             subb    A, #80h                                 ; Is error too negative?
07A3 E9             7250             mov     A, Temp2
07A4 94FF           7251             subb    A, #0FFh
07A6 4013           7252             jc      governor_limit_prop_corr_neg    ; Yes - limit
07A8 E1BF           7253             ajmp    governor_apply_prop_corr
                    7254     
07AA                7255     governor_check_prop_corr_limit_pos:
07AA C3             7256             clr     C
07AB E8             7257             mov     A, Temp1
07AC 947F           7258             subb    A, #7Fh                                 ; Is error too positive?
07AE E9             7259             mov     A, Temp2
07AF 9400           7260             subb    A, #00h
07B1 5002           7261             jnc     governor_limit_prop_corr_pos    ; Yes - limit
07B3 E1BF           7262             ajmp    governor_apply_prop_corr
                    7263     
07B5                7264     governor_limit_prop_corr_pos:
07B5 787F           7265             mov     Temp1, #7Fh                             ; Limit to max positive (2's comple
                             ment)
07B7 7900           7266             mov     Temp2, #00h
07B9 E1BF           7267             ajmp    governor_apply_prop_corr
                    7268     
07BB                7269     governor_limit_prop_corr_neg:
07BB 7880           7270             mov     Temp1, #80h                             ; Limit to max negative (2's comple
                             ment)
07BD 79FF           7271             mov     Temp2, #0FFh
                    7272     
07BF                7273     governor_apply_prop_corr:
                    7274             ; Test proportional sign
07BF E8             7275             mov     A, Temp1
07C0 20E713         7276             jb      ACC.7, governor_corr_neg_prop   ; If proportional negative - go to correct 
                             negative
                    7277     
                    7278             ; Subtract positive proportional
07C3 C3             7279             clr     C
07C4 E523           7280             mov     A, Governor_Req_Pwm
07C6 98             7281             subb    A, Temp1
07C7 F8             7282             mov     Temp1, A
                    7283             ; Check result
07C8 4008           7284             jc      governor_corr_prop_min_pwm      ; Is result negative?
                    7285     
07CA C3             7286             clr     C
07CB E8             7287             mov     A, Temp1                                        ; Is result below pwm min?
07CC 9401           7288             subb    A, #1
07CE 4002           7289             jc      governor_corr_prop_min_pwm      ; Yes
07D0 8011           7290             jmp     governor_store_prop_corr                ; No - store proportional correction
                    7291     
07D2                7292     governor_corr_prop_min_pwm:
07D2 7801           7293             mov     Temp1, #1                                       ; Load minimum pwm
07D4 800D           7294             jmp     governor_store_prop_corr
                    7295     
07D6                7296     governor_corr_neg_prop:
                    7297             ; Add negative proportional
07D6 E8             7298             mov     A, Temp1
07D7 F4             7299             cpl     A
07D8 2401           7300             add     A, #1
07DA 2523           7301             add     A, Governor_Req_Pwm
07DC F8             7302             mov     Temp1, A
                    7303             ; Check result
07DD 4002           7304             jc      governor_corr_prop_max_pwm      ; Is result above max?
07DF 8002           7305             jmp     governor_store_prop_corr                ; No - store proportional correction
                    7306     
07E1                7307     governor_corr_prop_max_pwm:
07E1 78FF           7308             mov     Temp1, #255                             ; Load maximum pwm
07E3                7309     governor_store_prop_corr:
                    7310             ; Store proportional pwm
07E3 884B           7311             mov     Gov_Prop_Pwm, Temp1
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   119

07E5                7312     calc_governor_prop_corr_exit:
07E5 22             7313             ret
                    7314     
                    7315     
                    7316     ; Fifth governor routine - calculate governor integral correction
07E6                7317     calc_governor_int_correction:
                    7318             ; Load integral gain
07E6 78A6           7319             mov     Temp1, #Pgm_Gov_I_Gain_Decoded; Load integral gain
07E8 E6             7320             mov     A, @Temp1                               
07E9 FA             7321             mov     Temp3, A                                        ; Store in Temp3
                    7322             ; Load integral
07EA A847           7323             mov     Temp1, Gov_Integral_H
07EC A948           7324             mov     Temp2, Gov_Integral_X
                    7325             ; Apply gain
07EE D107           7326             call    mult_s16_by_u8_div_16
                    7327             ; Check integral and limit
07F0 E9             7328             mov     A, Temp2
07F1 30E70B         7329             jnb     ACC.7, governor_check_int_corr_limit_pos        ; Check sign bit
                    7330     
07F4 C3             7331             clr     C
07F5 E8             7332             mov     A, Temp1
07F6 9401           7333             subb    A, #01h                                 ; Is integral too negative?
07F8 E9             7334             mov     A, Temp2
07F9 94FF           7335             subb    A, #0FFh
07FB 4013           7336             jc      governor_limit_int_corr_neg     ; Yes - limit
07FD 8015           7337             jmp     governor_apply_int_corr
                    7338     
07FF                7339     governor_check_int_corr_limit_pos:
07FF C3             7340             clr     C
0800 E8             7341             mov     A, Temp1
0801 94FF           7342             subb    A, #0FFh                                        ; Is integral too positive?
0803 E9             7343             mov     A, Temp2
0804 9400           7344             subb    A, #00h
0806 5002           7345             jnc     governor_limit_int_corr_pos     ; Yes - limit
0808 800A           7346             jmp     governor_apply_int_corr
                    7347     
080A                7348     governor_limit_int_corr_pos:
080A 78FF           7349             mov     Temp1, #0FFh                            ; Limit to max positive (2's comple
                             ment)
080C 7900           7350             mov     Temp2, #00h
080E 8004           7351             jmp     governor_apply_int_corr
                    7352     
0810                7353     governor_limit_int_corr_neg:
0810 7801           7354             mov     Temp1, #01h                             ; Limit to max negative (2's comple
                             ment)
0812 79FF           7355             mov     Temp2, #0FFh
                    7356     
0814                7357     governor_apply_int_corr:
                    7358             ; Test integral sign
0814 E9             7359             mov     A, Temp2
0815 20E713         7360             jb      ACC.7, governor_corr_neg_int    ; If integral negative - go to correct nega
                             tive
                    7361     
                    7362             ; Subtract positive integral
0818 C3             7363             clr     C
0819 E54B           7364             mov     A, Gov_Prop_Pwm
081B 98             7365             subb    A, Temp1
081C F8             7366             mov     Temp1, A
                    7367             ; Check result
081D 4008           7368             jc      governor_corr_int_min_pwm       ; Is result negative?
                    7369     
081F C3             7370             clr     C
0820 E8             7371             mov     A, Temp1                                        ; Is result below pwm min?
0821 9401           7372             subb    A, #1
0823 4002           7373             jc      governor_corr_int_min_pwm       ; Yes
0825 8011           7374             jmp     governor_store_int_corr         ; No - store correction
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   120

                    7375     
0827                7376     governor_corr_int_min_pwm:
0827 7801           7377             mov     Temp1, #1                                       ; Load minimum pwm
0829 800D           7378             jmp     governor_store_int_corr
                    7379     
082B                7380     governor_corr_neg_int:
                    7381             ; Add negative integral
082B E8             7382             mov     A, Temp1
082C F4             7383             cpl     A
082D 2401           7384             add     A, #1
082F 254B           7385             add     A, Gov_Prop_Pwm
0831 F8             7386             mov     Temp1, A
                    7387             ; Check result
0832 4002           7388             jc      governor_corr_int_max_pwm       ; Is result above max?
0834 8002           7389             jmp     governor_store_int_corr         ; No - store correction
                    7390     
0836                7391     governor_corr_int_max_pwm:
0836 78FF           7392             mov     Temp1, #255                             ; Load maximum pwm
0838                7393     governor_store_int_corr:
                    7394             ; Store current pwm
0838 8824           7395             mov     Current_Pwm, Temp1
083A                7396     calc_governor_int_corr_exit:
083A 22             7397             ret
                    7398     
                    7399     
                    7400     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    7401     ;
                    7402     ; Set pwm limit low rpm
                    7403     ;
                    7404     ; No assumptions
                    7405     ;
                    7406     ; Sets power limit for low rpms and disables demag for low rpms
                    7407     ;
                    7408     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
083B                7409     set_pwm_limit_low_rpm:
                    7410             ; Set pwm limit and demag disable for low rpms
083B 78FF           7411             mov     Temp1, #0FFh                                    ; Default full power
083D 206928         7412             jb      Flags1.STARTUP_PHASE, set_pwm_limit_low_rpm_exit        ; Exit if startup p
                             hase set
                    7413     
0840 79A1           7414             mov     Temp2, #Pgm_Enable_Power_Prot           ; Check if low RPM power protection
                              is enabled
0842 E7             7415             mov     A, @Temp2
0843 6023           7416             jz      set_pwm_limit_low_rpm_exit              ; Exit if disabled
                    7417     
0845 E541           7418             mov     A, Comm_Period4x_H
0847 601F           7419             jz      set_pwm_limit_low_rpm_exit              ; Avoid divide by zero
                    7420     
0849 74FF           7421             mov     A, #255                                         ; Divide 255 by Comm_Period
                             4x_H
084B 8541F0         7422             mov     B, Comm_Period4x_H
084E 84             7423             div     AB
084F 8539F0         7424             mov     B, Low_Rpm_Pwr_Slope                    ; Multiply by slope
0852 306A03         7425             jnb     Flags1.INITIAL_RUN_PHASE, ($+6) ; More protection for initial run phase 
0855 75F005         7426             mov     B, #5
0858 A4             7427             mul     AB
0859 F8             7428             mov     Temp1, A                                                ; Set new limit    
                                                  
085A C5F0           7429             xch     A, B
085C 6002           7430             jz      ($+4)                                           ; Limit to max
                    7431             
085E 78FF           7432             mov     Temp1, #0FFh                            
                    7433     
0860 C3             7434             clr     C
0861 E8             7435             mov     A, Temp1                                                ; Limit to min
0862 9564           7436             subb    A, Pwm_Spoolup_Beg
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   121

0864 5002           7437             jnc     set_pwm_limit_low_rpm_exit
                    7438     
0866 A864           7439             mov     Temp1, Pwm_Spoolup_Beg                          
                    7440     
0868                7441     set_pwm_limit_low_rpm_exit:
0868 8863           7442             mov     Pwm_Limit_By_Rpm, Temp1
086A 22             7443             ret
                    7444             
                    7445     
                    7446     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    7447     ;
                    7448     ; Set pwm limit high rpm
                    7449     ;
                    7450     ; No assumptions
                    7451     ;
                    7452     ; Sets power limit for high rpms
                    7453     ;
                    7454     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
086B                7455     set_pwm_limit_high_rpm:
                    7456     IF MCU_48MHZ == 1
                                     clr     C
                                     mov     A, Comm_Period4x_L
                                     subb    A, #0C8h                                ; Limit Comm_Period to 200, which i
                             s 400k erpm
                                     mov     A, Comm_Period4x_H
                                     subb    A, #00h
                             ELSE
086B C3             7463             clr     C
086C E540           7464             mov     A, Comm_Period4x_L
086E 9440           7465             subb    A, #40h                         ; Limit Comm_Period to 320, which is 250k e
                             rpm
0870 E541           7466             mov     A, Comm_Period4x_H
0872 9401           7467             subb    A, #01h
                    7468     ENDIF
0874 E563           7469             mov     A, Pwm_Limit_By_Rpm
0876 5003           7470             jnc     set_pwm_limit_high_rpm_inc_limit
                    7471             
0878 14             7472             dec     A
0879 017C           7473             ajmp    set_pwm_limit_high_rpm_store
                    7474             
087B                7475     set_pwm_limit_high_rpm_inc_limit:
087B 04             7476             inc     A
087C                7477     set_pwm_limit_high_rpm_store:
087C 6002           7478             jz      ($+4)
                    7479     
087E F563           7480             mov     Pwm_Limit_By_Rpm, A
                    7481     
0880 22             7482             ret
                    7483     
                    7484     
                    7485     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    7486     ;
                    7487     ; Measure lipo cells
                    7488     ;
                    7489     ; No assumptions
                    7490     ;
                    7491     ; Measure voltage and calculate lipo cells
                    7492     ;
                    7493     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
0881                7494     measure_lipo_cells:
                    7495     IF MODE >= 1    ; Tail or multi
                                     ; If not supported, then exit
                                     jmp     measure_lipo_exit
                             ENDIF
                    7499     IF MODE == 0    ; Main
                    7500             ; Load programmed low voltage limit
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   122

0881 7883           7501             mov     Temp1, #Pgm_Low_Voltage_Lim     ; Load limit
0883 E6             7502             mov     A, @Temp1                               
0884 F520           7503             mov     Bit_Access, A                           ; Store in Bit_Access
                    7504             ; Set commutation to BpFET on
0886 D1F0           7505             call    comm5comm6                      
                    7506             ; Start adc
                    7507             Start_Adc 
                    7509             ; Wait for ADC reference to settle, and then start again
088B 120549         7510             call    wait1ms
                    7511             Start_Adc
                    7513             ; Wait for ADC conversion to complete
0891                7514     measure_lipo_wait_adc:
0891 30EDFD         7515             jnb     AD0INT, measure_lipo_wait_adc
                    7516             ; Read ADC result
                    7517             Read_Adc_Result
                    7520             ; Stop ADC
                    7521             Stop_Adc
                    7522             ; Switch power off
0898 F192           7523             call    switch_power_off                
                    7524             ; Set limit step
089A 756E55         7525             mov     Lipo_Adc_Limit_L, #ADC_LIMIT_L
089D 756F00         7526             mov     Lipo_Adc_Limit_H, #ADC_LIMIT_H
08A0 C3             7527             clr     C
08A1 7400           7528             mov     A, #ADC_LIMIT_H         ; Divide 3.0V value by 2
08A3 13             7529             rrc     A
08A4 FD             7530             mov     Temp6, A
08A5 7455           7531             mov     A, #ADC_LIMIT_L
08A7 6065           7532             jz      measure_lipo_exit               ; Exit if disabled
                    7533     
08A9 13             7534             rrc     A
08AA FC             7535             mov     Temp5, A
08AB 7455           7536             mov     A, #ADC_LIMIT_L         ; Calculate 1.5*3.0V=4.5V value
08AD 2C             7537             add     A, Temp5
08AE FC             7538             mov     Temp5, A
08AF 7400           7539             mov     A, #ADC_LIMIT_H         
08B1 3D             7540             addc    A, Temp6
08B2 FD             7541             mov     Temp6, A
08B3 EC             7542             mov     A, Temp5                                ; Copy step
08B4 FA             7543             mov     Temp3, A
08B5 ED             7544             mov     A, Temp6        
08B6 FB             7545             mov     Temp4, A
08B7                7546     measure_lipo_cell_loop:
                    7547             ; Check voltage against xS lower limit
08B7 C3             7548             clr     C
08B8 E8             7549             mov     A, Temp1
08B9 9A             7550             subb    A, Temp3                                ; Voltage above limit?
08BA E9             7551             mov     A, Temp2
08BB 9B             7552             subb A, Temp4
08BC 4014           7553             jc      measure_lipo_adjust             ; No - branch
                    7554     
                    7555             ; Set xS voltage limit
08BE E56E           7556             mov     A, Lipo_Adc_Limit_L             
08C0 2455           7557             add     A, #ADC_LIMIT_L
08C2 F56E           7558             mov     Lipo_Adc_Limit_L, A
08C4 E56F           7559             mov     A, Lipo_Adc_Limit_H             
08C6 3400           7560             addc    A, #ADC_LIMIT_H
08C8 F56F           7561             mov     Lipo_Adc_Limit_H, A
                    7562             ; Set (x+1)S lower limit
08CA EA             7563             mov     A, Temp3
08CB 2C             7564             add     A, Temp5                                ; Add step
08CC FA             7565             mov     Temp3, A
08CD EB             7566             mov     A, Temp4
08CE 3D             7567             addc    A, Temp6
08CF FB             7568             mov     Temp4, A
08D0 80E5           7569             jmp     measure_lipo_cell_loop  ; Check for one more battery cell
                    7570     
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   123

08D2                7571     measure_lipo_adjust:
08D2 AE6E           7572             mov     Temp7, Lipo_Adc_Limit_L
08D4 AF6F           7573             mov     Temp8, Lipo_Adc_Limit_H
                    7574             ; Calculate 3.125%
08D6 C3             7575             clr     C
08D7 E56F           7576             mov     A, Lipo_Adc_Limit_H
08D9 13             7577             rrc     A
08DA F9             7578             mov     Temp2, A
08DB E56E           7579             mov     A, Lipo_Adc_Limit_L     
08DD 13             7580             rrc     A
08DE F8             7581             mov     Temp1, A                        ; After this 50%
08DF C3             7582             clr     C
08E0 E9             7583             mov     A, Temp2
08E1 13             7584             rrc     A
08E2 F9             7585             mov     Temp2, A
08E3 E8             7586             mov     A, Temp1        
08E4 13             7587             rrc     A
08E5 F8             7588             mov     Temp1, A                        ; After this 25%
                    7589             ; Divide three times to get to 3.125%
08E6 7A03           7590             mov     Temp3, #3
08E8                7591     measure_lipo_divide_loop:
08E8 C3             7592             clr     C
08E9 E9             7593             mov     A, Temp2
08EA 13             7594             rrc     A
08EB F9             7595             mov     Temp2, A
08EC E8             7596             mov     A, Temp1        
08ED 13             7597             rrc     A
08EE F8             7598             mov     Temp1, A                        
08EF DAF7           7599             djnz    Temp3, measure_lipo_divide_loop
                    7600     
                    7601             ; Add the programmed number of 0.1V (or 3.125% increments)
08F1 AA20           7602             mov     Temp3, Bit_Access               ; Load programmed limit (Bit_Access has Pgm
                             _Low_Voltage_Lim)
08F3 1A             7603             dec     Temp3
08F4 7008           7604             jnz     measure_lipo_limit_on   ; Is low voltage limiting on?
                    7605     
08F6 756E00         7606             mov     Lipo_Adc_Limit_L, #0    ; No - set limit to zero
08F9 756F00         7607             mov     Lipo_Adc_Limit_H, #0
08FC 8010           7608             jmp     measure_lipo_exit       
                    7609     
08FE                7610     measure_lipo_limit_on:
08FE 1A             7611             dec     Temp3
08FF EA             7612             mov     A, Temp3
0900 6008           7613             jz      measure_lipo_update
                    7614     
0902                7615     measure_lipo_add_loop:
0902 EE             7616             mov     A, Temp7                        ; Add 3.125%
0903 28             7617             add     A, Temp1
0904 FE             7618             mov     Temp7, A
0905 EF             7619             mov     A, Temp8
0906 39             7620             addc    A, Temp2
0907 FF             7621             mov     Temp8, A
0908 DAF8           7622             djnz    Temp3, measure_lipo_add_loop
                    7623     
090A                7624     measure_lipo_update:
                    7625             ; Set ADC limit
090A 8E6E           7626             mov     Lipo_Adc_Limit_L, Temp7
090C 8F6F           7627             mov     Lipo_Adc_Limit_H, Temp8
                    7628     ENDIF
090E                7629     measure_lipo_exit:
090E 22             7630             ret
                    7631     
                    7632     
                    7633     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    7634     ;
                    7635     ; Start ADC conversion
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   124

                    7636     ;
                    7637     ; No assumptions
                    7638     ;
                    7639     ; Start conversion used for measuring power supply voltage
                    7640     ;
                    7641     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
090F                7642     start_adc_conversion:
                    7643             ; Start adc
                    7644             Start_Adc 
0912 22             7646             ret
                    7647     
                    7648     
                    7649     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    7650     ;
                    7651     ; Check temperature, power supply voltage and limit power
                    7652     ;
                    7653     ; No assumptions
                    7654     ;
                    7655     ; Used to limit main motor power in order to maintain the required voltage
                    7656     ;
                    7657     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
0913                7658     check_temp_voltage_and_limit_power:
                    7659             ; Load programmed low voltage limit
0913 7883           7660             mov     Temp1, #Pgm_Low_Voltage_Lim     
0915 E6             7661             mov     A, @Temp1
0916 FF             7662             mov     Temp8, A                                        ; Store in Temp8           
                                  
                    7663             ; Wait for ADC conversion to complete
0917 30EDF9         7664             jnb     AD0INT, check_temp_voltage_and_limit_power
                    7665             ; Read ADC result
                    7666             Read_Adc_Result
                    7669             ; Stop ADC
                    7670             Stop_Adc
                    7671     
091E 0570           7672             inc     Adc_Conversion_Cnt                      ; Increment conversion counter
0920 C3             7673             clr     C
0921 E570           7674             mov     A, Adc_Conversion_Cnt           ; Is conversion count equal to temp rate?
0923 9408           7675             subb    A, #TEMP_CHECK_RATE
0925 404F           7676             jc      check_voltage_start                     ; No - check voltage
                    7677     
0927 757000         7678             mov     Adc_Conversion_Cnt, #0          ; Yes - temperature check. Reset counter
092A E9             7679             mov     A, Temp2                                        ; Move ADC MSB to Temp3
092B FA             7680             mov     Temp3, A
092C 79A0           7681             mov     Temp2, #Pgm_Enable_Temp_Prot    ; Is temp protection enabled?
092E E7             7682             mov     A, @Temp2
092F 6041           7683             jz      temp_check_exit                 ; No - branch
                    7684     
0931 EA             7685             mov     A, Temp3                                        ; Is temperature reading be
                             low 256?
0932 7006           7686             jnz     temp_average_inc_dec            ; No - proceed
                    7687     
0934 E571           7688             mov     A, Current_Average_Temp         ; Yes -  decrement average
0936 6018           7689             jz      temp_average_updated            ; Already zero - no change
0938 800C           7690             jmp     temp_average_dec                        ; Decrement 
                    7691     
093A                7692     temp_average_inc_dec:
093A C3             7693             clr     C
093B E8             7694             mov     A, Temp1                                        ; Check if current temperat
                             ure is above or below average
093C 9571           7695             subb    A, Current_Average_Temp
093E 600E           7696             jz      temp_average_updated_load_acc   ; Equal - no change
                    7697     
0940 E571           7698             mov     A, Current_Average_Temp         ; Above - increment average
0942 5005           7699             jnc     temp_average_inc                                
                    7700     
0944 600A           7701             jz      temp_average_updated            ; Below - decrement average if average is n
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   125

                             ot already zero
0946                7702     temp_average_dec:
0946 14             7703             dec     A                                               ; Decrement average
0947 8007           7704             jmp     temp_average_updated
                    7705     
0949                7706     temp_average_inc:
0949 04             7707             inc     A                                               ; Increment average
094A 60FA           7708             jz      temp_average_dec
094C 8002           7709             jmp     temp_average_updated
                    7710     
094E                7711     temp_average_updated_load_acc:
094E E571           7712             mov     A, Current_Average_Temp
0950                7713     temp_average_updated:
0950 F571           7714             mov     Current_Average_Temp, A
0952 C3             7715             clr     C
0953 9467           7716             subb    A, #TEMP_LIMIT                          ; Is temperature below first limit?
0955 401B           7717             jc      temp_check_exit                 ; Yes - exit
                    7718     
0957 7561C0         7719             mov  Pwm_Limit, #192                    ; No - limit pwm
                    7720     
095A C3             7721             clr     C
095B 9404           7722             subb    A, #TEMP_LIMIT_STEP                     ; Is temperature below second limit
095D 4013           7723             jc      temp_check_exit                 ; Yes - exit
                    7724     
095F 756180         7725             mov  Pwm_Limit, #128                    ; No - limit pwm
                    7726     
0962 C3             7727             clr     C
0963 9404           7728             subb    A, #TEMP_LIMIT_STEP                     ; Is temperature below third limit
0965 400B           7729             jc      temp_check_exit                 ; Yes - exit
                    7730     
0967 756140         7731             mov  Pwm_Limit, #64                             ; No - limit pwm
                    7732     
096A C3             7733             clr     C
096B 9404           7734             subb    A, #TEMP_LIMIT_STEP                     ; Is temperature below final limit
096D 4003           7735             jc      temp_check_exit                 ; Yes - exit
                    7736     
096F 756100         7737             mov  Pwm_Limit, #0                              ; No - limit pwm
                    7738     
0972                7739     temp_check_exit:
                    7740             Set_Adc_Ip_Volt                         ; Select adc input for next conversion
0975 22             7742             ret
                    7743     
0976                7744     check_voltage_start:
                    7745     IF MODE == 0    ; Main 
                    7746             ; Check if low voltage limiting is enabled
0976 EF             7747             mov     A, Temp8
0977 C3             7748             clr     C
0978 9401           7749             subb    A, #1                                   ; Is low voltage limit disabled?
097A 601E           7750             jz      check_voltage_good                      ; Yes - voltage declared good
                    7751     
097C 7455           7752             mov     A, #ADC_LIMIT_L                 ; Is low voltage limit zero (ESC does not s
                             upport it)?
097E 601A           7753             jz      check_voltage_good                      ; Yes - voltage declared good
                    7754     
                    7755             ; Check if ADC is saturated
0980 C3             7756             clr     C
0981 E8             7757             mov     A, Temp1
0982 94FF           7758             subb    A, #0FFh
0984 E9             7759             mov     A, Temp2
0985 9403           7760             subb    A, #03h
0987 5011           7761             jnc     check_voltage_good                      ; ADC saturated, can not make judge
                             ment
                    7762     
                    7763             ; Check voltage against limit
0989 C3             7764             clr     C
098A E8             7765             mov     A, Temp1
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   126

098B 956E           7766             subb    A, Lipo_Adc_Limit_L
098D E9             7767             mov     A, Temp2
098E 956F           7768             subb    A, Lipo_Adc_Limit_H
0990 5008           7769             jnc     check_voltage_good                      ; If voltage above limit - branch
                    7770     
                    7771             ; Decrease pwm limit
0992 E561           7772             mov  A, Pwm_Limit
0994 600B           7773             jz      check_voltage_lim                       ; If limit zero - branch
                    7774     
0996 1561           7775             dec     Pwm_Limit                                       ; Decrement limit
0998 8007           7776             jmp     check_voltage_lim
                    7777     
099A                7778     check_voltage_good:
                    7779             ; Increase pwm limit
099A E561           7780             mov  A, Pwm_Limit
099C F4             7781             cpl     A                       
099D 6002           7782             jz      check_voltage_lim                       ; If limit max - branch
                    7783     
099F 0561           7784             inc     Pwm_Limit                                       ; Increment limit
                    7785     
09A1                7786     check_voltage_lim:
09A1 A861           7787             mov     Temp1, Pwm_Limit                        ; Set limit
09A3 C3             7788             clr     C
09A4 E524           7789             mov     A, Current_Pwm
09A6 98             7790             subb    A, Temp1
09A7 5002           7791             jnc     check_voltage_spoolup_lim       ; If current pwm above limit - branch and l
                             imit 
                    7792     
09A9 A824           7793             mov     Temp1, Current_Pwm                      ; Set current pwm (no limiting)
                    7794     
09AB                7795     check_voltage_spoolup_lim:
                    7796             ; Slow spoolup
09AB C3             7797             clr     C
09AC E8             7798             mov     A, Temp1
09AD 9562           7799             subb    A, Pwm_Limit_Spoolup
09AF 400A           7800             jc      check_voltage_exit                      ; If current pwm below limit - bran
                             ch   
                    7801     
09B1 A862           7802             mov     Temp1, Pwm_Limit_Spoolup
09B3 E562           7803             mov     A, Pwm_Limit_Spoolup            ; Check if spoolup limit is max
09B5 F4             7804             cpl     A
09B6 6003           7805             jz      check_voltage_exit                      ; If max - branch
                    7806      
09B8 856261         7807             mov     Pwm_Limit, Pwm_Limit_Spoolup    ; Set pwm limit to spoolup limit during ram
                             p (to avoid governor integral buildup)
                    7808     
09BB                7809     check_voltage_exit:
09BB 8825           7810             mov  Current_Pwm_Limited, Temp1
09BD 8826           7811             mov     Current_Pwm_Lim_Dith, Temp1
                    7812     ENDIF
                    7813     IF MODE == 1    ; Tail
                                     ; Increase pwm limit
                                     mov  A, Pwm_Limit
                                     cpl     A                       
                                     jz      check_voltage_lim                       ; If limit max - branch
                             
                                     inc     Pwm_Limit                                       ; Increment limit
                             
                             check_voltage_lim:
                             ENDIF
                    7823     IF MODE == 2    ; Multi
                                     ; Increase pwm limit
                                     mov  A, Pwm_Limit
                                     add     A, #16                  
                                     jnc     ($+4)                                   ; If not max - branch
                             
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   127

                                     mov     A, #255
                             
                                     mov     Pwm_Limit, A                            ; Increment limit 
                                     ; Set current pwm limited if closed loop mode
                                     mov     Temp2, #Pgm_Gov_Mode            ; Governor mode?
                                     cjne    @Temp2, #4, ($+5)                       
                                     ajmp    check_voltage_pwm_done          ; No - branch
                             
                                     clr     C
                                     mov     Temp1, Pwm_Limit                        ; Set limit
                                     mov     A, Current_Pwm
                                     subb    A, Temp1
                                     jnc     check_voltage_low_rpm           ; If current pwm above limit - branch and l
                             imit 
                             
                                     mov     Temp1, Current_Pwm                      ; Set current pwm (no limiting)
                             
                             check_voltage_low_rpm:
                                     ; Limit pwm for low rpms
                                     clr     C
                                     mov     A, Temp1                                        ; Check against limit
                                     subb    A, Pwm_Limit_By_Rpm
                                     jc      ($+4)                                   ; If current pwm below limit - bran
                             ch
                             
                                     mov     Temp1, Pwm_Limit_By_Rpm         ; Limit pwm
                             
                                     mov  Current_Pwm_Limited, Temp1
                                     mov     Current_Pwm_Lim_Dith, Temp1
                             check_voltage_pwm_done:
                             ENDIF
                    7858             ; Set adc mux for next conversion
09BF E570           7859             mov     A, Adc_Conversion_Cnt           ; Is next conversion for temperature?
09C1 B40703         7860             cjne    A, #(TEMP_CHECK_RATE-1), check_voltage_ret
                    7861     
                    7862             Set_Adc_Ip_Temp                         ; Select temp sensor for next conversion
                    7864     
09C7                7865     check_voltage_ret:
09C7 22             7866             ret
                    7867     
                    7868     
                    7869     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    7870     ;
                    7871     ; Set startup PWM routine
                    7872     ;
                    7873     ; Either the SETTLE_PHASE or the STEPPER_PHASE flag must be set
                    7874     ;
                    7875     ; Used for pwm control during startup
                    7876     ;
                    7877     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
09C8                7878     set_startup_pwm:        
                    7879             ; Adjust startup power
09C8 7432           7880             mov     A, #PWM_START                                   ; Set power
09CA 79A7           7881             mov     Temp2, #Pgm_Startup_Pwr_Decoded
09CC 87F0           7882             mov     B, @Temp2
09CE A4             7883             mul     AB
09CF C5F0           7884             xch     A, B
09D1 A2F7           7885             mov     C, B.7                                          ; Multiply result by 2 (uni
                             ty gain is 128)
09D3 33             7886             rlc     A
09D4 F8             7887             mov     Temp1, A                                                ; Transfer to Temp1
09D5 C3             7888             clr     C
09D6 E8             7889             mov     A, Temp1                                                ; Check against lim
                             it
09D7 9561           7890             subb    A, Pwm_Limit    
09D9 4002           7891             jc      startup_pwm_set_pwm                             ; If pwm below limit - bran
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   128

                             ch
                    7892     
09DB A861           7893             mov     Temp1, Pwm_Limit                                ; Limit pwm
                    7894     
09DD                7895     startup_pwm_set_pwm:
                    7896             ; Set pwm variables
09DD 8822           7897             mov     Requested_Pwm, Temp1                    ; Update requested pwm
09DF 8824           7898             mov     Current_Pwm, Temp1                              ; Update current pwm
09E1 8825           7899             mov     Current_Pwm_Limited, Temp1              ; Update limited version of current
                              pwm
09E3 8826           7900             mov     Current_Pwm_Lim_Dith, Temp1
09E5 8864           7901             mov     Pwm_Spoolup_Beg, Temp1                  ; Yes - update spoolup beginning pw
                             m (will use PWM_SETTLE or PWM_SETTLE/2)                      
09E7 22             7902             ret
                    7903     
                    7904     
                    7905     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    7906     ;
                    7907     ; Initialize timing routine
                    7908     ;
                    7909     ; No assumptions
                    7910     ;
                    7911     ; Part of initialization before motor start
                    7912     ;
                    7913     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
09E8                7914     initialize_timing: 
09E8 754000         7915             mov     Comm_Period4x_L, #00h                           ; Set commutation period re
                             gisters
09EB 7541F0         7916             mov     Comm_Period4x_H, #0F0h
09EE 22             7917             ret
                    7918     
                    7919     
                    7920     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    7921     ;
                    7922     ; Calculate next commutation timing routine
                    7923     ;
                    7924     ; No assumptions
                    7925     ;
                    7926     ; Called immediately after each commutation
                    7927     ; Also sets up timer 3 to wait advance timing
                    7928     ; Two entry points are used
                    7929     ;
                    7930     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
09EF                7931     calc_next_comm_timing:          ; Entry point for run phase
                    7932             ; Read commutation time
09EF C2AF           7933             clr     EA
09F1 75C820         7934             mov     TMR2CN, #20h            ; Timer2 disabled
09F4 A8CC           7935             mov     Temp1, TMR2L            ; Load timer value
09F6 A9CD           7936             mov     Temp2, TMR2H    
09F8 AA3A           7937             mov     Temp3, Timer2_X 
09FA 30CF01         7938             jnb     TF2H, ($+4)             ; Check if interrupt is pending
09FD 0A             7939             inc     Temp3                   ; If it is pending, then timer has already wrapped
09FE 75C824         7940             mov     TMR2CN, #24h            ; Timer2 enabled
0A01 D2AF           7941             setb    EA
                    7942     IF MCU_48MHZ == 1
                                     clr     C
                                     mov     A, Temp3
                                     rrc     A
                                     mov     Temp3, A
                                     mov     A, Temp2
                                     rrc     A
                                     mov     Temp2, A
                                     mov     A, Temp1
                                     rrc     A
                                     mov     Temp1, A
                             ENDIF
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   129

                    7954             ; Calculate this commutation time
0A03 AB3B           7955             mov     Temp4, Prev_Comm_L 
0A05 AC3C           7956             mov     Temp5, Prev_Comm_H 
0A07 883B           7957             mov     Prev_Comm_L, Temp1              ; Store timestamp as previous commutation
0A09 893C           7958             mov     Prev_Comm_H, Temp2
0A0B C3             7959             clr     C
0A0C E8             7960             mov     A, Temp1
0A0D 9B             7961             subb    A, Temp4                                ; Calculate the new commutation time
0A0E F8             7962             mov     Temp1, A
0A0F E9             7963             mov     A, Temp2
0A10 9C             7964             subb    A, Temp5                
0A11 206908         7965             jb      Flags1.STARTUP_PHASE, calc_next_comm_startup    
                    7966     
                    7967     IF MCU_48MHZ == 1
                                     anl     A, #7Fh
                             ENDIF
0A14 F9             7970             mov     Temp2, A
0A15 306602         7971             jnb     Flags0.HIGH_RPM, ($+5)  ; Branch if high rpm
0A18 6100           7972             ajmp    calc_next_comm_timing_fast
                    7973     
0A1A 415A           7974             ajmp    calc_next_comm_normal
                    7975     
0A1C                7976     calc_next_comm_startup:
0A1C AD3D           7977             mov     Temp6, Prev_Comm_X
0A1E 8A3D           7978             mov     Prev_Comm_X, Temp3              ; Store extended timestamp as previous comm
                             utation
0A20 F9             7979             mov     Temp2, A
0A21 EA             7980             mov     A, Temp3
0A22 9D             7981             subb    A, Temp6                                ; Calculate the new extended commut
                             ation time
                    7982     IF MCU_48MHZ == 1
                                     anl     A, #7Fh
                             ENDIF
0A23 FA             7985             mov     Temp3, A
0A24 6006           7986             jz      calc_next_comm_startup_no_X
                    7987     
0A26 78FF           7988             mov     Temp1, #0FFh
0A28 79FF           7989             mov     Temp2, #0FFh
0A2A 413F           7990             ajmp    calc_next_comm_startup_average
                    7991     
0A2C                7992     calc_next_comm_startup_no_X:
0A2C AE3E           7993             mov     Temp7, Prev_Prev_Comm_L 
0A2E AF3F           7994             mov     Temp8, Prev_Prev_Comm_H 
0A30 8B3E           7995             mov     Prev_Prev_Comm_L, Temp4 
0A32 8C3F           7996             mov     Prev_Prev_Comm_H, Temp5 
0A34 A83B           7997             mov     Temp1, Prev_Comm_L              ; Reload this commutation time  
0A36 A93C           7998             mov     Temp2, Prev_Comm_H
0A38 C3             7999             clr     C
0A39 E8             8000             mov     A, Temp1
0A3A 9E             8001             subb    A, Temp7                                ; Calculate the new commutation tim
                             e based upon the two last commutations (to reduce sensitivity to offset)
0A3B F8             8002             mov     Temp1, A
0A3C E9             8003             mov     A, Temp2
0A3D 9F             8004             subb    A, Temp8 
0A3E F9             8005             mov     Temp2, A
0A3F                8006     calc_next_comm_startup_average:
0A3F C3             8007             clr     C
0A40 E541           8008             mov     A, Comm_Period4x_H              ; Average with previous and save
0A42 13             8009             rrc     A
0A43 FB             8010             mov     Temp4, A
0A44 E540           8011             mov     A, Comm_Period4x_L
0A46 13             8012             rrc     A
0A47 FA             8013             mov     Temp3, A
0A48 E8             8014             mov     A, Temp1                        
0A49 2A             8015             add     A, Temp3
0A4A F540           8016             mov     Comm_Period4x_L, A
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   130

0A4C E9             8017             mov     A, Temp2
0A4D 3B             8018             addc    A, Temp4
0A4E F541           8019             mov     Comm_Period4x_H, A
0A50 5006           8020             jnc     ($+8)
                    8021     
0A52 7540FF         8022             mov     Comm_Period4x_L, #0FFh
0A55 7541FF         8023             mov     Comm_Period4x_H, #0FFh
                    8024     
0A58 41A7           8025             ajmp    calc_new_wait_times_setup
                    8026     
0A5A                8027     calc_next_comm_normal:
                    8028             ; Calculate new commutation time 
0A5A AA40           8029             mov     Temp3, Comm_Period4x_L  ; Comm_Period4x(-l-h) holds the time of 4 commutati
                             ons
0A5C AB41           8030             mov     Temp4, Comm_Period4x_H
0A5E AC40           8031             mov     Temp5, Comm_Period4x_L  ; Copy variables
0A60 AD41           8032             mov     Temp6, Comm_Period4x_H
0A62 7E04           8033             mov     Temp7, #4                               ; Divide Comm_Period4x 4 times as d
                             efault
0A64 7F02           8034             mov     Temp8, #2                               ; Divide new commutation time 2 tim
                             es as default
0A66 C3             8035             clr     C
0A67 EB             8036             mov     A, Temp4
0A68 9404           8037             subb    A, #04h
0A6A 400D           8038             jc      calc_next_comm_avg_period_div
                    8039     
0A6C 1E             8040             dec     Temp7                           ; Reduce averaging time constant for low sp
                             eeds
0A6D 1F             8041             dec     Temp8
                    8042     
0A6E C3             8043             clr     C
0A6F EB             8044             mov     A, Temp4
0A70 9408           8045             subb    A, #08h
0A72 4005           8046             jc      calc_next_comm_avg_period_div
                    8047     
0A74 206A02         8048             jb      Flags1.INITIAL_RUN_PHASE, calc_next_comm_avg_period_div ; Do not average ve
                             ry fast during initial run
                    8049     
0A77 1E             8050             dec     Temp7                           ; Reduce averaging time constant more for e
                             ven lower speeds
0A78 1F             8051             dec     Temp8
                    8052     
0A79                8053     calc_next_comm_avg_period_div:
0A79 C3             8054             clr     C
0A7A ED             8055             mov     A, Temp6                                        
0A7B 13             8056             rrc     A                                       ; Divide by 2
0A7C FD             8057             mov     Temp6, A        
0A7D EC             8058             mov     A, Temp5                                
0A7E 13             8059             rrc     A
0A7F FC             8060             mov     Temp5, A
0A80 DEF7           8061             djnz    Temp7, calc_next_comm_avg_period_div
                    8062     
0A82 C3             8063             clr     C
0A83 EA             8064             mov     A, Temp3
0A84 9C             8065             subb    A, Temp5                                ; Subtract a fraction
0A85 FA             8066             mov     Temp3, A
0A86 EB             8067             mov     A, Temp4
0A87 9D             8068             subb    A, Temp6
0A88 FB             8069             mov     Temp4, A
0A89 EF             8070             mov     A, Temp8                                ; Divide new time
0A8A 6009           8071             jz      calc_next_comm_new_period_div_done
                    8072     
0A8C                8073     calc_next_comm_new_period_div:
0A8C C3             8074             clr     C
0A8D E9             8075             mov     A, Temp2                                        
0A8E 13             8076             rrc     A                                       ; Divide by 2
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   131

0A8F F9             8077             mov     Temp2, A        
0A90 E8             8078             mov     A, Temp1                                
0A91 13             8079             rrc     A
0A92 F8             8080             mov     Temp1, A
0A93 DFF7           8081             djnz    Temp8, calc_next_comm_new_period_div
                    8082     
0A95                8083     calc_next_comm_new_period_div_done:
0A95 EA             8084             mov     A, Temp3
0A96 28             8085             add     A, Temp1                                ; Add the divided new time
0A97 FA             8086             mov     Temp3, A
0A98 EB             8087             mov     A, Temp4
0A99 39             8088             addc    A, Temp2
0A9A FB             8089             mov     Temp4, A
0A9B 8A40           8090             mov     Comm_Period4x_L, Temp3  ; Store Comm_Period4x_X
0A9D 8B41           8091             mov     Comm_Period4x_H, Temp4
0A9F 5006           8092             jnc     calc_new_wait_times_setup; If period larger than 0xffff - go to slow case
                    8093     
0AA1 7BFF           8094             mov     Temp4, #0FFh
0AA3 8B40           8095             mov     Comm_Period4x_L, Temp4  ; Set commutation period registers to very slow tim
                             ing (0xffff)
0AA5 8B41           8096             mov     Comm_Period4x_H, Temp4
                    8097     
0AA7                8098     calc_new_wait_times_setup:      
                    8099             ; Set high rpm bit (if above 156k erpm)
0AA7 C3             8100             clr     C
0AA8 EB             8101             mov     A, Temp4
0AA9 9402           8102             subb    A, #2
0AAB 5002           8103             jnc     ($+4)
                    8104     
0AAD D266           8105             setb    Flags0.HIGH_RPM                 ; Set high rpm bit 
                    8106             
                    8107             ; Load programmed commutation timing
0AAF 306904         8108             jnb     Flags1.STARTUP_PHASE, calc_new_wait_per_startup_done    ; Set dedicated tim
                             ing during startup
                    8109     
0AB2 7F03           8110             mov     Temp8, #3
0AB4 41D2           8111             ajmp    calc_new_wait_per_demag_done
                    8112     
0AB6                8113     calc_new_wait_per_startup_done:
0AB6 7892           8114             mov     Temp1, #Pgm_Comm_Timing ; Load timing setting
0AB8 E6             8115             mov     A, @Temp1                               
0AB9 FF             8116             mov     Temp8, A                                ; Store in Temp8
0ABA C3             8117             clr     C
0ABB E537           8118             mov     A, Demag_Detected_Metric        ; Check demag metric
0ABD 9482           8119             subb    A, #130
0ABF 4011           8120             jc      calc_new_wait_per_demag_done
                    8121     
0AC1 0F             8122             inc     Temp8                           ; Increase timing
                    8123     
0AC2 C3             8124             clr     C
0AC3 E537           8125             mov     A, Demag_Detected_Metric
0AC5 94A0           8126             subb    A, #160
0AC7 4001           8127             jc      ($+3)
                    8128     
0AC9 0F             8129             inc     Temp8                           ; Increase timing again
                    8130     
0ACA C3             8131             clr     C
0ACB EF             8132             mov     A, Temp8                                ; Limit timing to max
0ACC 9406           8133             subb    A, #6
0ACE 4002           8134             jc      ($+4)
                    8135     
0AD0 7F05           8136             mov     Temp8, #5                               ; Set timing to max
                    8137     
0AD2                8138     calc_new_wait_per_demag_done:
0AD2 7E02           8139             mov     Temp7, #2                               ; Set timing reduction
                    8140             ; Load current commutation timing
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   132

0AD4 E541           8141             mov     A, Comm_Period4x_H              ; Divide 4 times
0AD6 C4             8142             swap    A
0AD7 540F           8143             anl     A, #00Fh
0AD9 F9             8144             mov     Temp2, A
0ADA E541           8145             mov     A, Comm_Period4x_H
0ADC C4             8146             swap    A
0ADD 54F0           8147             anl     A, #0F0h
0ADF F8             8148             mov     Temp1, A
0AE0 E540           8149             mov     A, Comm_Period4x_L
0AE2 C4             8150             swap    A
0AE3 540F           8151             anl     A, #00Fh
0AE5 28             8152             add     A, Temp1
0AE6 F8             8153             mov     Temp1, A
                    8154     
0AE7 C3             8155             clr     C
0AE8 E8             8156             mov     A, Temp1
0AE9 9E             8157             subb    A, Temp7
0AEA FA             8158             mov     Temp3, A
0AEB E9             8159             mov     A, Temp2                                
0AEC 9400           8160             subb    A, #0
0AEE FB             8161             mov     Temp4, A
0AEF 4009           8162             jc      load_min_time                   ; Check that result is still positive
                    8163     
0AF1 C3             8164             clr     C
0AF2 EA             8165             mov     A, Temp3
0AF3 9402           8166             subb    A, #(COMM_TIME_MIN SHL 1)
0AF5 EB             8167             mov     A, Temp4                        
0AF6 9400           8168             subb    A, #0
0AF8 5004           8169             jnc     calc_new_wait_times_exit        ; Check that result is still above minumum
                    8170     
0AFA                8171     load_min_time:
0AFA 7A02           8172             mov     Temp3, #(COMM_TIME_MIN SHL 1)
0AFC E4             8173             clr     A
0AFD FB             8174             mov     Temp4, A 
                    8175     
0AFE                8176     calc_new_wait_times_exit:       
0AFE 614C           8177             ajmp    wait_advance_timing
                    8178     
                    8179     
                    8180     ; Fast calculation (Comm_Period4x_H less than 2)
0B00                8181     calc_next_comm_timing_fast:                     
                    8182             ; Calculate new commutation time
0B00 AA40           8183             mov     Temp3, Comm_Period4x_L  ; Comm_Period4x(-l-h) holds the time of 4 commutati
                             ons
0B02 AB41           8184             mov     Temp4, Comm_Period4x_H
0B04 EB             8185             mov     A, Temp4                                ; Divide by 2 4 times
0B05 C4             8186             swap    A
0B06 FE             8187             mov     Temp7, A
0B07 EA             8188             mov     A, Temp3
0B08 C4             8189             swap A
0B09 540F           8190             anl     A, #0Fh
0B0B 4E             8191             orl     A, Temp7
0B0C FC             8192             mov     Temp5, A
0B0D C3             8193             clr     C
0B0E EA             8194             mov     A, Temp3                                ; Subtract a fraction
0B0F 9C             8195             subb    A, Temp5
0B10 FA             8196             mov     Temp3, A
0B11 EB             8197             mov     A, Temp4                                
0B12 9400           8198             subb    A, #0
0B14 FB             8199             mov     Temp4, A
0B15 C3             8200             clr     C
0B16 E8             8201             mov     A, Temp1
0B17 13             8202             rrc     A                                       ; Divide by 2 2 times
0B18 C3             8203             clr     C
0B19 13             8204             rrc     A
0B1A F8             8205             mov     Temp1, A
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   133

0B1B EA             8206             mov     A, Temp3                                ; Add the divided new time
0B1C 28             8207             add     A, Temp1
0B1D FA             8208             mov     Temp3, A
0B1E EB             8209             mov     A, Temp4
0B1F 3400           8210             addc    A, #0
0B21 FB             8211             mov     Temp4, A
0B22 8A40           8212             mov     Comm_Period4x_L, Temp3  ; Store Comm_Period4x_X
0B24 8B41           8213             mov     Comm_Period4x_H, Temp4
0B26 C3             8214             clr     C
0B27 EB             8215             mov     A, Temp4                                ; If erpm below 156k - go to normal
                              case
0B28 9402           8216             subb    A, #2
0B2A 4002           8217             jc      ($+4)
                    8218     
0B2C C266           8219             clr     Flags0.HIGH_RPM                 ; Clear high rpm bit 
                    8220             
0B2E 7802           8221             mov     Temp1, #2                               ; Set timing reduction
0B30 EB             8222             mov     A, Temp4                                ; Divide by 2 4 times
0B31 C4             8223             swap    A
0B32 FE             8224             mov     Temp7, A
0B33 7B00           8225             mov     Temp4, #0
0B35 EA             8226             mov     A, Temp3
0B36 C4             8227             swap A
0B37 540F           8228             anl     A, #0Fh
0B39 4E             8229             orl     A, Temp7
0B3A FA             8230             mov     Temp3, A
0B3B C3             8231             clr     C
0B3C EA             8232             mov     A, Temp3
0B3D 98             8233             subb    A, Temp1
0B3E FA             8234             mov     Temp3, A
0B3F 4005           8235             jc      load_min_time_fast              ; Check that result is still positive
                    8236     
0B41 C3             8237             clr     C
0B42 9402           8238             subb    A, #(COMM_TIME_MIN SHL 1)
0B44 5002           8239             jnc     calc_new_wait_times_fast_done   ; Check that result is still above minumum
                    8240     
0B46                8241     load_min_time_fast:
0B46 7A02           8242             mov     Temp3, #(COMM_TIME_MIN SHL 1)
                    8243     
0B48                8244     calc_new_wait_times_fast_done:  
0B48 7892           8245             mov     Temp1, #Pgm_Comm_Timing ; Load timing setting
0B4A E6             8246             mov     A, @Temp1                               
0B4B FF             8247             mov     Temp8, A                                ; Store in Temp8
                    8248     
                    8249     
                    8250     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    8251     ;
                    8252     ; Wait advance timing routine
                    8253     ;
                    8254     ; No assumptions
                    8255     ; NOTE: Be VERY careful if using temp registers. They are passed over this routine
                    8256     ;
                    8257     ; Waits for the advance timing to elapse and sets up the next zero cross wait
                    8258     ;
                    8259     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
0B4C                8260     wait_advance_timing:    
0B4C 306002         8261             jnb     Flags0.T3_PENDING, ($+5)
0B4F 614C           8262             ajmp    wait_advance_timing
                    8263     
                    8264             ; Setup next wait time
0B51 855192         8265             mov     TMR3RLL, Wt_ZC_Tout_Start_L
0B54 855293         8266             mov     TMR3RLH, Wt_ZC_Tout_Start_H
0B57 D260           8267             setb    Flags0.T3_PENDING
0B59 43E680         8268             orl     EIE1, #80h      ; Enable timer3 interrupts
                    8269     
                    8270     
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   134

                    8271     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    8272     ;
                    8273     ; Calculate new wait times routine
                    8274     ;
                    8275     ; No assumptions
                    8276     ;
                    8277     ; Calculates new wait times
                    8278     ;
                    8279     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
0B5C                8280     calc_new_wait_times:    
0B5C C3             8281             clr     C
0B5D E4             8282             clr     A
0B5E 9A             8283             subb    A, Temp3                                ; Negate
0B5F F8             8284             mov     Temp1, A        
0B60 E4             8285             clr     A
0B61 9B             8286             subb    A, Temp4                                
0B62 F9             8287             mov     Temp2, A        
                    8288     IF MCU_48MHZ == 1
                                     clr     C
                                     mov     A, Temp1                                ; Multiply by 2
                                     rlc     A
                                     mov     Temp1, A
                                     mov     A, Temp2
                                     rlc     A
                                     mov     Temp2, A
                             ENDIF
0B63 306602         8297             jnb     Flags0.HIGH_RPM, ($+5)  ; Branch if high rpm
0B66 61D7           8298             ajmp    calc_new_wait_times_fast
                    8299     
0B68 E8             8300             mov     A, Temp1                                ; Copy values
0B69 FA             8301             mov     Temp3, A
0B6A E9             8302             mov     A, Temp2
0B6B FB             8303             mov     Temp4, A
0B6C D3             8304             setb    C                                       ; Negative numbers - set carry
0B6D E9             8305             mov     A, Temp2                                
0B6E 13             8306             rrc     A                                       ; Divide by 2
0B6F FD             8307             mov     Temp6, A
0B70 E8             8308             mov     A, Temp1
0B71 13             8309             rrc     A
0B72 FC             8310             mov     Temp5, A
0B73 8851           8311             mov     Wt_Zc_Tout_Start_L, Temp1; Set 15deg time for zero cross scan timeout
0B75 8952           8312             mov     Wt_Zc_Tout_Start_H, Temp2
0B77 C3             8313             clr     C
0B78 EF             8314             mov     A, Temp8                                ; (Temp8 has Pgm_Comm_Timing)
0B79 9403           8315             subb    A, #3                           ; Is timing normal?
0B7B 6037           8316             jz      store_times_decrease    ; Yes - branch
                    8317     
0B7D EF             8318             mov     A, Temp8                                
0B7E 20E00C         8319             jb      ACC.0, adjust_timing_two_steps  ; If an odd number - branch
                    8320     
0B81 E8             8321             mov     A, Temp1                                ; Add 7.5deg and store in Temp1/2
0B82 2C             8322             add     A, Temp5
0B83 F8             8323             mov     Temp1, A
0B84 E9             8324             mov     A, Temp2
0B85 3D             8325             addc    A, Temp6
0B86 F9             8326             mov     Temp2, A
0B87 EC             8327             mov     A, Temp5                                ; Store 7.5deg in Temp3/4
0B88 FA             8328             mov     Temp3, A
0B89 ED             8329             mov     A, Temp6                        
0B8A FB             8330             mov     Temp4, A
0B8B 8013           8331             jmp     store_times_up_or_down
                    8332     
0B8D                8333     adjust_timing_two_steps:
0B8D E8             8334             mov     A, Temp1                                ; Add 15deg and store in Temp1/2
0B8E 28             8335             add     A, Temp1
0B8F F8             8336             mov     Temp1, A
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   135

0B90 E9             8337             mov     A, Temp2
0B91 39             8338             addc    A, Temp2
0B92 F9             8339             mov     Temp2, A
0B93 C3             8340             clr     C
0B94 E8             8341             mov     A, Temp1
0B95 2402           8342             add     A, #(COMM_TIME_MIN SHL 1)
0B97 F8             8343             mov     Temp1, A
0B98 E9             8344             mov     A, Temp2
0B99 3400           8345             addc    A, #0
0B9B F9             8346             mov     Temp2, A
0B9C 7AFE           8347             mov     Temp3, #-(COMM_TIME_MIN SHL 1); Store minimum time in Temp3/4
0B9E 7BFF           8348             mov     Temp4, #0FFh
                    8349     
0BA0                8350     store_times_up_or_down:
0BA0 C3             8351             clr     C
0BA1 EF             8352             mov     A, Temp8                                
0BA2 9403           8353             subb    A, #3                                   ; Is timing higher than normal?
0BA4 400E           8354             jc      store_times_decrease            ; No - branch
                    8355     
0BA6                8356     store_times_increase:
0BA6 8A53           8357             mov     Wt_Comm_Start_L, Temp3          ; Now commutation time (~60deg) divided by 
                             4 (~15deg nominal)
0BA8 8B54           8358             mov     Wt_Comm_Start_H, Temp4
0BAA 884D           8359             mov     Wt_Adv_Start_L, Temp1           ; New commutation advance time (~15deg nomi
                             nal)
0BAC 894E           8360             mov     Wt_Adv_Start_H, Temp2
0BAE 8C4F           8361             mov     Wt_Zc_Scan_Start_L, Temp5       ; Use this value for zero cross scan delay 
                             (7.5deg)
0BB0 8D50           8362             mov     Wt_Zc_Scan_Start_H, Temp6
0BB2 810B           8363             ajmp    wait_before_zc_scan
                    8364     
0BB4                8365     store_times_decrease:
0BB4 8853           8366             mov     Wt_Comm_Start_L, Temp1          ; Now commutation time (~60deg) divided by 
                             4 (~15deg nominal)
0BB6 8954           8367             mov     Wt_Comm_Start_H, Temp2
0BB8 8A4D           8368             mov     Wt_Adv_Start_L, Temp3           ; New commutation advance time (~15deg nomi
                             nal)
0BBA 8B4E           8369             mov     Wt_Adv_Start_H, Temp4
0BBC 8C4F           8370             mov     Wt_Zc_Scan_Start_L, Temp5       ; Use this value for zero cross scan delay 
                             (7.5deg)
0BBE 8D50           8371             mov     Wt_Zc_Scan_Start_H, Temp6
0BC0 306912         8372             jnb     Flags1.STARTUP_PHASE, store_times_exit
                    8373     
0BC3 7553F0         8374             mov     Wt_Comm_Start_L, #0F0h          ; Set very short delays for all but advance
                              time during startup, in order to widen zero cross capture range
0BC6 7554FF         8375             mov     Wt_Comm_Start_H, #0FFh
0BC9 754FF0         8376             mov     Wt_Zc_Scan_Start_L, #0F0h
0BCC 7550FF         8377             mov     Wt_Zc_Scan_Start_H, #0FFh
0BCF 7551F0         8378             mov     Wt_Zc_Tout_Start_L, #0F0h
0BD2 7552FF         8379             mov     Wt_Zc_Tout_Start_H, #0FFh
                    8380     
0BD5                8381     store_times_exit:
0BD5 810B           8382             ajmp    wait_before_zc_scan
                    8383     
                    8384     
0BD7                8385     calc_new_wait_times_fast:       
0BD7 E8             8386             mov     A, Temp1                                ; Copy values
0BD8 FA             8387             mov     Temp3, A
0BD9 D3             8388             setb    C                                       ; Negative numbers - set carry
0BDA E8             8389             mov     A, Temp1                                ; Divide by 2
0BDB 13             8390             rrc     A
0BDC FC             8391             mov     Temp5, A
0BDD 8851           8392             mov     Wt_Zc_Tout_Start_L, Temp1; Set 15deg time for zero cross scan timeout
0BDF C3             8393             clr     C
0BE0 EF             8394             mov     A, Temp8                                ; (Temp8 has Pgm_Comm_Timing)
0BE1 9403           8395             subb    A, #3                           ; Is timing normal?
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   136

0BE3 6020           8396             jz      store_times_decrease_fast; Yes - branch
                    8397     
0BE5 EF             8398             mov     A, Temp8                                
0BE6 20E007         8399             jb      ACC.0, adjust_timing_two_steps_fast     ; If an odd number - branch
                    8400     
0BE9 E8             8401             mov     A, Temp1                                ; Add 7.5deg and store in Temp1
0BEA 2C             8402             add     A, Temp5
0BEB F8             8403             mov     Temp1, A
0BEC EC             8404             mov     A, Temp5                                ; Store 7.5deg in Temp3
0BED FA             8405             mov     Temp3, A
0BEE 61F7           8406             ajmp    store_times_up_or_down_fast
                    8407     
0BF0                8408     adjust_timing_two_steps_fast:
0BF0 E8             8409             mov     A, Temp1                                ; Add 15deg and store in Temp1
0BF1 28             8410             add     A, Temp1
0BF2 2402           8411             add     A, #(COMM_TIME_MIN SHL 1)
0BF4 F8             8412             mov     Temp1, A
0BF5 7AFE           8413             mov     Temp3, #-(COMM_TIME_MIN SHL 1)  ; Store minimum time in Temp3
                    8414     
0BF7                8415     store_times_up_or_down_fast:
0BF7 C3             8416             clr     C
0BF8 EF             8417             mov     A, Temp8                                
0BF9 9403           8418             subb    A, #3                           ; Is timing higher than normal?
0BFB 4008           8419             jc      store_times_decrease_fast; No - branch
                    8420     
0BFD                8421     store_times_increase_fast:
0BFD 8A53           8422             mov     Wt_Comm_Start_L, Temp3          ; Now commutation time (~60deg) divided by 
                             4 (~15deg nominal)
0BFF 884D           8423             mov     Wt_Adv_Start_L, Temp1           ; New commutation advance time (~15deg nomi
                             nal)
0C01 8C4F           8424             mov     Wt_Zc_Scan_Start_L, Temp5       ; Use this value for zero cross scan delay 
                             (7.5deg)
0C03 810B           8425             ajmp    wait_before_zc_scan
                    8426     
0C05                8427     store_times_decrease_fast:
0C05 8853           8428             mov     Wt_Comm_Start_L, Temp1          ; Now commutation time (~60deg) divided by 
                             4 (~15deg nominal)
0C07 8A4D           8429             mov     Wt_Adv_Start_L, Temp3           ; New commutation advance time (~15deg nomi
                             nal)
0C09 8C4F           8430             mov     Wt_Zc_Scan_Start_L, Temp5       ; Use this value for zero cross scan delay 
                             (7.5deg)
                    8431     
                    8432     
                    8433     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    8434     ;
                    8435     ; Wait before zero cross scan routine
                    8436     ;
                    8437     ; No assumptions
                    8438     ;
                    8439     ; Waits for the zero cross scan wait time to elapse
                    8440     ; Also sets up timer 3 for the zero cross scan timeout time
                    8441     ;
                    8442     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
0C0B                8443     wait_before_zc_scan:    
                    8444             ; Calculate random number
0C0B E568           8445             mov     A, Random
0C0D C3             8446             clr     C
0C0E 33             8447             rlc     A
0C0F 5002           8448             jnc     wait_before_zc_scan_rand
                    8449     
0C11 646B           8450             xrl     A, #06Bh                ; Sequence length of 35, when initialized to 1
                    8451     
0C13                8452     wait_before_zc_scan_rand:          
0C13 F568           8453             mov     Random, A
                    8454     
0C15                8455     wait_before_zc_scan_wait:          
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   137

0C15 306002         8456             jnb     Flags0.T3_PENDING, ($+5)
0C18 8115           8457             ajmp    wait_before_zc_scan_wait
                    8458     
0C1A 753402         8459             mov     Startup_Zc_Timeout_Cntd, #2
0C1D                8460     setup_zc_scan_timeout:
0C1D D260           8461             setb    Flags0.T3_PENDING
0C1F 43E680         8462             orl     EIE1, #80h                      ; Enable timer3 interrupts
0C22 E52D           8463             mov     A, Flags1
0C24 5406           8464             anl     A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0C26 6034           8465             jz      wait_before_zc_scan_exit                
                    8466     
0C28 A840           8467             mov     Temp1, Comm_Period4x_L  ; Set long timeout when starting
0C2A A941           8468             mov     Temp2, Comm_Period4x_H
0C2C C3             8469             clr     C
0C2D E9             8470             mov     A, Temp2
0C2E 13             8471             rrc     A
0C2F F9             8472             mov     Temp2, A
0C30 E8             8473             mov     A, Temp1
0C31 13             8474             rrc     A
0C32 F8             8475             mov     Temp1, A
                    8476     IF MCU_48MHZ == 0
0C33 C3             8477             clr     C
0C34 E9             8478             mov     A, Temp2
0C35 13             8479             rrc     A
0C36 F9             8480             mov     Temp2, A
0C37 E8             8481             mov     A, Temp1
0C38 13             8482             rrc     A
0C39 F8             8483             mov     Temp1, A
                    8484     ENDIF
0C3A 306904         8485             jnb     Flags1.STARTUP_PHASE, setup_zc_scan_timeout_startup_done
                    8486             
0C3D E9             8487             mov     A, Temp2
0C3E 2440           8488             add     A, #40h                         ; Increase timeout somewhat to avoid false 
                             wind up
0C40 F9             8489             mov     Temp2, A
                    8490     
0C41                8491     setup_zc_scan_timeout_startup_done:
0C41 C2AF           8492             clr     EA
0C43 53E67F         8493             anl     EIE1, #7Fh                      ; Disable timer3 interrupts
0C46 759100         8494             mov     TMR3CN, #00h                    ; Timer3 disabled and interrupt flag cleared
0C49 C3             8495             clr     C
0C4A E4             8496             clr     A
0C4B 98             8497             subb    A, Temp1                                ; Set timeout
0C4C F594           8498             mov     TMR3L, A
0C4E E4             8499             clr     A
0C4F 99             8500             subb    A, Temp2                
0C50 F595           8501             mov     TMR3H, A
0C52 759104         8502             mov     TMR3CN, #04h                    ; Timer3 enabled and interrupt flag cleared
0C55 D260           8503             setb    Flags0.T3_PENDING
0C57 43E680         8504             orl     EIE1, #80h                      ; Enable timer3 interrupts
0C5A D2AF           8505             setb    EA
                    8506     
0C5C                8507     wait_before_zc_scan_exit:          
0C5C 22             8508             ret
                    8509     
                    8510     
                    8511     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    8512     ;
                    8513     ; Wait for comparator to go low/high routines
                    8514     ;
                    8515     ; No assumptions
                    8516     ;
                    8517     ; Waits for the zero cross scan wait time to elapse
                    8518     ; Then scans for comparator going low/high
                    8519     ;
                    8520     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   138

0C5D                8521     wait_for_comp_out_low:
0C5D D264           8522             setb    Flags0.DEMAG_DETECTED           ; Set demag detected flag as default
0C5F 754300         8523             mov     Comparator_Read_Cnt, #0         ; Reset number of comparator reads
0C62 752000         8524             mov     Bit_Access, #00h                        ; Desired comparator output
0C65 306C03         8525             jnb     Flags1.DIR_CHANGE_BRAKE, ($+6)
0C68 752040         8526             mov     Bit_Access, #40h                
0C6B 800E           8527             jmp     wait_for_comp_out_start
                    8528     
0C6D                8529     wait_for_comp_out_high:
0C6D D264           8530             setb    Flags0.DEMAG_DETECTED           ; Set demag detected flag as default
0C6F 754300         8531             mov     Comparator_Read_Cnt, #0         ; Reset number of comparator reads
0C72 752040         8532             mov     Bit_Access, #40h                        ; Desired comparator output
0C75 306C03         8533             jnb     Flags1.DIR_CHANGE_BRAKE, ($+6)
0C78 752000         8534             mov     Bit_Access, #00h                
                    8535     
0C7B                8536     wait_for_comp_out_start:
                    8537             ; Set number of comparator readings
0C7B 7801           8538             mov     Temp1, #1                                       ; Number of OK readings req
                             uired
0C7D 7901           8539             mov     Temp2, #1                                       ; Max number of readings re
                             quired
0C7F 206620         8540             jb      Flags0.HIGH_RPM, comp_scale_samples     ; Branch if high rpm
                    8541     
0C82 E52D           8542             mov     A, Flags1                                       ; Clear demag detected flag
                              if start phases
0C84 5406           8543             anl     A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0C86 6002           8544             jz      ($+4)
                    8545                     
0C88 C264           8546             clr     Flags0.DEMAG_DETECTED
                    8547     
0C8A 7914           8548             mov     Temp2, #20                              ; Too low value (~<15) causes rough
                              running at pwm harmonics. Too high a value (~>35) causes the RCT4215 630 to run rough on full throttle
0C8C E541           8549             mov     A, Comm_Period4x_H                      ; Set number of readings higher for
                              lower speeds        
0C8E C3             8550             clr     C
0C8F 13             8551             rrc     A
0C90 7001           8552             jnz     ($+3)
0C92 04             8553             inc     A
0C93 F8             8554             mov     Temp1, A
0C94 C3             8555             clr     C                                               
0C95 9414           8556             subb    A, #20                  
0C97 4002           8557             jc      ($+4)
                    8558     
0C99 7814           8559             mov     Temp1, #20
                    8560             
0C9B 306904         8561             jnb     Flags1.STARTUP_PHASE, comp_scale_samples                
                    8562     
0C9E 781B           8563             mov     Temp1, #27                              ; Set many samples during startup, 
                             approximately one pwm period
0CA0 791B           8564             mov     Temp2, #27
                    8565     
0CA2                8566     comp_scale_samples:
                    8567     IF MCU_48MHZ == 1
                                     clr     C
                                     mov     A, Temp1
                                     rlc     A
                                     mov     Temp1, A
                                     clr     C
                                     mov     A, Temp2
                                     rlc     A
                                     mov     Temp2, A
                             ENDIF
                    8577     
0CA2                8578     comp_check_timeout:
0CA2 206010         8579             jb      Flags0.T3_PENDING, comp_check_timeout_not_timed_out     ; Has zero cross sc
                             an timeout elapsed?
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   139

                    8580     
0CA5 E543           8581             mov     A, Comparator_Read_Cnt                          ; Check that comparator has
                              been read
0CA7 600C           8582             jz      comp_check_timeout_not_timed_out                ; If not read - branch
                    8583     
0CA9 306903         8584             jnb     Flags1.STARTUP_PHASE, comp_check_timeout_timeout_extended       ; Extend ti
                             meout during startup
                    8585     
0CAC D53404         8586             djnz    Startup_Zc_Timeout_Cntd, comp_check_timeout_extend_timeout
                    8587     
0CAF                8588     comp_check_timeout_timeout_extended:
0CAF D26D           8589             setb    Flags1.COMP_TIMED_OUT
0CB1 A125           8590             ajmp    setup_comm_wait
                    8591     
0CB3                8592     comp_check_timeout_extend_timeout:
0CB3 911D           8593             call    setup_zc_scan_timeout
0CB5                8594     comp_check_timeout_not_timed_out:
0CB5 0543           8595             inc     Comparator_Read_Cnt                     ; Increment comparator read count
                    8596             Read_Comp_Out                                   ; Read comparator output
0CB9 5440           8598             anl     A, #40h
0CBB B52002         8599             cjne    A, Bit_Access, comp_read_wrong
0CBE A10F           8600             ajmp    comp_read_ok
                    8601             
0CC0                8602     comp_read_wrong:
0CC0 306909         8603             jnb     Flags1.STARTUP_PHASE, comp_read_wrong_not_startup
                    8604     
0CC3 08             8605             inc     Temp1                                   ; Increment number of OK readings r
                             equired
0CC4 C3             8606             clr     C
0CC5 E8             8607             mov     A, Temp1
0CC6 99             8608             subb    A, Temp2                                        ; If above initial requirem
                             ent - go back and restart
0CC7 4001           8609             jc      ($+3)
0CC9 18             8610             dec     Temp1
                    8611     
0CCA 81A2           8612             ajmp    comp_check_timeout                      ; Continue to look for good ones
                    8613     
0CCC                8614     comp_read_wrong_not_startup:
0CCC 20640A         8615             jb      Flags0.DEMAG_DETECTED, comp_read_wrong_extend_timeout
                    8616     
0CCF 08             8617             inc     Temp1                                   ; Increment number of OK readings r
                             equired
0CD0 C3             8618             clr     C
0CD1 E8             8619             mov     A, Temp1
0CD2 99             8620             subb    A, Temp2                                        
0CD3 4002           8621             jc      ($+4)
0CD5 817B           8622             ajmp    wait_for_comp_out_start         ; If above initial requirement - go back an
                             d restart
                    8623     
0CD7 81A2           8624             ajmp    comp_check_timeout                      ; Otherwise - take another reading
                    8625     
0CD9                8626     comp_read_wrong_extend_timeout:
0CD9 C264           8627             clr     Flags0.DEMAG_DETECTED           ; Clear demag detected flag
0CDB C2AF           8628             clr     EA
0CDD 53E67F         8629             anl     EIE1, #7Fh                              ; Disable timer3 interrupts
0CE0 759100         8630             mov     TMR3CN, #00h                            ; Timer3 disabled and interrupt fla
                             g cleared
0CE3 306612         8631             jnb     Flags0.HIGH_RPM, comp_read_wrong_low_rpm        ; Branch if not high rpm   
                                  
                    8632     
0CE6 759400         8633             mov     TMR3L, #00h                             ; Set timeout to ~1ms
                    8634     IF MCU_48MHZ == 1
                                     mov     TMR3H, #0F0h
                             ELSE
0CE9 7595F8         8637             mov     TMR3H, #0F8h
                    8638     ENDIF
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   140

0CEC                8639     comp_read_wrong_timeout_set:
0CEC 759104         8640             mov     TMR3CN, #04h                            ; Timer3 enabled and interrupt flag
                              cleared
0CEF D260           8641             setb    Flags0.T3_PENDING
0CF1 43E680         8642             orl     EIE1, #80h                              ; Enable timer3 interrupts
0CF4 D2AF           8643             setb    EA
0CF6 817B           8644             ajmp    wait_for_comp_out_start         ; If comparator output is not correct - go 
                             back and restart
                    8645     
0CF8                8646     comp_read_wrong_low_rpm:
0CF8 E541           8647             mov     A, Comm_Period4x_H                      ; Set timeout to ~4x comm period 4x
                              value
0CFA 7EFF           8648             mov     Temp7, #0FFh                            ; Default to long
                    8649     IF MCU_48MHZ == 1
                                     clr     C
                                     rlc     A
                                     jc      comp_read_wrong_load_timeout
                             
                             ENDIF
0CFC C3             8655             clr     C
0CFD 33             8656             rlc     A
0CFE 4005           8657             jc      comp_read_wrong_load_timeout
                    8658     
0D00 C3             8659             clr     C
0D01 33             8660             rlc     A
0D02 4001           8661             jc      comp_read_wrong_load_timeout
                    8662     
0D04 FE             8663             mov     Temp7, A
                    8664     
0D05                8665     comp_read_wrong_load_timeout:
0D05 C3             8666             clr     C
0D06 E4             8667             clr     A
0D07 9E             8668             subb    A, Temp7
0D08 759400         8669             mov     TMR3L, #0
0D0B F595           8670             mov     TMR3H, A
0D0D 81EC           8671             ajmp    comp_read_wrong_timeout_set
                    8672     
0D0F                8673     comp_read_ok:
0D0F C3             8674             clr     C
0D10 E533           8675             mov     A, Startup_Cnt                          ; Force a timeout for the first com
                             mutation             
0D12 9401           8676             subb    A, #1
0D14 5002           8677             jnc     ($+4)
0D16 817B           8678             ajmp    wait_for_comp_out_start
                    8679     
0D18 306402         8680             jnb     Flags0.DEMAG_DETECTED, ($+5)    ; Do not accept correct comparator output i
                             f it is demag        
0D1B 817B           8681             ajmp    wait_for_comp_out_start
                    8682     
0D1D D802           8683             djnz    Temp1, comp_read_ok_jmp         ; Decrement readings counter - repeat compa
                             rator reading if not zero
0D1F A123           8684             ajmp    ($+4)
                    8685     
0D21                8686     comp_read_ok_jmp:
0D21 81A2           8687             ajmp    comp_check_timeout      
                    8688     
0D23 C26D           8689             clr     Flags1.COMP_TIMED_OUT
                    8690     
                    8691     
                    8692     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    8693     ;
                    8694     ; Setup commutation timing routine
                    8695     ;
                    8696     ; No assumptions
                    8697     ;
                    8698     ; Sets up and starts wait from commutation to zero cross
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   141

                    8699     ;
                    8700     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
0D25                8701     setup_comm_wait: 
0D25 C2AF           8702             clr     EA
0D27 53E67F         8703             anl     EIE1, #7Fh              ; Disable timer3 interrupts
0D2A 759100         8704             mov     TMR3CN, #00h            ; Timer3 disabled and interrupt flag cleared
0D2D 855394         8705             mov     TMR3L, Wt_Comm_Start_L
0D30 855495         8706             mov     TMR3H, Wt_Comm_Start_H
0D33 759104         8707             mov     TMR3CN, #04h            ; Timer3 enabled and interrupt flag cleared
                    8708             ; Setup next wait time
0D36 854D92         8709             mov     TMR3RLL, Wt_Adv_Start_L
0D39 854E93         8710             mov     TMR3RLH, Wt_Adv_Start_H
0D3C D260           8711             setb    Flags0.T3_PENDING
0D3E 43E680         8712             orl     EIE1, #80h              ; Enable timer3 interrupts
0D41 D2AF           8713             setb    EA                              ; Enable interrupts again
                    8714     
                    8715     
                    8716     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    8717     ;
                    8718     ; Evaluate comparator integrity
                    8719     ;
                    8720     ; No assumptions
                    8721     ;
                    8722     ; Checks comparator signal behaviour versus expected behaviour
                    8723     ;
                    8724     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
0D43                8725     evaluate_comparator_integrity:
0D43 E52D           8726             mov     A, Flags1
0D45 5406           8727             anl     A, #((1 SHL STARTUP_PHASE)+(1 SHL INITIAL_RUN_PHASE))
0D47 6007           8728             jz      eval_comp_check_timeout
                    8729     
0D49 206A02         8730             jb      Flags1.INITIAL_RUN_PHASE, ($+5) ; Do not increment beyond startup phase
0D4C 0533           8731             inc     Startup_Cnt                                     ; Increment counter
0D4E 8010           8732             jmp     eval_comp_exit
                    8733     
0D50                8734     eval_comp_check_timeout:
0D50 306D0D         8735             jnb     Flags1.COMP_TIMED_OUT, eval_comp_exit   ; Has timeout elapsed?
0D53 206C0A         8736             jb      Flags1.DIR_CHANGE_BRAKE, eval_comp_exit ; Do not exit run mode if it is bra
                             king
0D56 206407         8737             jb      Flags0.DEMAG_DETECTED, eval_comp_exit   ; Do not exit run mode if it is a d
                             emag situation
0D59 1581           8738             dec     SP                                                              ; Routine e
                             xit without "ret" command
0D5B 1581           8739             dec     SP
0D5D 0215F8         8740             ljmp    run_to_wait_for_power_on_fail                   ; Yes - exit run mode
                    8741     
0D60                8742     eval_comp_exit:
0D60 22             8743             ret
                    8744     
                    8745     
                    8746     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    8747     ;
                    8748     ; Wait for commutation routine
                    8749     ;
                    8750     ; No assumptions
                    8751     ;
                    8752     ; Waits from zero cross to commutation 
                    8753     ;
                    8754     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
0D61                8755     wait_for_comm: 
                    8756             ; Update demag metric
0D61 7800           8757             mov     Temp1, #0
0D63 306402         8758             jnb     Flags0.DEMAG_DETECTED, ($+5)
                    8759     
0D66 7801           8760             mov     Temp1, #1
                    8761     
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   142

0D68 E537           8762             mov     A, Demag_Detected_Metric        ; Sliding average of 8, 256 when demag and 
                             0 when not. Limited to minimum 120
0D6A 75F007         8763             mov     B, #7
0D6D A4             8764             mul     AB                                      ; Multiply by 7
0D6E F9             8765             mov     Temp2, A
0D6F E5F0           8766             mov     A, B                                    ; Add new value for current demag s
                             tatus
0D71 28             8767             add     A, Temp1                                
0D72 F5F0           8768             mov     B, A
0D74 E9             8769             mov     A, Temp2
0D75 A2F0           8770             mov     C, B.0                          ; Divide by 8
0D77 13             8771             rrc     A                                       
0D78 A2F1           8772             mov     C, B.1
0D7A 13             8773             rrc     A
0D7B A2F2           8774             mov     C, B.2
0D7D 13             8775             rrc     A
0D7E F537           8776             mov     Demag_Detected_Metric, A
0D80 C3             8777             clr     C
0D81 9478           8778             subb    A, #120                         ; Limit to minimum 120
0D83 5003           8779             jnc     ($+5)
                    8780     
0D85 753778         8781             mov     Demag_Detected_Metric, #120
                    8782     
0D88 C3             8783             clr     C
0D89 E537           8784             mov     A, Demag_Detected_Metric        ; Check demag metric
0D8B 9538           8785             subb    A, Demag_Pwr_Off_Thresh
0D8D 4008           8786             jc      wait_for_comm_wait              ; Cut power if many consecutive demags. Thi
                             s will help retain sync during hard accelerations
                    8787     
0D8F D265           8788             setb    Flags0.DEMAG_CUT_POWER  ; Set demag power cut flag
                    8789     IF NFETON_DELAY NE 0
                    8790             All_nFETs_off
                    8794     ELSE
                                     En_Off                                  ; For EN/PWM style drivers
                             ENDIF
                    8797     
0D97                8798     wait_for_comm_wait:
0D97 306002         8799             jnb Flags0.T3_PENDING, ($+5)                    
0D9A A197           8800             ajmp    wait_for_comm_wait                                      
                    8801     
                    8802             ; Setup next wait time
0D9C 854F92         8803             mov     TMR3RLL, Wt_Zc_Scan_Start_L
0D9F 855093         8804             mov     TMR3RLH, Wt_Zc_Scan_Start_H
0DA2 D260           8805             setb    Flags0.T3_PENDING
0DA4 43E680         8806             orl     EIE1, #80h                      ; Enable timer3 interrupts
0DA7 22             8807             ret
                    8808     
                    8809     
                    8810     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    8811     ;
                    8812     ; Commutation routines
                    8813     ;
                    8814     ; No assumptions
                    8815     ;
                    8816     ; Performs commutation switching 
                    8817     ; Damped routines uses all pfets on when in pwm off to dampen the motor
                    8818     ;
                    8819     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    8820     ; Comm phase 1 to comm phase 2
0DA8                8821     comm1comm2:     
                    8822             Set_RPM_Out
0DA8 207D15         8823             jb      Flags3.PGM_DIR_REV, comm12_rev
                    8824     
0DAB C2AF           8825             clr     EA                                      ; Disable all interrupts
0DAD 754202         8826             mov     Comm_Phase, #2
                    8827             BpFET_off                               ; Turn off pfet
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   143

                    8829             ApFET_on                                        ; Turn on pfet
0DB4 306202         8831             jnb     Flags0.PWM_ON, comm12_nfet_done ; Is pwm on?
                    8832             CnFET_on                                        ; Pwm on - turn on nfet
0DB9                8834     comm12_nfet_done:
0DB9 D2AF           8835             setb    EA
                    8836             Set_Comp_Phase_B                        ; Set comparator phase
0DBE E18F           8838             jmp     comm_exit
                    8839     
0DC0                8840     comm12_rev:     
0DC0 C2AF           8841             clr     EA                                      ; Disable all interrupts
0DC2 754202         8842             mov     Comm_Phase, #2
                    8843             BpFET_off                               ; Turn off pfet
                    8845             CpFET_on                                        ; Turn on pfet (reverse)
0DC9 306202         8847             jnb     Flags0.PWM_ON, comm12_nfet_done_rev     ; Is pwm on?
                    8848             AnFET_on                                        ; Pwm on - turn on nfet
0DCE                8850     comm12_nfet_done_rev:
0DCE D2AF           8851             setb    EA
                    8852             Set_Comp_Phase_B                        ; Set comparator phase
0DD3 E18F           8854             jmp     comm_exit
                    8855     
                    8856     
                    8857     ; Comm phase 2 to comm phase 3
0DD5                8858     comm2comm3:     
                    8859             Clear_RPM_Out
0DD5 307243         8860             jnb     Flags2.PGM_PWMOFF_DAMPED, comm23_nondamp
                    8861     
                    8862             ; Comm2Comm3 Damped
0DD8 207D20         8863             jb      Flags3.PGM_DIR_REV, comm23_damp_rev
                    8864     
0DDB C2AF           8865             clr     EA                                      ; Disable all interrupts
0DDD 754203         8866             mov     Comm_Phase, #3
0DE0 90013B         8867             mov     DPTR, #pwm_bfet_damped  
0DE3 757B04         8868             mov     DampingFET, #(1 SHL BpFET)
                    8869             CnFET_off                                       ; Turn off fets
                    8871             CpFET_off                                               
0DEA 306204         8873             jnb     Flags0.PWM_ON, comm23_nfet_off  ; Is pwm on?
                    8874             BnFET_on                                        ; Pwm on - turn on nfet
0DEF A1F3           8876             ajmp    comm23_fets_done
0DF1                8877     comm23_nfet_off:
                    8878             BpFET_on                                        ; Pwm off - switch damping fets 
0DF3                8880     comm23_fets_done:
0DF3 D2AF           8881             setb    EA
                    8882             Set_Comp_Phase_C                        ; Set comparator phase
0DF8 020F8F         8884             ljmp    comm_exit
                    8885     
                    8886             ; Comm2Comm3 Damped reverse
0DFB                8887     comm23_damp_rev:
0DFB C2AF           8888             clr     EA                                      ; Disable all interrupts
0DFD 754203         8889             mov     Comm_Phase, #3
0E00 90013B         8890             mov     DPTR, #pwm_bfet_damped  
0E03 757B04         8891             mov     DampingFET, #(1 SHL BpFET)
                    8892             AnFET_off                                       ; Turn off fets (reverse)
                    8894             ApFET_off                                               
0E0A 306204         8896             jnb     Flags0.PWM_ON, comm23_nfet_off_rev      ; Is pwm on?
                    8897             BnFET_on                                        ; Pwm on - turn on nfet
0E0F C113           8899             ajmp    comm23_fets_done_rev
0E11                8900     comm23_nfet_off_rev:
                    8901             BpFET_on                                        ; Pwm off - switch damping fets 
0E13                8903     comm23_fets_done_rev:
0E13 D2AF           8904             setb    EA
                    8905             Set_Comp_Phase_A                        ; Set comparator phase (reverse)
0E18 020F8F         8907             ljmp    comm_exit
                    8908     
                    8909             ; Comm2Comm3 Non-damped
0E1B                8910     comm23_nondamp:
0E1B 207D17         8911             jb      Flags3.PGM_DIR_REV, comm23_nondamp_rev
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   144

                    8912     
0E1E C2AF           8913             clr     EA                                      ; Disable all interrupts
0E20 754203         8914             mov     Comm_Phase, #3
0E23 900116         8915             mov     DPTR, #pwm_bfet 
                    8916     IF NFETON_DELAY == 0
                                     mov     DampingFET, #(1 SHL BpFET)
                             ENDIF
                    8919             CnFET_off                                       ; Turn off nfet
0E28 306202         8921             jnb     Flags0.PWM_ON, comm23_nfet_done ; Is pwm on?
                    8922             BnFET_on                                        ; Yes - turn on nfet
0E2D                8924     comm23_nfet_done:
0E2D D2AF           8925             setb    EA
                    8926             Set_Comp_Phase_C                        ; Set comparator phase
0E32 020F8F         8928             ljmp    comm_exit
                    8929     
                    8930             ; Comm2Comm3 Non-damped reverse
0E35                8931     comm23_nondamp_rev:
0E35 C2AF           8932             clr     EA                                      ; Disable all interrupts
0E37 754203         8933             mov     Comm_Phase, #3
0E3A 900116         8934             mov     DPTR, #pwm_bfet 
                    8935     IF NFETON_DELAY == 0
                                     mov     DampingFET, #(1 SHL BpFET)
                             ENDIF
                    8938             AnFET_off                                       ; Turn off nfet (reverse)
0E3F 306202         8940             jnb     Flags0.PWM_ON, comm23_nfet_done_rev     ; Is pwm on?
                    8941             BnFET_on                                        ; Yes - turn on nfet
0E44                8943     comm23_nfet_done_rev:
0E44 D2AF           8944             setb    EA
                    8945             Set_Comp_Phase_A                        ; Set comparator phase (reverse)
0E49 020F8F         8947             ljmp    comm_exit
                    8948     
                    8949     
                    8950     ; Comm phase 3 to comm phase 4
0E4C                8951     comm3comm4:     
                    8952             Set_RPM_Out
0E4C 207D15         8953             jb      Flags3.PGM_DIR_REV, comm34_rev
                    8954     
0E4F C2AF           8955             clr     EA                                      ; Disable all interrupts
0E51 754204         8956             mov     Comm_Phase, #4
                    8957             ApFET_off                               ; Turn off pfet
                    8959             CpFET_on                                        ; Turn on pfet
0E58 306202         8961             jnb     Flags0.PWM_ON, comm34_nfet_done ; Is pwm on?
                    8962             BnFET_on                                        ; Pwm on - turn on nfet
0E5D                8964     comm34_nfet_done:
0E5D D2AF           8965             setb    EA
                    8966             Set_Comp_Phase_A                        ; Set comparator phase
0E62 E18F           8968             jmp     comm_exit
                    8969     
0E64                8970     comm34_rev:     
0E64 C2AF           8971             clr     EA                                      ; Disable all interrupts
0E66 754204         8972             mov     Comm_Phase, #4
                    8973             CpFET_off                               ; Turn off pfet (reverse)
                    8975             ApFET_on                                        ; Turn on pfet (reverse)
0E6D 306202         8977             jnb     Flags0.PWM_ON, comm34_nfet_done_rev     ; Is pwm on?
                    8978             BnFET_on                                        ; Pwm on - turn on nfet
0E72                8980     comm34_nfet_done_rev:
0E72 D2AF           8981             setb    EA
                    8982             Set_Comp_Phase_C                        ; Set comparator phase (reverse)
0E77 E18F           8984             jmp     comm_exit
                    8985     
                    8986     
                    8987     ; Comm phase 4 to comm phase 5
0E79                8988     comm4comm5:     
                    8989             Clear_RPM_Out
0E79 307243         8990             jnb     Flags2.PGM_PWMOFF_DAMPED, comm45_nondamp
                    8991     
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   145

                    8992             ; Comm4Comm5 Damped
0E7C 207D20         8993             jb      Flags3.PGM_DIR_REV, comm45_damp_rev
                    8994     
0E7F C2AF           8995             clr     EA                                      ; Disable all interrupts
0E81 754205         8996             mov     Comm_Phase, #5
0E84 90012A         8997             mov     DPTR, #pwm_afet_damped  
0E87 757B01         8998             mov     DampingFET, #(1 SHL ApFET)
                    8999             BnFET_off                                       ; Turn off fets
                    9001             BpFET_off                                               
0E8E 306204         9003             jnb     Flags0.PWM_ON, comm45_nfet_off  ; Is pwm on?
                    9004             AnFET_on                                        ; Pwm on - turn on nfet
0E93 C197           9006             ajmp    comm45_fets_done
0E95                9007     comm45_nfet_off:
                    9008             ApFET_on                                        ; Pwm off - switch damping fets 
0E97                9010     comm45_fets_done:
0E97 D2AF           9011             setb    EA
                    9012             Set_Comp_Phase_B                        ; Set comparator phase
0E9C 020F8F         9014             ljmp    comm_exit
                    9015     
                    9016             ; Comm4Comm5 Damped reverse
0E9F                9017     comm45_damp_rev:
0E9F C2AF           9018             clr     EA                                      ; Disable all interrupts
0EA1 754205         9019             mov     Comm_Phase, #5
0EA4 90014C         9020             mov     DPTR, #pwm_cfet_damped  ; (reverse)
0EA7 757B10         9021             mov     DampingFET, #(1 SHL CpFET)      ; (reverse)
                    9022             BnFET_off                                       ; Turn off fets
                    9024             BpFET_off                                               
0EAE 306204         9026             jnb     Flags0.PWM_ON, comm45_nfet_off_rev      ; Is pwm on?
                    9027             CnFET_on                                        ; Pwm on - turn on nfet (reverse)
0EB3 C1B7           9029             ajmp    comm45_fets_done_rev
0EB5                9030     comm45_nfet_off_rev:
                    9031             CpFET_on                                        ; Pwm off - switch damping fets (re
                             verse)       
0EB7                9033     comm45_fets_done_rev:
0EB7 D2AF           9034             setb    EA
                    9035             Set_Comp_Phase_B                        ; Set comparator phase
0EBC 020F8F         9037             ljmp    comm_exit
                    9038     
                    9039             ; Comm4Comm5 Non-damped
0EBF                9040     comm45_nondamp:
0EBF 207D17         9041             jb      Flags3.PGM_DIR_REV, comm45_nondamp_rev
                    9042     
0EC2 C2AF           9043             clr     EA                                      ; Disable all interrupts
0EC4 754205         9044             mov     Comm_Phase, #5
0EC7 90010C         9045             mov     DPTR, #pwm_afet 
                    9046     IF NFETON_DELAY == 0
                                     mov     DampingFET, #(1 SHL ApFET)
                             ENDIF
                    9049             BnFET_off                                       ; Turn off nfet
0ECC 306202         9051             jnb     Flags0.PWM_ON, comm45_nfet_done ; Is pwm on?
                    9052             AnFET_on                                        ; Yes - turn on nfet
0ED1                9054     comm45_nfet_done:
0ED1 D2AF           9055             setb    EA
                    9056             Set_Comp_Phase_B                        ; Set comparator phase
0ED6 020F8F         9058             ljmp    comm_exit
                    9059     
                    9060             ; Comm4Comm5 Non-damped reverse
0ED9                9061     comm45_nondamp_rev:
0ED9 C2AF           9062             clr     EA                                      ; Disable all interrupts
0EDB 754205         9063             mov     Comm_Phase, #5
0EDE 900120         9064             mov     DPTR, #pwm_cfet         ;  (reverse)
                    9065     IF NFETON_DELAY == 0
                                     mov     DampingFET, #(1 SHL CpFET)
                             ENDIF
                    9068             BnFET_off                                       ; Turn off nfet
0EE3 3062EB         9070             jnb     Flags0.PWM_ON, comm45_nfet_done ; Is pwm on?
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   146

                    9071             CnFET_on                                        ; Yes - turn on nfet (reverse)
0EE8 D2AF           9073             setb    EA
                    9074             Set_Comp_Phase_B                        ; Set comparator phase
0EED 020F8F         9076             ljmp    comm_exit
                    9077     
                    9078     
                    9079     ; Comm phase 5 to comm phase 6
0EF0                9080     comm5comm6:     
                    9081             Set_RPM_Out
0EF0 207D15         9082             jb      Flags3.PGM_DIR_REV, comm56_rev
                    9083     
0EF3 C2AF           9084             clr     EA                                      ; Disable all interrupts
0EF5 754206         9085             mov     Comm_Phase, #6
                    9086             CpFET_off                               ; Turn off pfet
                    9088             BpFET_on                                        ; Turn on pfet
0EFC 306202         9090             jnb     Flags0.PWM_ON, comm56_nfet_done ; Is pwm on?
                    9091             AnFET_on                                        ; Pwm on - turn on nfet
0F01                9093     comm56_nfet_done:
0F01 D2AF           9094             setb    EA
                    9095             Set_Comp_Phase_C                        ; Set comparator phase
0F06 E18F           9097             jmp     comm_exit
                    9098     
0F08                9099     comm56_rev:
0F08 C2AF           9100             clr     EA                                      ; Disable all interrupts
0F0A 754206         9101             mov     Comm_Phase, #6
                    9102             ApFET_off                               ; Turn off pfet (reverse)
                    9104             BpFET_on                                        ; Turn on pfet
0F11 306202         9106             jnb     Flags0.PWM_ON, comm56_nfet_done_rev     ; Is pwm on?
                    9107             CnFET_on                                        ; Pwm on - turn on nfet
0F16                9109     comm56_nfet_done_rev:
0F16 D2AF           9110             setb    EA
                    9111             Set_Comp_Phase_A                        ; Set comparator phase (reverse)
0F1B 8072           9113             jmp     comm_exit
                    9114     
                    9115     
                    9116     ; Comm phase 6 to comm phase 1
0F1D                9117     comm6comm1:     
                    9118             Clear_RPM_Out
0F1D 307242         9119             jnb     Flags2.PGM_PWMOFF_DAMPED, comm61_nondamp
                    9120     
                    9121             ; Comm6Comm1 Damped
0F20 207D20         9122             jb      Flags3.PGM_DIR_REV, comm61_damp_rev
                    9123     
0F23 C2AF           9124             clr     EA                                      ; Disable all interrupts
0F25 754201         9125             mov     Comm_Phase, #1
0F28 90014C         9126             mov     DPTR, #pwm_cfet_damped  
0F2B 757B10         9127             mov     DampingFET, #(1 SHL CpFET)
                    9128             AnFET_off                                       ; Turn off fets
                    9130             ApFET_off                                               
0F32 306204         9132             jnb     Flags0.PWM_ON, comm61_nfet_off  ; Is pwm on?
                    9133             CnFET_on                                        ; Pwm on - turn on nfet
0F37 E13B           9135             ajmp    comm61_fets_done
0F39                9136     comm61_nfet_off:
                    9137             CpFET_on                                        ; Pwm off - switch damping fets 
0F3B                9139     comm61_fets_done:
0F3B D2AF           9140             setb    EA
                    9141             Set_Comp_Phase_A                        ; Set comparator phase
0F40 020F8F         9143             ljmp    comm_exit
                    9144     
                    9145             ; Comm6Comm1 Damped reverse
0F43                9146     comm61_damp_rev:
0F43 C2AF           9147             clr     EA                                      ; Disable all interrupts
0F45 754201         9148             mov     Comm_Phase, #1
0F48 90012A         9149             mov     DPTR, #pwm_afet_damped  ; (reverse)     
0F4B 757B01         9150             mov     DampingFET, #(1 SHL ApFET)      ; (reverse)
                    9151             CnFET_off                                       ; Turn off fets (reverse)
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   147

                    9153             CpFET_off                                               
0F52 306204         9155             jnb     Flags0.PWM_ON, comm61_nfet_off_rev      ; Is pwm on?
                    9156             AnFET_on                                        ; Pwm on - turn on nfet
0F57 8002           9158             jmp     comm61_fets_done_rev
0F59                9159     comm61_nfet_off_rev:
                    9160             ApFET_on                                        ; Pwm off - switch damping fets (re
                             verse)       
0F5B                9162     comm61_fets_done_rev:
0F5B D2AF           9163             setb    EA
                    9164             Set_Comp_Phase_C                        ; Set comparator phase (reverse)
0F60 802D           9166             jmp     comm_exit
                    9167     
                    9168             ; Comm6Comm1 Non-damped
0F62                9169     comm61_nondamp:
0F62 207D16         9170             jb      Flags3.PGM_DIR_REV, comm61_nondamp_rev
                    9171     
0F65 C2AF           9172             clr     EA                                      ; Disable all interrupts
0F67 754201         9173             mov     Comm_Phase, #1
0F6A 900120         9174             mov     DPTR, #pwm_cfet 
                    9175     IF NFETON_DELAY == 0
                                     mov     DampingFET, #(1 SHL CpFET)
                             ENDIF
                    9178             AnFET_off                                       ; Turn off nfet
0F6F 306202         9180             jnb     Flags0.PWM_ON, comm61_nfet_done ; Is pwm on?
                    9181             CnFET_on                                        ; Yes - turn on nfet
0F74                9183     comm61_nfet_done:
0F74 D2AF           9184             setb    EA
                    9185             Set_Comp_Phase_A                        ; Set comparator phase
0F79 8014           9187             jmp     comm_exit
                    9188     
                    9189             ; Comm6Comm1 Non-damped reverse
0F7B                9190     comm61_nondamp_rev:
0F7B C2AF           9191             clr     EA                                      ; Disable all interrupts
0F7D 754201         9192             mov     Comm_Phase, #1
0F80 90010C         9193             mov     DPTR, #pwm_afet         ; (reverse)
                    9194     IF NFETON_DELAY == 0
                                     mov     DampingFET, #(1 SHL ApFET)
                             ENDIF
                    9197             CnFET_off                                       ; Turn off nfet (reverse)
0F85 306202         9199             jnb     Flags0.PWM_ON, comm61_nfet_done_rev     ; Is pwm on?
                    9200             AnFET_on                                        ; Yes - turn on nfet (reverse)
0F8A                9202     comm61_nfet_done_rev:
0F8A D2AF           9203             setb    EA
                    9204             Set_Comp_Phase_C                        ; Set comparator phase (reverse)
                    9206     
0F8F                9207     comm_exit:
0F8F C265           9208             clr     Flags0.DEMAG_CUT_POWER  ; Clear demag power cut flag
0F91 22             9209             ret
                    9210     
                    9211     
                    9212     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    9213     ;
                    9214     ; Switch power off routine
                    9215     ;
                    9216     ; No assumptions
                    9217     ;
                    9218     ; Switches all fets off 
                    9219     ;
                    9220     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
0F92                9221     switch_power_off:
0F92 90010A         9222             mov     DPTR, #pwm_nofet        ; Set DPTR register to pwm_nofet                
0F95 757B00         9223             mov     DampingFET, #0
                    9224             All_nFETs_Off                   ; Turn off all nfets
                    9228             All_pFETs_Off                   ; Turn off all pfets
0FA4 C262           9232             clr     Flags0.PWM_ON           ; Set pwm cycle to pwm off
0FA6 22             9233             ret                     
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   148

                    9234     
                    9235     
                    9236     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    9237     ;
                    9238     ; Set default parameters
                    9239     ;
                    9240     ; No assumptions
                    9241     ;
                    9242     ; Sets default programming parameters
                    9243     ;
                    9244     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
0FA7                9245     set_default_parameters:
                    9246     IF MODE == 0    ; Main
0FA7 7880           9247             mov     Temp1, #Pgm_Gov_P_Gain
0FA9 7607           9248             mov     @Temp1, #DEFAULT_PGM_MAIN_P_GAIN
0FAB 08             9249             inc     Temp1
0FAC 7607           9250             mov     @Temp1, #DEFAULT_PGM_MAIN_I_GAIN
0FAE 08             9251             inc     Temp1
0FAF 7601           9252             mov     @Temp1, #DEFAULT_PGM_MAIN_GOVERNOR_MODE
0FB1 08             9253             inc     Temp1
0FB2 7604           9254             mov     @Temp1, #DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM
0FB4 08             9255             inc     Temp1
0FB5 76FF           9256             mov     @Temp1, #0FFh   ; Motor gain
0FB7 08             9257             inc     Temp1
0FB8 76FF           9258             mov     @Temp1, #0FFh   ; Motor idle
0FBA 08             9259             inc     Temp1
0FBB 7609           9260             mov     @Temp1, #DEFAULT_PGM_MAIN_STARTUP_PWR
0FBD 08             9261             inc     Temp1
0FBE 7602           9262             mov     @Temp1, #DEFAULT_PGM_MAIN_PWM_FREQ
0FC0 08             9263             inc     Temp1
0FC1 7601           9264             mov     @Temp1, #DEFAULT_PGM_MAIN_DIRECTION
0FC3 08             9265             inc     Temp1
0FC4 7601           9266             mov     @Temp1, #DEFAULT_PGM_MAIN_RCP_PWM_POL
                    9267     
0FC6 788C           9268             mov     Temp1, #Pgm_Enable_TX_Program
0FC8 7601           9269             mov     @Temp1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
0FCA 08             9270             inc     Temp1
0FCB 7600           9271             mov     @Temp1, #DEFAULT_PGM_MAIN_REARM_START
0FCD 08             9272             inc     Temp1
0FCE 76B4           9273             mov     @Temp1, #DEFAULT_PGM_MAIN_GOV_SETUP_TARGET
0FD0 08             9274             inc     Temp1
0FD1 76FF           9275             mov     @Temp1, #0FFh   ; Startup rpm   
0FD3 08             9276             inc     Temp1
0FD4 76FF           9277             mov     @Temp1, #0FFh   ; Startup accel
0FD6 08             9278             inc     Temp1
0FD7 76FF           9279             mov     @Temp1, #0FFh   ; Voltage comp
0FD9 08             9280             inc     Temp1
0FDA 7603           9281             mov     @Temp1, #DEFAULT_PGM_MAIN_COMM_TIMING
0FDC 08             9282             inc     Temp1
0FDD 76FF           9283             mov     @Temp1, #0FFh   ; Damping force
0FDF 08             9284             inc     Temp1
0FE0 7601           9285             mov     @Temp1, #DEFAULT_PGM_MAIN_GOVERNOR_RANGE
0FE2 08             9286             inc     Temp1
0FE3 76FF           9287             mov     @Temp1, #0FFh   ; Startup method        
0FE5 08             9288             inc     Temp1
0FE6 7625           9289             mov     @Temp1, #DEFAULT_PGM_PPM_MIN_THROTTLE
0FE8 08             9290             inc     Temp1
0FE9 76D0           9291             mov     @Temp1, #DEFAULT_PGM_PPM_MAX_THROTTLE
0FEB 08             9292             inc     Temp1
0FEC 7678           9293             mov     @Temp1, #DEFAULT_PGM_MAIN_BEEP_STRENGTH
0FEE 08             9294             inc     Temp1
0FEF 76C8           9295             mov     @Temp1, #DEFAULT_PGM_MAIN_BEACON_STRENGTH
0FF1 08             9296             inc     Temp1
0FF2 7604           9297             mov     @Temp1, #DEFAULT_PGM_MAIN_BEACON_DELAY
0FF4 08             9298             inc     Temp1
0FF5 76FF           9299             mov     @Temp1, #0FFh   ; Throttle rate
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   149

0FF7 08             9300             inc     Temp1
0FF8 7601           9301             mov     @Temp1, #DEFAULT_PGM_MAIN_DEMAG_COMP
0FFA 08             9302             inc     Temp1
0FFB 7600           9303             mov     @Temp1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
0FFD 08             9304             inc     Temp1
0FFE 767A           9305             mov     @Temp1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
1000 08             9306             inc     Temp1
1001 760A           9307             mov     @Temp1, #DEFAULT_PGM_MAIN_SPOOLUP_TIME
1003 08             9308             inc     Temp1
1004 7601           9309             mov     @Temp1, #DEFAULT_PGM_ENABLE_TEMP_PROT
1006 08             9310             inc     Temp1
1007 7601           9311             mov     @Temp1, #DEFAULT_PGM_ENABLE_POWER_PROT
1009 08             9312             inc     Temp1
100A 7600           9313             mov     @Temp1, #DEFAULT_PGM_ENABLE_PWM_INPUT
100C 08             9314             inc     Temp1
100D 76FF           9315             mov     @Temp1, #0FFh   ; Pwm dither
100F 08             9316             inc     Temp1
1010 7600           9317             mov     @Temp1, #DEFAULT_PGM_BRAKE_ON_STOP
                    9318     ENDIF
                    9319     IF MODE == 1    ; Tail
                                     mov     Temp1, #Pgm_Gov_P_Gain
                                     mov     @Temp1, #0FFh   
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Governor I gain
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Governor mode
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Low voltage limit
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_TAIL_GAIN
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_TAIL_IDLE_SPEED
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_TAIL_STARTUP_PWR
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_TAIL_PWM_FREQ
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_TAIL_DIRECTION
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_TAIL_RCP_PWM_POL
                             
                                     mov     Temp1, #Pgm_Enable_TX_Program
                                     mov     @Temp1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Main rearm start
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Governor setup target
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Startup rpm   
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Startup accel
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Voltage comp
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_TAIL_COMM_TIMING
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Damping force 
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Governor range
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Startup method        
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                                     inc     Temp1
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   150

                                     mov     @Temp1, #DEFAULT_PGM_TAIL_BEEP_STRENGTH
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_TAIL_BEACON_STRENGTH
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_TAIL_BEACON_DELAY
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Throttle rate 
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_TAIL_DEMAG_COMP
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_ENABLE_POWER_PROT
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_ENABLE_PWM_INPUT
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_TAIL_PWM_DITHER
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_BRAKE_ON_STOP
                             ENDIF
                    9392     IF MODE == 2    ; Multi
                                     mov     Temp1, #Pgm_Gov_P_Gain
                                     mov     @Temp1, #DEFAULT_PGM_MULTI_P_GAIN
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_MULTI_I_GAIN
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_MULTI_GOVERNOR_MODE
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Low voltage limit
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_MULTI_GAIN
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_MULTI_STARTUP_PWR
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_MULTI_PWM_FREQ
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_MULTI_DIRECTION
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_MULTI_RCP_PWM_POL
                             
                                     mov     Temp1, #Pgm_Enable_TX_Program
                                     mov     @Temp1, #DEFAULT_PGM_ENABLE_TX_PROGRAM
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Main rearm start
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Governor setup target
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Startup rpm   
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Startup accel
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Voltage comp
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_MULTI_COMM_TIMING
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Damping force 
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Governor range
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   151

                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Startup method        
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_PPM_MIN_THROTTLE
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_PPM_MAX_THROTTLE
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_MULTI_BEEP_STRENGTH
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_MULTI_BEACON_STRENGTH
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_MULTI_BEACON_DELAY
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   ; Throttle rate 
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_MULTI_DEMAG_COMP
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_BEC_VOLTAGE_HIGH
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_PPM_CENTER_THROTTLE
                                     inc     Temp1
                                     mov     @Temp1, #0FFh   
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_ENABLE_TEMP_PROT
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_ENABLE_POWER_PROT
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_ENABLE_PWM_INPUT
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_MULTI_PWM_DITHER
                                     inc     Temp1
                                     mov     @Temp1, #DEFAULT_PGM_BRAKE_ON_STOP
                             ENDIF
1012 22             9465             ret
                    9466     
                    9467     
                    9468     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    9469     ;
                    9470     ; Decode parameters
                    9471     ;
                    9472     ; No assumptions
                    9473     ;
                    9474     ; Decodes programming parameters
                    9475     ;
                    9476     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
1013                9477     decode_parameters:
                    9478             ; Load programmed pwm frequency
1013 7887           9479             mov     Temp1, #Pgm_Pwm_Freq    ; Load pwm freq
1015 E6             9480             mov     A, @Temp1                               
1016 FF             9481             mov     Temp8, A                                ; Store in Temp8
1017 C272           9482             clr     Flags2.PGM_PWMOFF_DAMPED
                    9483     IF DAMPED_MODE_ENABLE == 1
1019 BF0302         9484             cjne    Temp8, #3, ($+5)
101C D272           9485             setb    Flags2.PGM_PWMOFF_DAMPED
                    9486     ENDIF
                    9487             ; Load programmed direction
101E 7888           9488             mov     Temp1, #Pgm_Direction   
                    9489     IF MODE >= 1    ; Tail or multi
                                     mov     A, @Temp1                               
                                     clr     C
                                     subb    A, #3
                                     jz      decode_params_dir_set
                             ENDIF
                    9495     
1020 C27D           9496             clr     Flags3.PGM_DIR_REV
1022 E6             9497             mov     A, @Temp1                               
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   152

1023 30E102         9498             jnb     ACC.1, ($+5)
1026 D27D           9499             setb    Flags3.PGM_DIR_REV
1028                9500     decode_params_dir_set:
1028 C27E           9501             clr     Flags3.PGM_RCP_PWM_POL
102A 7889           9502             mov     Temp1, #Pgm_Input_Pol   
102C E6             9503             mov     A, @Temp1                               
102D 30E102         9504             jnb     ACC.1, ($+5)
1030 D27E           9505             setb    Flags3.PGM_RCP_PWM_POL
1032 C3             9506             clr     C
1033 EF             9507             mov     A, Temp8                        
1034 9402           9508             subb    A, #2
1036 6007           9509             jz      decode_pwm_freq_low
                    9510     
1038 758E01         9511             mov     CKCON, #01h             ; Timer0 set for clk/4 (22kHz pwm)
103B D273           9512             setb    Flags2.PGM_PWM_HIGH_FREQ
103D 8005           9513             jmp     decode_pwm_freq_end
                    9514     
103F                9515     decode_pwm_freq_low:
103F 758E00         9516             mov     CKCON, #00h             ; Timer0 set for clk/12 (8kHz pwm)
1042 C273           9517             clr     Flags2.PGM_PWM_HIGH_FREQ
                    9518     
1044                9519     decode_pwm_freq_end:
1044 22             9520             ret
                    9521     
                    9522     
                    9523     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    9524     ;
                    9525     ; Decode settings
                    9526     ;
                    9527     ; No assumptions
                    9528     ;
                    9529     ; Decodes various settings
                    9530     ;
                    9531     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
1045                9532     decode_settings:
                    9533             ; Decode governor gains
1045 7880           9534             mov     Temp1, #Pgm_Gov_P_Gain  ; Decode governor P gain        
1047 E6             9535             mov     A, @Temp1                               
1048 14             9536             dec     A       
1049 900080         9537             mov     DPTR, #GOV_GAIN_TABLE
104C 93             9538             movc A, @A+DPTR 
104D 78A5           9539             mov     Temp1, #Pgm_Gov_P_Gain_Decoded
104F F6             9540             mov     @Temp1, A       
1050 7881           9541             mov     Temp1, #Pgm_Gov_I_Gain  ; Decode governor I gain
1052 E6             9542             mov     A, @Temp1                               
1053 14             9543             dec     A       
1054 900080         9544             mov     DPTR, #GOV_GAIN_TABLE
1057 93             9545             movc A, @A+DPTR 
1058 78A6           9546             mov     Temp1, #Pgm_Gov_I_Gain_Decoded
105A F6             9547             mov     @Temp1, A       
                    9548             ; Decode startup power
105B 7886           9549             mov     Temp1, #Pgm_Startup_Pwr         
105D E6             9550             mov     A, @Temp1                               
105E 14             9551             dec     A       
105F 90008D         9552             mov     DPTR, #STARTUP_POWER_TABLE
1062 93             9553             movc A, @A+DPTR 
1063 78A7           9554             mov     Temp1, #Pgm_Startup_Pwr_Decoded
1065 F6             9555             mov     @Temp1, A       
                    9556     IF MODE == 0    ; Main
                    9557             ; Decode spoolup time
1066 789F           9558             mov     Temp1, #Pgm_Main_Spoolup_Time           
1068 E6             9559             mov     A, @Temp1
1069 F8             9560             mov     Temp1, A                ; Store
106A 7005           9561             jnz     decode_main_spoolup_nonzero     ; If not zero - branch
                    9562             
106C 756B00         9563             mov     Main_Spoolup_Time_3x, #0        
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   153

106F 018B           9564             ajmp    decode_main_spoolup_done
                    9565     
1071                9566     decode_main_spoolup_nonzero:
1071 C3             9567             clr     C
1072 E8             9568             mov     A, Temp1
1073 9411           9569             subb    A, #17          ; Limit to 17 max
1075 4002           9570             jc      ($+4)
                    9571     
1077 7811           9572             mov     Temp1, #17
                    9573     
1079 E8             9574             mov     A, Temp1
107A 28             9575             add     A, Temp1
107B 28             9576             add     A, Temp1                ; Now 3x
107C F56B           9577             mov     Main_Spoolup_Time_3x, A
107E 256B           9578             add     A, Main_Spoolup_Time_3x
1080 256B           9579             add     A, Main_Spoolup_Time_3x
1082 28             9580             add     A, Temp1                ; Now 10x
1083 F56C           9581             mov     Main_Spoolup_Time_10x, A
1085 256B           9582             add     A, Main_Spoolup_Time_3x
1087 28             9583             add     A, Temp1                
1088 28             9584             add     A, Temp1                ; Now 15x
1089 F56D           9585             mov     Main_Spoolup_Time_15x, A
108B                9586     decode_main_spoolup_done:
                    9587     ENDIF
                    9588             ; Decode low rpm power slope
108B 7886           9589             mov     Temp1, #Pgm_Startup_Pwr
108D E6             9590             mov     A, @Temp1
108E F539           9591             mov     Low_Rpm_Pwr_Slope, A
1090 C3             9592             clr     C       
1091 9402           9593             subb    A, #2
1093 5003           9594             jnc     ($+5)
1095 753902         9595             mov     Low_Rpm_Pwr_Slope, #2
                    9596             ; Decode demag compensation
1098 789C           9597             mov     Temp1, #Pgm_Demag_Comp          
109A E6             9598             mov     A, @Temp1                               
109B 7538FF         9599             mov     Demag_Pwr_Off_Thresh, #255      ; Set default
                    9600     
109E B40203         9601             cjne    A, #2, decode_demag_high
                    9602     
10A1 7538A0         9603             mov     Demag_Pwr_Off_Thresh, #160      ; Settings for demag comp low
                    9604     
10A4                9605     decode_demag_high:
10A4 B40303         9606             cjne    A, #3, decode_demag_done
                    9607     
10A7 753882         9608             mov     Demag_Pwr_Off_Thresh, #130      ; Settings for demag comp high
                    9609     
10AA                9610     decode_demag_done:
                    9611             ; Decode pwm dither
10AA 78A3           9612             mov     Temp1, #Pgm_Pwm_Dither          
10AC E6             9613             mov     A, @Temp1                               
10AD 14             9614             dec     A       
10AE 90009A         9615             mov     DPTR, #PWM_DITHER_TABLE
10B1 93             9616             movc A, @A+DPTR 
10B2 F566           9617             mov     Pwm_Dither_Decoded, A
10B4 120F92         9618             call    switch_power_off                        ; Reset DPTR
10B7 22             9619             ret
                    9620     
                    9621     
                    9622     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    9623     ;
                    9624     ; Set BEC voltage
                    9625     ;
                    9626     ; No assumptions
                    9627     ;
                    9628     ; Sets the BEC output voltage low or high
                    9629     ;
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   154

                    9630     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
10B8                9631     set_bec_voltage:
                    9632             ; Set bec voltage
                    9633     IF HIGH_BEC_VOLTAGE == 1
                                     Set_BEC_Lo                      ; Set default to low
                                     mov     Temp1, #Pgm_BEC_Voltage_High            
                                     mov     A, @Temp1                               
                                     jz      set_bec_voltage_exit    
                             
                                     Set_BEC_Hi                      ; Set to high
                             
                             set_bec_voltage_exit:
                             ENDIF
                    9643     IF HIGH_BEC_VOLTAGE == 2
                                     Set_BEC_0                               ; Set default to low
                                     mov     Temp1, #Pgm_BEC_Voltage_High            
                                     mov     A, @Temp1                               
                                     cjne    A, #1, set_bec_voltage_2        
                             
                                     Set_BEC_1                               ; Set to level 1
                             
                             set_bec_voltage_2:
                                     cjne    A, #2, set_bec_voltage_exit     
                             
                                     Set_BEC_2                               ; Set to level 2
                             
                             set_bec_voltage_exit:
                             ENDIF
10B8 22             9658             ret
                    9659     
                    9660     
                    9661     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    9662     ;
                    9663     ; Find throttle gain
                    9664     ;
                    9665     ; The difference between max and min throttle must be more than 520us (a Pgm_Ppm_xxx_Thrott
                             le difference of 130)
                    9666     ;
                    9667     ; Finds throttle gain from throttle calibration values
                    9668     ;
                    9669     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
10B9                9670     find_throttle_gain:
                    9671             ; Load programmed minimum and maximum throttle
10B9 7896           9672             mov     Temp1, #Pgm_Ppm_Min_Throttle
10BB E6             9673             mov     A, @Temp1                               
10BC FA             9674             mov     Temp3, A                        
10BD 7897           9675             mov     Temp1, #Pgm_Ppm_Max_Throttle
10BF E6             9676             mov     A, @Temp1                               
10C0 FB             9677             mov     Temp4, A                        
10C1 7888           9678             mov     Temp1, #Pgm_Direction   ; Check if bidirectional operation
10C3 E6             9679             mov     A, @Temp1                               
10C4 B40305         9680             cjne    A, #3, find_throttle_gain_check_full
                    9681     
10C7 C3             9682             clr     C
10C8 EB             9683             mov     A, Temp4                        
10C9 940E           9684             subb    A, #14                          ; Compensate for higher deadband in bidirec
                             tional
10CB FB             9685             mov     Temp4, A                        
                    9686     
10CC                9687     find_throttle_gain_check_full:
                    9688             ; Check if full range is chosen
10CC 307F04         9689             jnb     Flags3.FULL_THROTTLE_RANGE, find_throttle_gain_calculate
                    9690     
10CF 7A00           9691             mov     Temp3, #0                       
10D1 7BFF           9692             mov     Temp4, #255             
                    9693     
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   155

10D3                9694     find_throttle_gain_calculate:
                    9695             ; Calculate difference
10D3 C3             9696             clr     C
10D4 EB             9697             mov     A, Temp4
10D5 9A             9698             subb    A, Temp3
10D6 FC             9699             mov     Temp5, A
                    9700             ; Check that difference is minimum 130
10D7 C3             9701             clr     C
10D8 9482           9702             subb    A, #130
10DA 5002           9703             jnc     ($+4)
                    9704     
10DC 7C82           9705             mov     Temp5, #130
                    9706     
                    9707             ; Find gain
10DE 757200         9708             mov     Ppm_Throttle_Gain, #0
10E1                9709     test_throttle_gain:
10E1 0572           9710             inc     Ppm_Throttle_Gain
10E3 EC             9711             mov     A, Temp5
10E4 8572F0         9712             mov     B, Ppm_Throttle_Gain    ; A has difference, B has gain
10E7 A4             9713             mul     AB
10E8 C3             9714             clr     C
10E9 E5F0           9715             mov     A, B
10EB 947D           9716             subb    A, #125
10ED 40F2           9717             jc      test_throttle_gain
10EF 22             9718             ret
                    9719     
                    9720     
                    9721     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    9722     ;
                    9723     ; Average throttle 
                    9724     ;
                    9725     ; Outputs result in Temp7
                    9726     ;
                    9727     ; Averages throttle calibration readings
                    9728     ;
                    9729     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
10F0                9730     average_throttle:
10F0 D27F           9731             setb    Flags3.FULL_THROTTLE_RANGE      ; Set range to 1000-2020us
10F2 11B9           9732             call    find_throttle_gain      ; Set throttle gain
10F4 120555         9733             call wait30ms           
10F7 120555         9734             call wait30ms           
10FA 7A00           9735             mov     Temp3, #0
10FC 7B00           9736             mov     Temp4, #0
10FE 7C10           9737             mov     Temp5, #16              ; Average 16 measurments
1100                9738     average_throttle_meas:
1100 12054D         9739             call    wait3ms                 ; Wait for new RC pulse value
1103 E55C           9740             mov     A, New_Rcp              ; Get new RC pulse value
1105 2A             9741             add     A, Temp3
1106 FA             9742             mov     Temp3, A
1107 7400           9743             mov     A, #0
1109 3B             9744             addc A, Temp4
110A FB             9745             mov     Temp4, A
110B DCF3           9746             djnz    Temp5, average_throttle_meas
                    9747     
110D 7C04           9748             mov     Temp5, #4                       ; Shift 4 times
110F                9749     average_throttle_div:
110F C3             9750             clr     C
1110 EB             9751             mov     A, Temp4                ; Shift right 
1111 13             9752             rrc     A      
1112 FB             9753             mov     Temp4, A   
1113 EA             9754             mov     A, Temp3   
1114 13             9755             rrc     A      
1115 FA             9756             mov     Temp3, A   
1116 DCF7           9757             djnz    Temp5, average_throttle_div
                    9758     
1118 FE             9759             mov     Temp7, A                ; Copy to Temp7
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   156

1119 C27F           9760             clr     Flags3.FULL_THROTTLE_RANGE      
111B 11B9           9761             call    find_throttle_gain      ; Set throttle gain
111D 22             9762             ret
                    9763     
                    9764     
                    9765     
                    9766     
                    9767     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    9768     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    9769     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    9770     ;
                    9771     ; Main program start
                    9772     ;
                    9773     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    9774     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    9775     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
111E                9776     pgm_start:
                    9777             ; Initialize flash keys to invalid values
111E 757C00         9778             mov     Flash_Key_1, #0
1121 757D00         9779             mov     Flash_Key_2, #0
                    9780             ; Check flash lock byte
1124 E5EF           9781             mov     A, RSTSRC                       
1126 20E603         9782             jb      ACC.6, ($+6)            ; Check if flash access error was reset source 
                    9783     
1129 752000         9784             mov     Bit_Access, #0          ; No - then this is the first try
                    9785     
112C 0520           9786             inc     Bit_Access
112E 903FFF         9787             mov     DPTR, #LOCK_BYTE_ADDRESS_16K    ; First try is for 16k flash size
1131 E520           9788             mov     A, Bit_Access
1133 14             9789             dec     A
1134 6006           9790             jz      lock_byte_test
                    9791     
1136 901FFF         9792             mov     DPTR, #LOCK_BYTE_ADDRESS_8K     ; Second try is for 8k flash size
1139 14             9793             dec     A
113A 6000           9794             jz      lock_byte_test
                    9795     
113C                9796     lock_byte_test:
113C 93             9797             movc A, @A+DPTR         ; Read lock byte
113D 04             9798             inc     A                               
113E 6003           9799             jz      lock_byte_ok            ; If lock byte is 0xFF, then start code execution
                    9800     
                    9801     IF ONE_S_CAPABLE == 0           
1140 75EF16         9802             mov     RSTSRC, #16h                    ; Generate hardware reset and set missing c
                             lock and VDD monitor
                    9803     ELSE
                                     mov     RSTSRC, #14h                    ; Generate hardware reset and disable VDD m
                             onitor
                             ENDIF
                    9806     
1143                9807     lock_byte_ok:
                    9808             ; Disable the WDT.
                    9809     IF SIGNATURE_001 == 0f3h                
                                     anl     PCA0MD, #NOT(40h)       ; Clear watchdog enable bit
                             ENDIF
                    9812     IF SIGNATURE_001 == 0f8h                
1143 7597DE         9813             mov     WDTCN, #0DEh            ; Disable watchdog
1146 7597AD         9814             mov     WDTCN, #0ADh            
                    9815     ENDIF
                    9816             ; Initialize stack
1149 7581C0         9817             mov     SP, #0c0h                       ; Stack = 64 upper bytes of RAM
                    9818             ; Initialize VDD monitor
114C 43FF80         9819             orl     VDM0CN, #080h           ; Enable the VDD monitor
114F 120549         9820             call    wait1ms                 ; Wait at least 100us
                    9821     IF ONE_S_CAPABLE == 0           
1152 75EF06         9822             mov     RSTSRC, #06h    ; Set missing clock and VDD monitor as a reset source if no
                             t 1S capable
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   157

                    9823     ELSE
                                     mov     RSTSRC, #04h    ; Do not set VDD monitor as a reset source for 1S ESCSs, in
                              order to avoid resets due to it
                             ENDIF
                    9826             ; Set clock frequency
                    9827     IF SIGNATURE_001 == 0f3h                
                                     orl     OSCICN, #03h            ; Set clock divider to 1 (not supported on 'f850)
                             ENDIF
                    9830     IF SIGNATURE_001 == 0f8h                
1155 75A900         9831             mov     CLKSEL, #00h            ; Set clock divider to 1 (not supported on 'f3xx)
                    9832     ENDIF
1158 E5C7           9833             mov     A, OSCICL                               
115A 2402           9834             add     A, #02h                 ; 24.5MHz to 24MHz (~0.5-1% per step)
115C 20E70D         9835             jb      ACC.7, reset_cal_done   ; Is carry (7bit) set? - branch
                    9836     
115F F521           9837             mov     Bit_Access_Int, A
                    9838     IF SIGNATURE_002 <> 010h                
1161 E5B1           9839             mov     A, OSCLCN
                    9840     ELSE
                                     mov     A, OSCXCN
                             ENDIF
1163 20E006         9843             jb      ACC.0, reset_cal_done   ; Set if cal aleady done
                    9844     
1166 8521C7         9845             mov     OSCICL, Bit_Access_Int
                    9846     IF SIGNATURE_002 <> 010h                
1169 43B101         9847             orl     OSCLCN, #01h                    ; Tag that cal is done
                    9848     ELSE
                                     orl     OSCXCN, #01h                    ; Tag that cal is done
                             ENDIF
                    9851     
116C                9852     reset_cal_done:
                    9853             ; Switch power off
116C 120F92         9854             call    switch_power_off
                    9855             ; Ports initialization
116F 7580FF         9856             mov     P0, #P0_INIT                            
1172 75A400         9857             mov     P0MDOUT, #P0_PUSHPULL                           
1175 75F1B0         9858             mov     P0MDIN, #P0_DIGITAL                             
1178 75D4DF         9859             mov     P0SKIP, #P0_SKIP                                
117B 759015         9860             mov     P1, #P1_INIT                            
117E 75A53F         9861             mov     P1MDOUT, #P1_PUSHPULL                           
1181 75F23F         9862             mov     P1MDIN, #P1_DIGITAL                             
1184 75D500         9863             mov     P1SKIP, #P1_SKIP                                
                    9864     IF PORT3_EXIST == 1
                                     mov     P2, #P2_INIT                            
                             ENDIF
1187 75A601         9867             mov     P2MDOUT, #P2_PUSHPULL                           
                    9868     IF PORT3_EXIST == 1
                                     mov     P2MDIN, #P2_DIGITAL                             
                                     mov     P2SKIP, #P2_SKIP                                
                                     mov     P3, #P3_INIT                            
                                     mov     P3MDOUT, #P3_PUSHPULL                           
                                     mov     P3MDIN, #P3_DIGITAL                             
                             ENDIF
                    9875             ; Initialize the XBAR and related functionality
                    9876             Initialize_Xbar
                    9879             ; Switch power off again, after initializing ports
1190 120F92         9880             call    switch_power_off
                    9881             ; Clear RAM
1193 E4             9882             clr     A                               ; Clear accumulator
1194 F8             9883             mov     Temp1, A                        ; Clear Temp1
1195                9884     clear_ram:      
1195 F6             9885             mov     @Temp1, A                       ; Clear RAM
1196 D8FD           9886             djnz Temp1, clear_ram   ; Is A not zero? - jump
                    9887             ; Initialize LFSR
1198 756801         9888             mov     Random, #1
                    9889             ; Set default programmed parameters
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   158

119B 120FA7         9890             call    set_default_parameters
                    9891             ; Read all programmed parameters
119E D14F           9892             call read_all_eeprom_parameters
                    9893             ; Set beep strength
11A0 7898           9894             mov     Temp1, #Pgm_Beep_Strength
11A2 8673           9895             mov     Beep_Strength, @Temp1
                    9896             ; Set initial arm variable
11A4 753001         9897             mov     Initial_Arm, #1
                    9898             ; Initializing beep
11A7 C2AF           9899             clr     EA                              ; Disable interrupts explicitly
11A9 12055D         9900             call wait200ms  
11AC 12056C         9901             call beep_f1
11AF 120555         9902             call wait30ms
11B2 120572         9903             call beep_f2
11B5 120555         9904             call wait30ms
11B8 120578         9905             call beep_f3
11BB 120555         9906             call wait30ms
                    9907     IF MODE <= 1    ; Main or tail
                    9908             ; Wait for receiver to initialize
11BE F172           9909             call    wait1s
11C0 12055D         9910             call    wait200ms
11C3 12055D         9911             call    wait200ms
11C6 120559         9912             call    wait100ms
                    9913     ENDIF
                    9914     
                    9915     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                    9916     ;
                    9917     ; No signal entry point
                    9918     ;
                    9919     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
11C9                9920     init_no_signal:
                    9921             ; Disable interrupts explicitly
11C9 C2AF           9922             clr     EA                              
                    9923             ; Initialize flash keys to invalid values
11CB 757C00         9924             mov     Flash_Key_1, #0
11CE 757D00         9925             mov     Flash_Key_2, #0
                    9926             ; Check if input signal is high for more than 15ms
11D1 78FA           9927             mov     Temp1, #250
11D3                9928     input_high_check_1:
11D3 79FA           9929             mov     Temp2, #250
11D5                9930     input_high_check_2:
11D5 308507         9931             jnb     RTX_PORT.RTX_PIN, bootloader_done       ; Look for low
11D8 D9FB           9932             djnz    Temp2, input_high_check_2
11DA D8F7           9933             djnz    Temp1, input_high_check_1
                    9934     
11DC 021C00         9935             ljmp    1C00h                   ; Jump to bootloader
                    9936     
11DF                9937     bootloader_done:
                    9938             ; Decode parameters
11DF 1113           9939             call    decode_parameters
                    9940             ; Decode settings
11E1 1145           9941             call    decode_settings
                    9942             ; Set BEC voltage
11E3 11B8           9943             call    set_bec_voltage
                    9944             ; Find throttle gain from stored min and max settings
11E5 11B9           9945             call    find_throttle_gain
                    9946             ; Set beep strength
11E7 7898           9947             mov     Temp1, #Pgm_Beep_Strength
11E9 8673           9948             mov     Beep_Strength, @Temp1
                    9949             ; Switch power off
11EB 120F92         9950             call    switch_power_off
                    9951             ; Set clock frequency
                    9952     IF MCU_48MHZ == 1
                                     Set_MCU_Clk_24MHz
                             ENDIF
                    9955             ; Timer control
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   159

11EE 758810         9956             mov     TCON, #10h              ; Timer0 enabled
                    9957             ; Timer mode
11F1 758902         9958             mov     TMOD, #02h              ; Timer0 as 8bit
                    9959             ; Timer2: clk/12 for 128us and 32ms interrupts
11F4 75C824         9960             mov     TMR2CN, #24h            ; Timer2 enabled, low counter interrups enabled 
                    9961             ; Timer3: clk/12 for commutation timing
11F7 759104         9962             mov     TMR3CN, #04h            ; Timer3 enabled
                    9963             ; PCA
11FA 75D840         9964             mov     PCA0CN, #40h            ; PCA enabled
                    9965             ; Enable interrupts
11FD 75A822         9966             mov     IE, #22h                        ; Enable timer0 and timer2 interrupts
1200 75B802         9967             mov     IP, #02h                        ; High priority to timer0 interrupts
1203 75E690         9968             mov     EIE1, #90h              ; Enable timer3 and PCA0 interrupts
                    9969             ; Initialize comparator
1206 759B80         9970             mov     CPT0CN, #80h            ; Comparator enabled, no hysteresis
1209 759D00         9971             mov     CPT0MD, #00h            ; Comparator response time 100ns
                    9972     IF COMP1_USED == 1                      
                                     mov     CPT1CN, #80h            ; Comparator enabled, no hysteresis
                                     mov     CPT1MD, #00h            ; Comparator response time 100ns
                             ENDIF
                    9976             ; Initialize ADC
                    9977             Initialize_Adc                  ; Initialize ADC operation
121B 120549         9983             call    wait1ms
121E D2AF           9984             setb    EA                              ; Enable all interrupts
                    9985             ; Measure number of lipo cells
1220 120881         9986             call Measure_Lipo_Cells                 ; Measure number of lipo cells
                    9987             ; Reset stall count
1223 753600         9988             mov     Stall_Cnt, #0
                    9989             ; Initialize RC pulse
                    9990             Rcp_Int_First                                   ; Enable interrupt and set to first
                              edge
                    9996             Rcp_Int_Enable                                  ; Enable interrupt
                    9998             Rcp_Clear_Int_Flag                              ; Clear interrupt flag
123A C271          10000             clr     Flags2.RCP_EDGE_NO                      ; Set first edge flag
123C 12055D        10001             call wait200ms
                   10002     
                   10003             ; Measure PWM frequency
123F               10004     measure_pwm_freq_init:  
123F D261          10005             setb    Flags0.RCP_MEAS_PWM_FREQ                ; Set measure pwm frequency flag
1241 7B03          10006             mov     Temp4, #3                                               ; Number of attempt
                             s before going back to detect input signal
1243               10007     measure_pwm_freq_start: 
1243 7A0C          10008             mov     Temp3, #12                                      ; Number of pulses to measu
                             re
1245               10009     measure_pwm_freq_loop:  
                   10010             ; Check if period diff was accepted
1245 E55B          10011             mov     A, Rcp_Period_Diff_Accepted
1247 7007          10012             jnz     measure_pwm_freq_wait
                   10013     
1249 7A0C          10014             mov     Temp3, #12                                      ; Reset number of pulses to
                              measure
124B DB03          10015             djnz    Temp4, ($+5)                                    ; If it is not zero - proce
                             ed
124D 0211C9        10016             ljmp    init_no_signal                                  ; Go back to detect input s
                             ignal
                   10017     
1250               10018     measure_pwm_freq_wait:
1250 120555        10019             call    wait30ms                                                ; Wait 30ms for new
                              pulse
1253 207003        10020             jb      Flags2.RCP_UPDATED, ($+6)               ; Is there an updated RC pulse avai
                             lable - proceed
1256 0211C9        10021             ljmp    init_no_signal                                  ; Go back to detect input s
                             ignal
                   10022     
1259 C270          10023             clr     Flags2.RCP_UPDATED                              ; Flag that pulse has been 
                             evaluated
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   160

125B E55C          10024             mov     A, New_Rcp                                      ; Load value
125D C3            10025             clr     C
125E 9402          10026             subb    A, #RCP_VALIDATE                                ; Higher than validate leve
                             l?
1260 40E1          10027             jc      measure_pwm_freq_start                  ; No - start over
                   10028     
1262 E52F          10029             mov     A, Flags3                                               ; Check pwm frequen
                             cy flags
1264 541F          10030             anl     A, #((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_FRE
                             Q_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1266 855E5D        10031             mov     Prev_Rcp_Pwm_Freq, Curr_Rcp_Pwm_Freq            ; Store as previous flags f
                             or next pulse 
1269 F55E          10032             mov     Curr_Rcp_Pwm_Freq, A                                    ; Store current fla
                             gs for next pulse 
126B B55DD5        10033             cjne    A, Prev_Rcp_Pwm_Freq, measure_pwm_freq_start    ; Go back if new flags not 
                             same as previous
                   10034     
126E DAD5          10035             djnz    Temp3, measure_pwm_freq_loop                            ; Go back if not re
                             quired number of pulses seen
                   10036     
                   10037             ; Clear measure pwm frequency flag
1270 C261          10038             clr     Flags0.RCP_MEAS_PWM_FREQ                
                   10039             ; Set up RC pulse interrupts after pwm frequency measurement
                   10040             Rcp_Int_First                                           ; Enable interrupt and set 
                             to first edge
                   10046             Rcp_Clear_Int_Flag                                      ; Clear interrupt flag
1283 C271          10048             clr     Flags2.RCP_EDGE_NO                              ; Set first edge flag
1285 78A2          10049             mov     Temp1, #Pgm_Enable_PWM_Input            ; Check if PWM input is enabled
1287 E6            10050             mov     A, @Temp1
1288 7008          10051             jnz     test_for_oneshot                                ; If it is - proceed
                   10052     
128A D274          10053             setb    Flags2.RCP_PPM                                  ; Set PPM flag
128C E52F          10054             mov     A, Flags3                                               ; Clear pwm frequen
                             cy flags
128E 54E0          10055             anl     A, #NOT((1 SHL RCP_PWM_FREQ_1KHZ)+(1 SHL RCP_PWM_FREQ_2KHZ)+(1 SHL RCP_PWM_
                             FREQ_4KHZ)+(1 SHL RCP_PWM_FREQ_8KHZ)+(1 SHL RCP_PWM_FREQ_12KHZ))
1290 F52F          10056             mov     Flags3, A
                   10057     
1292               10058     test_for_oneshot:       
                   10059             ; Test whether signal is OneShot125
1292 C275          10060             clr     Flags2.RCP_PPM_ONESHOT125               ; Clear OneShot125 flag
1294 752900        10061             mov     Rcp_Outside_Range_Cnt, #0               ; Reset out of range counter
1297 120559        10062             call wait100ms                                          ; Wait for new RC pulse
129A 307409        10063             jnb     Flags2.RCP_PPM, validate_rcp_start      ; If flag is not set (PWM) - branch
                   10064     
129D C3            10065             clr     C
129E E529          10066             mov     A, Rcp_Outside_Range_Cnt                        ; Check how many pulses wer
                             e outside normal PPM range (800-2160us)
12A0 940A          10067             subb    A, #10                                          
12A2 4002          10068             jc      validate_rcp_start
                   10069     
12A4 D275          10070             setb    Flags2.RCP_PPM_ONESHOT125               ; Set OneShot125 flag
                   10071     
                   10072             ; Validate RC pulse
12A6               10073     validate_rcp_start:     
12A6 12054D        10074             call wait3ms                                            ; Wait for next pulse (NB: 
                             Uses Temp1/2!) 
12A9 7802          10075             mov     Temp1, #RCP_VALIDATE                    ; Set validate level as default
12AB 307402        10076             jnb     Flags2.RCP_PPM, ($+5)                   ; If flag is not set (PWM) - branch
                   10077     
12AE 7800          10078             mov     Temp1, #0                                               ; Set level to zero
                              for PPM (any level will be accepted)
                   10079     
12B0 C3            10080             clr     C
12B1 E55C          10081             mov     A, New_Rcp                                      ; Load value
12B3 98            10082             subb    A, Temp1                                                ; Higher than valid
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   161

                             ate level?
12B4 40F0          10083             jc      validate_rcp_start                              ; No - start over
                   10084     
                   10085             ; Beep arm sequence start signal
12B6 C2AF          10086             clr     EA                                                      ; Disable all inter
                             rupts
12B8 12056C        10087             call beep_f1                                            ; Signal that RC pulse is r
                             eady
12BB 12056C        10088             call beep_f1
12BE 12056C        10089             call beep_f1
12C1 D2AF          10090             setb    EA                                                      ; Enable all interr
                             upts
12C3 12055D        10091             call wait200ms  
                   10092     
                   10093             ; Arming sequence start
12C6 754C00        10094             mov     Gov_Arm_Target, #0              ; Clear governor arm target
12C9               10095     arming_start:
                   10096     IF MODE >= 1    ; Tail or multi
                                     mov     Temp1, #Pgm_Direction   ; Check if bidirectional operation
                                     mov     A, @Temp1                               
                                     cjne    A, #3, ($+5)
                             
                                     ajmp    program_by_tx_checked   ; Disable tx programming if bidirectional operation
                             ENDIF
                   10103     
12C9 12054D        10104             call wait3ms
12CC 788C          10105             mov     Temp1, #Pgm_Enable_TX_Program; Start programming mode entry if enabled
12CE E6            10106             mov     A, @Temp1                               
12CF C3            10107             clr     C
12D0 9401          10108             subb    A, #1                           ; Is TX programming enabled?
12D2 5002          10109             jnc     arming_initial_arm_check        ; Yes - proceed
                   10110     
12D4 61AE          10111             jmp     program_by_tx_checked   ; No - branch
                   10112     
12D6               10113     arming_initial_arm_check:
12D6 E530          10114             mov     A, Initial_Arm                  ; Yes - check if it is initial arm sequence
12D8 C3            10115             clr     C
12D9 9401          10116             subb    A, #1                           ; Is it the initial arm sequence?
12DB 5002          10117             jnc     arming_ppm_check                ; Yes - proceed
                   10118     
12DD 61AE          10119             jmp     program_by_tx_checked   ; No - branch
                   10120     
12DF               10121     arming_ppm_check:
                   10122             ; Initialize flash keys to valid values
12DF 757CA5        10123             mov     Flash_Key_1, #0A5h
12E2 757DF1        10124             mov     Flash_Key_2, #0F1h
12E5 207433        10125             jb      Flags2.RCP_PPM, throttle_high_cal_start ; If flag is set (PPM) - branch
                   10126     
                   10127             ; PWM tx program entry
12E8 C3            10128             clr     C
12E9 E55C          10129             mov     A, New_Rcp                      ; Load new RC pulse value
12EB 94FF          10130             subb    A, #RCP_MAX                     ; Is RC pulse max?
12ED 5002          10131             jnc     program_by_tx_entry_pwm ; Yes - proceed
                   10132     
12EF 61AE          10133             jmp     program_by_tx_checked   ; No - branch
                   10134     
12F1               10135     program_by_tx_entry_pwm:        
12F1 C2AF          10136             clr     EA                                      ; Disable all interrupts
12F3 12057E        10137             call beep_f4
12F6 D2AF          10138             setb    EA                                      ; Enable all interrupts
12F8 120559        10139             call wait100ms
12FB C3            10140             clr     C
12FC E55C          10141             mov     A, New_Rcp                      ; Load new RC pulse value
12FE 9401          10142             subb    A, #RCP_STOP                    ; Below stop?
1300 50EF          10143             jnc     program_by_tx_entry_pwm ; No - start over
                   10144     
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   162

1302               10145     program_by_tx_entry_wait_pwm:   
1302 C2AF          10146             clr     EA                                      ; Disable all interrupts
1304 12056C        10147             call beep_f1
1307 120551        10148             call wait10ms
130A 12056C        10149             call beep_f1
130D D2AF          10150             setb    EA                                      ; Enable all interrupts
130F 120559        10151             call wait100ms
1312 C3            10152             clr     C
1313 E55C          10153             mov     A, New_Rcp                      ; Load new RC pulse value
1315 94FF          10154             subb    A, #RCP_MAX                     ; At or above max?
1317 40E9          10155             jc      program_by_tx_entry_wait_pwm    ; No - start over
                   10156     
1319 E1F7          10157             jmp     program_by_tx                   ; Yes - enter programming mode
                   10158     
                   10159             ; PPM throttle calibration and tx program entry
131B               10160     throttle_high_cal_start:
                   10161     IF MODE <= 1    ; Main or tail
131B 7F05          10162             mov     Temp8, #5                               ; Set 3 seconds wait time
                   10163     ELSE
                                     mov     Temp8, #2                               ; Set 1 seconds wait time
                             ENDIF
131D               10166     throttle_high_cal:                      
131D D27F          10167             setb    Flags3.FULL_THROTTLE_RANGE      ; Set range to 1000-2020us
131F 11B9          10168             call    find_throttle_gain              ; Set throttle gain
1321 120559        10169             call wait100ms                          ; Wait for new throttle value
1324 C2AF          10170             clr     EA                                      ; Disable interrupts (freeze New_Rc
                             p value)
1326 C27F          10171             clr     Flags3.FULL_THROTTLE_RANGE      ; Set programmed range
1328 11B9          10172             call    find_throttle_gain              ; Set throttle gain
132A AE5C          10173             mov     Temp7, New_Rcp                  ; Store new RC pulse value
132C C3            10174             clr     C
132D E55C          10175             mov     A, New_Rcp                      ; Load new RC pulse value
132F 947F          10176             subb    A, #(RCP_MAX/2)         ; Is RC pulse above midstick?
1331 D2AF          10177             setb    EA                                      ; Enable interrupts
1333 5002          10178             jnc     ($+4)           
1335 61BE          10179             ajmp    arm_target_updated              ; No - branch
                   10180     
1337 120549        10181             call wait1ms            
133A C2AF          10182             clr     EA                                      ; Disable all interrupts
133C 12057E        10183             call beep_f4
133F D2AF          10184             setb    EA                                      ; Enable all interrupts
1341 DFDA          10185             djnz    Temp8, throttle_high_cal        ; Continue to wait
                   10186     
1343 11F0          10187             call    average_throttle
1345 C3            10188             clr     C
1346 EE            10189             mov     A, Temp7                                
                   10190     IF MODE <= 1    ; Main or tail
1347 9405          10191             subb    A, #5                           ; Subtract about 2% and ensure that it is 2
                             50 or lower
                   10192     ENDIF
1349 7897          10193             mov     Temp1, #Pgm_Ppm_Max_Throttle    ; Store
134B F6            10194             mov     @Temp1, A                       
134C 12055D        10195             call wait200ms                          
134F F17A          10196             call    success_beep
                   10197     
1351               10198     throttle_low_cal_start:
1351 7F0A          10199             mov     Temp8, #10                      ; Set 3 seconds wait time
1353               10200     throttle_low_cal:                       
1353 D27F          10201             setb    Flags3.FULL_THROTTLE_RANGE      ; Set range to 1000-2020us
1355 11B9          10202             call    find_throttle_gain              ; Set throttle gain
1357 120559        10203             call wait100ms
135A C2AF          10204             clr     EA                                      ; Disable interrupts (freeze New_Rc
                             p value)
135C C27F          10205             clr     Flags3.FULL_THROTTLE_RANGE      ; Set programmed range
135E 11B9          10206             call    find_throttle_gain              ; Set throttle gain
1360 AE5C          10207             mov     Temp7, New_Rcp                  ; Store new RC pulse value
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   163

1362 C3            10208             clr     C
1363 E55C          10209             mov     A, New_Rcp                      ; Load new RC pulse value
1365 947F          10210             subb    A, #(RCP_MAX/2)         ; Below midstick?
1367 D2AF          10211             setb    EA                                      ; Enable interrupts
1369 50E6          10212             jnc     throttle_low_cal_start  ; No - start over
                   10213     
136B 120549        10214             call wait1ms            
136E C2AF          10215             clr     EA                                      ; Disable all interrupts
1370 12056C        10216             call beep_f1
1373 120551        10217             call wait10ms
1376 12056C        10218             call beep_f1
1379 D2AF          10219             setb    EA                                      ; Enable all interrupts
137B DFD6          10220             djnz    Temp8, throttle_low_cal ; Continue to wait
                   10221     
137D 11F0          10222             call    average_throttle
137F EE            10223             mov     A, Temp7                                
1380 2403          10224             add     A, #3                           ; Add about 1%
1382 7896          10225             mov     Temp1, #Pgm_Ppm_Min_Throttle    ; Store
1384 F6            10226             mov     @Temp1, A                       
1385 F8            10227             mov     Temp1, A                                ; Min throttle in Temp1
1386 7997          10228             mov     Temp2, #Pgm_Ppm_Max_Throttle
1388 E7            10229             mov     A, @Temp2
1389 C3            10230             clr     C
138A 9482          10231             subb    A, #130                         ; Subtract 130 (520us) from max throttle
138C 4003          10232             jc      program_by_tx_entry_limit
                   10233     
138E 98            10234             subb    A, Temp1                                ; Subtract min from max
138F 5006          10235             jnc     program_by_tx_entry_store
                   10236     
1391               10237     program_by_tx_entry_limit:
1391 E8            10238             mov     A, Temp1                                ; Load min
1392 2482          10239             add     A, #130                         ; Make max 520us higher than min
1394 7897          10240             mov     Temp1, #Pgm_Ppm_Max_Throttle    ; Store new max
1396 F6            10241             mov     @Temp1, A
                   10242     
1397               10243     program_by_tx_entry_store:
1397 12055D        10244             call wait200ms                          
139A D196          10245             call erase_and_store_all_in_eeprom      
139C F1A9          10246             call    success_beep_inverted
                   10247     
139E               10248     program_by_tx_entry_wait_ppm:   
139E 120559        10249             call wait100ms
13A1 11B9          10250             call    find_throttle_gain              ; Set throttle gain
13A3 C3            10251             clr     C
13A4 E55C          10252             mov     A, New_Rcp                      ; Load new RC pulse value
13A6 94FF          10253             subb    A, #RCP_MAX                     ; At or above max?
13A8 5002          10254             jnc     ($+4)
13AA 41DF          10255             ajmp    arming_ppm_check                ; No - go back
                   10256     
13AC E1F7          10257             jmp     program_by_tx                   ; Yes - enter programming mode
                   10258     
13AE               10259     program_by_tx_checked:
                   10260             ; Initialize flash keys to invalid values
13AE 757C00        10261             mov     Flash_Key_1, #0
13B1 757D00        10262             mov     Flash_Key_2, #0
13B4 C3            10263             clr     C
13B5 E55C          10264             mov     A, New_Rcp                      ; Load new RC pulse value
13B7 954C          10265             subb    A, Gov_Arm_Target               ; Is RC pulse larger than arm target?
13B9 4003          10266             jc      arm_target_updated              ; No - do not update
                   10267     
13BB 855C4C        10268             mov     Gov_Arm_Target, New_Rcp ; Yes - update arm target
                   10269     
13BE               10270     arm_target_updated:
13BE 120559        10271             call wait100ms                          ; Wait for new throttle value
13C1 7801          10272             mov     Temp1, #RCP_STOP                ; Default stop value
13C3 7988          10273             mov     Temp2, #Pgm_Direction   ; Check if bidirectional operation
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   164

13C5 E7            10274             mov     A, @Temp2                               
13C6 B40302        10275             cjne    A, #3, ($+5)                    ; No - branch
                   10276     
13C9 7805          10277             mov     Temp1, #(RCP_STOP+4)    ; Higher stop value for bidirectional
                   10278     
13CB C3            10279             clr     C
13CC E55C          10280             mov     A, New_Rcp                      ; Load new RC pulse value
13CE 98            10281             subb    A, Temp1                                ; Below stop?
13CF 4002          10282             jc      arm_end_beep                    ; Yes - proceed
                   10283     
13D1 41C9          10284             jmp     arming_start                    ; No - start over
                   10285     
13D3               10286     arm_end_beep:
                   10287             ; Beep arm sequence end signal
13D3 C2AF          10288             clr     EA                                      ; Disable all interrupts
13D5 12057E        10289             call beep_f4                            ; Signal that rcpulse is ready
13D8 12057E        10290             call beep_f4
13DB 12057E        10291             call beep_f4
13DE D2AF          10292             setb    EA                                      ; Enable all interrupts
13E0 12055D        10293             call wait200ms
                   10294     
                   10295             ; Clear initial arm variable
13E3 753000        10296             mov     Initial_Arm, #0
                   10297     
                   10298             ; Armed and waiting for power on
13E6               10299     wait_for_power_on:
13E6 E4            10300             clr     A
13E7 F531          10301             mov     Power_On_Wait_Cnt_L, A  ; Clear wait counter
13E9 F532          10302             mov     Power_On_Wait_Cnt_H, A  
13EB               10303     wait_for_power_on_loop:
13EB 0531          10304             inc     Power_On_Wait_Cnt_L             ; Increment low wait counter
13ED E531          10305             mov     A, Power_On_Wait_Cnt_L
13EF F4            10306             cpl     A
13F0 703F          10307             jnz     wait_for_power_on_no_beep; Counter wrapping (about 3 sec)
                   10308     
13F2 0532          10309             inc     Power_On_Wait_Cnt_H             ; Increment high wait counter
13F4 789A          10310             mov     Temp1, #Pgm_Beacon_Delay
13F6 E6            10311             mov     A, @Temp1
13F7 7819          10312             mov     Temp1, #25              ; Approximately 1 min
13F9 14            10313             dec     A
13FA 6012          10314             jz      beep_delay_set
                   10315     
13FC 7832          10316             mov     Temp1, #50              ; Approximately 2 min
13FE 14            10317             dec     A
13FF 600D          10318             jz      beep_delay_set
                   10319     
1401 787D          10320             mov     Temp1, #125             ; Approximately 5 min
1403 14            10321             dec     A
1404 6008          10322             jz      beep_delay_set
                   10323     
1406 78FA          10324             mov     Temp1, #250             ; Approximately 10 min
1408 14            10325             dec     A
1409 6003          10326             jz      beep_delay_set
                   10327     
140B 753200        10328             mov     Power_On_Wait_Cnt_H, #0         ; Reset counter for infinite delay
                   10329     
140E               10330     beep_delay_set:
140E C3            10331             clr     C
140F E532          10332             mov     A, Power_On_Wait_Cnt_H
1411 98            10333             subb    A, Temp1                                ; Check against chosen delay
1412 401D          10334             jc      wait_for_power_on_no_beep; Has delay elapsed?
                   10335     
1414 120F92        10336             call    switch_power_off                ; Switch power off in case braking is set
1417 120549        10337             call    wait1ms
141A 1532          10338             dec     Power_On_Wait_Cnt_H             ; Decrement high wait counter
141C 753100        10339             mov     Power_On_Wait_Cnt_L, #0 ; Set low wait counter
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   165

141F 7899          10340             mov     Temp1, #Pgm_Beacon_Strength
1421 8673          10341             mov     Beep_Strength, @Temp1
1423 C2AF          10342             clr     EA                                      ; Disable all interrupts
1425 12057E        10343             call beep_f4                            ; Signal that there is no signal
1428 D2AF          10344             setb    EA                                      ; Enable all interrupts
142A 7898          10345             mov     Temp1, #Pgm_Beep_Strength
142C 8673          10346             mov     Beep_Strength, @Temp1
142E 120559        10347             call wait100ms                          ; Wait for new RC pulse to be measured
                   10348     
1431               10349     wait_for_power_on_no_beep:
1431 120551        10350             call wait10ms
1434 E52A          10351             mov     A, Rcp_Timeout_Cntd                             ; Load RC pulse timeout cou
                             nter value
1436 7005          10352             jnz     wait_for_power_on_ppm_not_missing       ; If it is not zero - proceed
                   10353     
1438 307402        10354             jnb     Flags2.RCP_PPM, wait_for_power_on_ppm_not_missing       ; If flag is not se
                             t (PWM) - branch
                   10355     
143B 21C9          10356             jmp     init_no_signal                                  ; If ppm and pulses missing
                              - go back to detect input signal
                   10357     
143D               10358     wait_for_power_on_ppm_not_missing:
143D 7801          10359             mov     Temp1, #RCP_STOP
143F 207402        10360             jb      Flags2.RCP_PPM, ($+5)   ; If flag is set (PPM) - branch
                   10361     
1442 7806          10362             mov     Temp1, #(RCP_STOP+5)    ; Higher than stop (for pwm)
                   10363     
1444 C3            10364             clr     C
1445 E55C          10365             mov     A, New_Rcp                      ; Load new RC pulse value
1447 98            10366             subb    A, Temp1                                ; Higher than stop (plus some hyste
                             resis)?
1448 40A1          10367             jc      wait_for_power_on_loop  ; No - start over
                   10368     
                   10369     IF MODE >= 1    ; Tail or multi
                                     mov     Temp1, #Pgm_Direction   ; Check if bidirectional operation
                                     mov     A, @Temp1                               
                                     clr     C
                                     subb    A, #3
                                     jz      wait_for_power_on_check_timeout ; Do not wait if bidirectional operation
                             ENDIF
                   10376     
144A 120559        10377             lcall wait100ms                 ; Wait to see if start pulse was only a glitch
                   10378     
144D               10379     wait_for_power_on_check_timeout:
144D E52A          10380             mov     A, Rcp_Timeout_Cntd             ; Load RC pulse timeout counter value
144F 7003          10381             jnz     ($+5)                           ; If it is not zero - proceed
                   10382     
1451 0211C9        10383             ljmp    init_no_signal                  ; If it is zero (pulses missing) - go back 
                             to detect input signal
                   10384     
                   10385     
                   10386     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                   10387     ;
                   10388     ; Start entry point
                   10389     ;
                   10390     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
1454               10391     init_start:
1454 C2AF          10392             clr     EA
1456 120F92        10393             call switch_power_off
1459 E4            10394             clr     A
145A F522          10395             mov     Requested_Pwm, A                ; Set requested pwm to zero
145C F523          10396             mov     Governor_Req_Pwm, A             ; Set governor requested pwm to zero
145E F524          10397             mov     Current_Pwm, A                  ; Set current pwm to zero
1460 F525          10398             mov     Current_Pwm_Limited, A  ; Set limited current pwm to zero
1462 F526          10399             mov     Current_Pwm_Lim_Dith, A
1464 F567          10400             mov     Pwm_Dither_Excess_Power, A
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   166

1466 D2AF          10401             setb    EA
1468 7885          10402             mov     Temp1, #Pgm_Motor_Idle  ; Set idle pwm to programmed value      
146A E6            10403             mov     A, @Temp1                               
146B C3            10404             clr     C
146C 33            10405             rlc     A
146D F565          10406             mov     Pwm_Motor_Idle, A
146F E4            10407             clr     A
1470 F544          10408             mov     Gov_Target_L, A         ; Set target to zero
1472 F545          10409             mov     Gov_Target_H, A
1474 F546          10410             mov     Gov_Integral_L, A               ; Set integral to zero
1476 F547          10411             mov     Gov_Integral_H, A
1478 F548          10412             mov     Gov_Integral_X, A
147A F570          10413             mov     Adc_Conversion_Cnt, A
147C F52C          10414             mov     Flags0, A                               ; Clear flags0
147E F52D          10415             mov     Flags1, A                               ; Clear flags1
1480 F537          10416             mov     Demag_Detected_Metric, A        ; Clear demag metric
                   10417             ;**** **** **** **** ****
                   10418             ; Motor start beginning
                   10419             ;**** **** **** **** **** 
1482 757008        10420             mov     Adc_Conversion_Cnt, #TEMP_CHECK_RATE    ; Make sure a temp reading is done
                   10421             Set_Adc_Ip_Temp
1488 120549        10423             call wait1ms
148B 12090F        10424             call start_adc_conversion
148E               10425     read_initial_temp:
148E 30EDFD        10426             jnb     AD0INT, read_initial_temp
                   10427             Read_Adc_Result                                         ; Read initial temperature
1495 E9            10430             mov     A, Temp2
1496 7001          10431             jnz     ($+3)                                                   ; Is reading below 
                             256?
                   10432     
1498 F8            10433             mov     Temp1, A                                                        ; Yes - set
                              average temperature value to zero
                   10434     
1499 8871          10435             mov     Current_Average_Temp, Temp1                     ; Set initial average tempe
                             rature
149B 120913        10436             call check_temp_voltage_and_limit_power
149E 757008        10437             mov     Adc_Conversion_Cnt, #TEMP_CHECK_RATE    ; Make sure a temp reading is done 
                             next time
                   10438             Set_Adc_Ip_Temp
                   10440             ; Set up start operating conditions
14A4 1113          10441             call    decode_parameters               ; (Decode_parameters uses Temp1 and Temp8)
                   10442             ; Set max allowed power
14A6 C2AF          10443             clr     EA                                      ; Disable interrupts to avoid that 
                             Requested_Pwm is overwritten
14A8 7561FF        10444             mov     Pwm_Limit, #0FFh                ; Set pwm limit to max
14AB 1209C8        10445             call set_startup_pwm
14AE 852261        10446             mov     Pwm_Limit, Requested_Pwm
14B1 852262        10447             mov     Pwm_Limit_Spoolup, Requested_Pwm
14B4 852263        10448             mov     Pwm_Limit_By_Rpm, Requested_Pwm
14B7 D2AF          10449             setb    EA
14B9 752201        10450             mov     Requested_Pwm, #1                       ; Set low pwm again after calling s
                             et_startup_pwm
14BC 752401        10451             mov     Current_Pwm, #1
14BF 752501        10452             mov     Current_Pwm_Limited, #1 
14C2 752601        10453             mov     Current_Pwm_Lim_Dith, #1
14C5 856069        10454             mov     Spoolup_Limit_Cnt, Auto_Bailout_Armed
14C8 756A01        10455             mov     Spoolup_Limit_Skip, #1                  
                   10456             ; Begin startup sequence
                   10457     IF MCU_48MHZ == 1
                                     Set_MCU_Clk_48MHz
                             ENDIF
14CB 7888          10460             mov     Temp1, #Pgm_Direction           ; Check if bidirectional operation
14CD E6            10461             mov     A, @Temp1                               
14CE B40307        10462             cjne    A, #3, init_start_bidir_done
                   10463     
14D1 C27D          10464             clr     Flags3.PGM_DIR_REV                      ; Set spinning direction. Default f
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   167

                             wd
14D3 307602        10465             jnb     Flags2.RCP_DIR_REV, ($+5)       ; Check force direction
14D6 D27D          10466             setb    Flags3.PGM_DIR_REV                      ; Set spinning direction
                   10467     
14D8               10468     init_start_bidir_done:
14D8 D268          10469             setb    Flags1.MOTOR_SPINNING           ; Set motor spinning flag
14DA D269          10470             setb    Flags1.STARTUP_PHASE            ; Set startup phase flag
14DC 753300        10471             mov     Startup_Cnt, #0                 ; Reset counter
14DF 120EF0        10472             call comm5comm6                         ; Initialize commutation
14E2 120F1D        10473             call comm6comm1                         
14E5 1209E8        10474             call initialize_timing                  ; Initialize timing
14E8 1209EF        10475             call    calc_next_comm_timing           ; Set virtual commutation point
14EB 1209E8        10476             call initialize_timing                  ; Initialize timing
14EE 1209EF        10477             call    calc_next_comm_timing           
14F1 1209E8        10478             call    initialize_timing                       ; Initialize timing
                   10479     
                   10480     
                   10481     
                   10482     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                   10483     ;
                   10484     ; Run entry point
                   10485     ;
                   10486     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                   10487     
                   10488     ; Run 1 = B(p-on) + C(n-pwm) - comparator A evaluated
                   10489     ; Out_cA changes from low to high
14F4               10490     run1:
14F4 120C6D        10491             call wait_for_comp_out_high     ; Wait zero cross wait and wait for high
                   10492     ;               setup_comm_wait         ; Setup wait time from zero cross to commutation
                   10493     ;               evaluate_comparator_integrity   ; Check whether comparator reading has been
                              normal
14F7 12065E        10494             call calc_governor_target       ; Calculate governor target
14FA 120D61        10495             call wait_for_comm                      ; Wait from zero cross to commutation
14FD 120DA8        10496             call comm1comm2                 ; Commutate
1500 1209EF        10497             call calc_next_comm_timing      ; Calculate next timing and start advance timing wa
                             it
                   10498     ;               wait_advance_timing             ; Wait advance timing and start zero cross 
                             wait
                   10499     ;               calc_new_wait_times
                   10500     ;               wait_before_zc_scan             ; Wait zero cross wait and start zero cross
                              timeout
                   10501     
                   10502     ; Run 2 = A(p-on) + C(n-pwm) - comparator B evaluated
                   10503     ; Out_cB changes from high to low
1503               10504     run2:
1503 120C5D        10505             call wait_for_comp_out_low
                   10506     ;               setup_comm_wait 
                   10507     ;               evaluate_comparator_integrity   
1506 306E03        10508             jnb     Flags1.GOV_ACTIVE, ($+6)
1509 1206FA        10509             lcall calc_governor_prop_error
150C 206603        10510             jb      Flags0.HIGH_RPM, ($+6)  ; Skip if high rpm
150F 12083B        10511             lcall set_pwm_limit_low_rpm
1512 306603        10512             jnb     Flags0.HIGH_RPM, ($+6)  ; Do if high rpm
1515 12086B        10513             lcall set_pwm_limit_high_rpm
1518 120D61        10514             call wait_for_comm
151B 120DD5        10515             call comm2comm3
151E 1209EF        10516             call calc_next_comm_timing
                   10517     ;               wait_advance_timing
                   10518     ;               calc_new_wait_times
                   10519     ;               wait_before_zc_scan     
                   10520     
                   10521     ; Run 3 = A(p-on) + B(n-pwm) - comparator C evaluated
                   10522     ; Out_cC changes from low to high
1521               10523     run3:
1521 120C6D        10524             call wait_for_comp_out_high
                   10525     ;               setup_comm_wait 
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   168

                   10526     ;               evaluate_comparator_integrity   
1524 306E03        10527             jnb     Flags1.GOV_ACTIVE, ($+6)
1527 120733        10528             lcall calc_governor_int_error
152A 120D61        10529             call wait_for_comm
152D 120E4C        10530             call comm3comm4
1530 1209EF        10531             call calc_next_comm_timing
                   10532     ;               wait_advance_timing
                   10533     ;               calc_new_wait_times
                   10534     ;               wait_before_zc_scan     
                   10535     
                   10536     ; Run 4 = C(p-on) + B(n-pwm) - comparator A evaluated
                   10537     ; Out_cA changes from high to low
1533               10538     run4:
1533 120C5D        10539             call wait_for_comp_out_low
                   10540     ;               setup_comm_wait 
                   10541     ;               evaluate_comparator_integrity   
1536 306E03        10542             jnb     Flags1.GOV_ACTIVE, ($+6)
1539 12078C        10543             lcall calc_governor_prop_correction
153C 120D61        10544             call wait_for_comm
153F 120E79        10545             call comm4comm5
1542 1209EF        10546             call calc_next_comm_timing
                   10547     ;               wait_advance_timing
                   10548     ;               calc_new_wait_times
                   10549     ;               wait_before_zc_scan     
                   10550     
                   10551     ; Run 5 = C(p-on) + A(n-pwm) - comparator B evaluated
                   10552     ; Out_cB changes from low to high
1545               10553     run5:
1545 120C6D        10554             call wait_for_comp_out_high
                   10555     ;               setup_comm_wait 
                   10556     ;               evaluate_comparator_integrity   
1548 306E03        10557             jnb     Flags1.GOV_ACTIVE, ($+6)
154B 1207E6        10558             lcall calc_governor_int_correction
154E 120D61        10559             call wait_for_comm
1551 120EF0        10560             call comm5comm6
1554 1209EF        10561             call calc_next_comm_timing
                   10562     ;               wait_advance_timing
                   10563     ;               calc_new_wait_times
                   10564     ;               wait_before_zc_scan     
                   10565     
                   10566     ; Run 6 = B(p-on) + A(n-pwm) - comparator C evaluated
                   10567     ; Out_cC changes from high to low
1557               10568     run6:
1557 12090F        10569             call start_adc_conversion
155A 120C5D        10570             call wait_for_comp_out_low
                   10571     ;               setup_comm_wait 
                   10572     ;               evaluate_comparator_integrity   
155D 120D61        10573             call wait_for_comm
1560 120F1D        10574             call comm6comm1
1563 120913        10575             call check_temp_voltage_and_limit_power
1566 1209EF        10576             call calc_next_comm_timing
                   10577     ;               wait_advance_timing
                   10578     ;               calc_new_wait_times
                   10579     ;               wait_before_zc_scan     
                   10580     
                   10581             ; Check if it is direct startup
1569 30692A        10582             jnb     Flags1.STARTUP_PHASE, normal_run_checks
                   10583     
                   10584             ; Set spoolup power variables
156C 856461        10585             mov     Pwm_Limit, Pwm_Spoolup_Beg              ; Set initial max power
156F 856462        10586             mov     Pwm_Limit_Spoolup, Pwm_Spoolup_Beg      ; Set initial slow spoolup power
1572 856069        10587             mov     Spoolup_Limit_Cnt, Auto_Bailout_Armed
1575 756A01        10588             mov     Spoolup_Limit_Skip, #1                  
                   10589             ; Check startup counter
1578 7918          10590             mov     Temp2, #24                              ; Set nominal startup parameters
157A 7A0C          10591             mov     Temp3, #12
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   169

157C C3            10592             clr     C
157D E533          10593             mov     A, Startup_Cnt                          ; Load counter
157F 99            10594             subb    A, Temp2                                        ; Is counter above requirem
                             ent?
1580 4008          10595             jc      direct_start_check_rcp          ; No - proceed
                   10596     
1582 C269          10597             clr     Flags1.STARTUP_PHASE            ; Clear startup phase flag
1584 D26A          10598             setb    Flags1.INITIAL_RUN_PHASE                ; Set initial run phase flag
1586 8A35          10599             mov     Initial_Run_Rot_Cntd, Temp3     ; Set initial run rotation count
                   10600     IF MODE == 1    ; Tail
                                     mov     Pwm_Limit, #0FFh                        ; Allow full power
                             ENDIF
                   10603     IF MODE == 2    ; Multi
                                     mov     Pwm_Limit, Pwm_Spoolup_Beg
                                     mov     Pwm_Limit_By_Rpm, Pwm_Spoolup_Beg
                             ENDIF
1588 800C          10607             jmp     normal_run_checks
                   10608     
158A               10609     direct_start_check_rcp:
158A C3            10610             clr     C
158B E55C          10611             mov     A, New_Rcp                              ; Load new pulse value
158D 9401          10612             subb    A, #RCP_STOP                            ; Check if pulse is below stop value
158F 4003          10613             jc      ($+5)
                   10614     
1591 0214F4        10615             ljmp    run1                                            ; Continue to run 
                   10616     
1594 806A          10617             jmp     run_to_wait_for_power_on
                   10618     
                   10619     
1596               10620     normal_run_checks:
                   10621             ; Check if it is initial run phase
1596 306A24        10622             jnb     Flags1.INITIAL_RUN_PHASE, initial_run_phase_done        ; If not initial ru
                             n phase - branch
1599 206C21        10623             jb      Flags1.DIR_CHANGE_BRAKE, initial_run_phase_done ; If a direction change - b
                             ranch
                   10624     
                   10625             ; Decrement startup rotaton count
159C E535          10626             mov     A, Initial_Run_Rot_Cntd
159E 14            10627             dec     A
                   10628             ; Check number of initial rotations
159F 7006          10629             jnz     normal_run_check_startup_rot    ; Branch if counter is not zero
                   10630     
15A1 C26A          10631             clr     Flags1.INITIAL_RUN_PHASE                ; Clear initial run phase flag
15A3 D26B          10632             setb    Flags1.MOTOR_STARTED            ; Set motor started
15A5 81F4          10633             jmp run1                                                ; Continue with normal run
                   10634     
15A7               10635     normal_run_check_startup_rot:
15A7 F535          10636             mov     Initial_Run_Rot_Cntd, A         ; Not zero - store counter
                   10637     
15A9 C3            10638             clr     C
15AA E55C          10639             mov     A, New_Rcp                              ; Load new pulse value
15AC 9401          10640             subb    A, #RCP_STOP                            ; Check if pulse is below stop value
15AE 4003          10641             jc      ($+5)
                   10642     
15B0 0214F4        10643             ljmp    run1                                            ; Continue to run 
                   10644     
15B3 7888          10645             mov     Temp1, #Pgm_Direction           ; Check if bidirectional operation
15B5 E6            10646             mov     A, @Temp1       
15B6 C3            10647             clr     C
15B7 9403          10648             subb    A, #3                   
15B9 6002          10649             jz      initial_run_phase_done
                   10650     
15BB 8043          10651             jmp     run_to_wait_for_power_on
                   10652     
15BD               10653     initial_run_phase_done:
                   10654             ; Reset stall count
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   170

15BD 753600        10655             mov     Stall_Cnt, #0
                   10656     IF MODE == 0    ; Main
                   10657             ; Check if throttle is zeroed
15C0 C3            10658             clr     C
15C1 E55F          10659             mov     A, Rcp_Stop_Cnt                 ; Load stop RC pulse counter value
15C3 9401          10660             subb    A, #1                                   ; Is number of stop RC pulses above
                              limit?
15C5 4009          10661             jc      run6_check_rcp_stop_count       ; If no - branch
                   10662     
15C7 856462        10663             mov     Pwm_Limit_Spoolup, Pwm_Spoolup_Beg              ; If yes - set initial max 
                             powers
15CA 856069        10664             mov     Spoolup_Limit_Cnt, Auto_Bailout_Armed   ; And set spoolup parameters
15CD 756A01        10665             mov     Spoolup_Limit_Skip, #1                  
                   10666     
15D0               10667     run6_check_rcp_stop_count:
                   10668     ENDIF
                   10669             ; Exit run loop after a given time
15D0 78FA          10670             mov     Temp1, #RCP_STOP_LIMIT
15D2 79A4          10671             mov     Temp2, #Pgm_Brake_On_Stop
15D4 E7            10672             mov     A, @Temp2       
15D5 6002          10673             jz      ($+4)
                   10674     
15D7 7803          10675             mov     Temp1, #3                                       ; About 100ms before stoppi
                             ng when brake is set
                   10676     
15D9 C3            10677             clr     C
15DA E55F          10678             mov     A, Rcp_Stop_Cnt                 ; Load stop RC pulse counter low byte value
15DC 98            10679             subb    A, Temp1                                        ; Is number of stop RC puls
                             es above limit?
15DD 5021          10680             jnc     run_to_wait_for_power_on                ; Yes, go back to wait for poweron
                   10681     
15DF 307404        10682             jnb     Flags2.RCP_PPM, run6_check_dir; If flag is not set (PWM) - branch
                   10683     
15E2 E52A          10684             mov     A, Rcp_Timeout_Cntd                     ; Load RC pulse timeout counter val
                             ue
15E4 601A          10685             jz      run_to_wait_for_power_on                ; If it is zero - go back to wait f
                             or poweron
                   10686     
15E6               10687     run6_check_dir:
                   10688     IF MODE >= 1    ; Tail or multi
                                     mov     Temp1, #Pgm_Direction           ; Check if bidirectional operation
                                     mov     A, @Temp1                               
                                     cjne    A, #3, run6_check_speed
                             
                                     jb      Flags3.PGM_DIR_REV, run6_check_dir_rev          ; Check if actual rotation 
                             direction
                                     jb      Flags2.RCP_DIR_REV, run6_check_dir_change       ; Matches force direction
                                     ajmp    run6_check_speed
                             
                             run6_check_dir_rev:
                                     jnb     Flags2.RCP_DIR_REV, run6_check_dir_change
                                     ajmp    run6_check_speed
                             
                             run6_check_dir_change:
                                     jb      Flags1.DIR_CHANGE_BRAKE, run6_check_speed
                             
                                     setb    Flags1.DIR_CHANGE_BRAKE         ; Set brake flag
                                     mov     Pwm_Limit, Pwm_Spoolup_Beg      ; Set max power while braking
                                     jmp     run4                                            ; Go back to run 4, thereby
                              changing force direction
                             
                             run6_check_speed:
                             ENDIF
15E6 78F0          10710             mov     Temp1, #0F0h                            ; Default minimum speed
15E8 306C05        10711             jnb     Flags1.DIR_CHANGE_BRAKE, run6_brake_done; Is it a direction change?
                   10712     
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   171

15EB 856461        10713             mov     Pwm_Limit, Pwm_Spoolup_Beg      ; Set max power while braking
15EE 7820          10714             mov     Temp1, #20h                             ; Bidirectional braking termination
                              speed
                   10715     
15F0               10716     run6_brake_done:
15F0 C3            10717             clr     C
15F1 E541          10718             mov     A, Comm_Period4x_H                      ; Is Comm_Period4x more than 32ms (
                             ~1220 eRPM)?
15F3 98            10719             subb    A, Temp1
15F4 5002          10720             jnc     ($+4)                                   ; Yes - stop or turn direction 
15F6 81F4          10721             ajmp    run1                                            ; No - go back to run 1
                   10722     
                   10723     IF MODE >= 1    ; Tail or multi
                                     jnb     Flags1.DIR_CHANGE_BRAKE, run_to_wait_for_power_on       ; If it is not a di
                             rection change - stop
                             
                                     clr     Flags1.DIR_CHANGE_BRAKE         ; Clear brake flag
                                     clr     Flags3.PGM_DIR_REV                      ; Set spinning direction. Default f
                             wd
                                     jnb     Flags2.RCP_DIR_REV, ($+5)       ; Check force direction
                                     setb    Flags3.PGM_DIR_REV                      ; Set spinning direction
                                     setb    Flags1.INITIAL_RUN_PHASE                
                                     mov     Initial_Run_Rot_Cntd, #18
                                     mov     Pwm_Limit, Pwm_Spoolup_Beg      ; Set initial max power
                                     ajmp    run1                                            ; Go back to run 1 
                             ENDIF
                   10735     
15F8               10736     run_to_wait_for_power_on_fail:  
15F8 0536          10737             inc     Stall_Cnt                                       ; Increment stall count
15FA E55C          10738             mov     A, New_Rcp                              ; Check if RCP is zero, then it is 
                             a normal stop                        
15FC 6002          10739             jz      run_to_wait_for_power_on
15FE C103          10740             ajmp    run_to_wait_for_power_on_stall_done
                   10741     
1600               10742     run_to_wait_for_power_on:       
1600 753600        10743             mov     Stall_Cnt, #0
                   10744     
1603               10745     run_to_wait_for_power_on_stall_done:
1603 C2AF          10746             clr     EA
1605 120F92        10747             call switch_power_off
1608 7887          10748             mov     Temp1, #Pgm_Pwm_Freq
160A E6            10749             mov     A, @Temp1       
160B FE            10750             mov     Temp7, A                                        ; Store setting in Temp7
160C 7602          10751             mov     @Temp1, #2                              ; Set low pwm mode (in order to tur
                             n off damping)
160E 1113          10752             call    decode_parameters                       ; (Decode_parameters uses Temp1 and
                              Temp8)
1610 7887          10753             mov     Temp1, #Pgm_Pwm_Freq
1612 EE            10754             mov     A, Temp7
1613 F6            10755             mov     @Temp1, A                                       ; Restore settings
1614 E4            10756             clr     A
1615 F522          10757             mov     Requested_Pwm, A                        ; Set requested pwm to zero
1617 F523          10758             mov     Governor_Req_Pwm, A                     ; Set governor requested pwm to zero
1619 F524          10759             mov     Current_Pwm, A                          ; Set current pwm to zero
161B F525          10760             mov     Current_Pwm_Limited, A          ; Set limited current pwm to zero
161D F526          10761             mov     Current_Pwm_Lim_Dith, A 
161F F565          10762             mov     Pwm_Motor_Idle, A                       ; Set motor idle to zero
1621 752C00        10763             mov     Flags0, #0                              ; Clear flags0
1624 752D00        10764             mov     Flags1, #0                              ; Clear flags1
                   10765     IF MCU_48MHZ == 1
                                     Set_MCU_Clk_24MHz
                             ENDIF
1627 D2AF          10768             setb    EA
1629 120559        10769             call    wait100ms                                       ; Wait for pwm to be stopped
162C 120F92        10770             call switch_power_off
162F 78A4          10771             mov     Temp1, #Pgm_Brake_On_Stop
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   172

1631 E6            10772             mov     A, @Temp1       
1632 6006          10773             jz      run_to_wait_for_power_on_brake_done
                   10774     
                   10775             Brake_FETs_on
                   10776+1           AnFET_on
                   10778+1           BnFET_on
                   10780+1           CnFET_on
                   10782     
163A               10783     run_to_wait_for_power_on_brake_done:
                   10784     IF MODE == 0    ; Main
163A 307406        10785             jnb     Flags2.RCP_PPM, run_to_next_state_main  ; If flag is not set (PWM) - branch
                   10786     
163D E52A          10787             mov     A, Rcp_Timeout_Cntd                     ; Load RC pulse timeout counter val
                             ue
163F 7002          10788             jnz     run_to_next_state_main          ; If it is not zero - branch
                   10789     
1641 21C9          10790             jmp     init_no_signal                          ; If it is zero (pulses missing) - 
                             go back to detect input signal
                   10791     
1643               10792     run_to_next_state_main:
1643 788D          10793             mov     Temp1, #Pgm_Main_Rearm_Start
1645 E6            10794             mov     A, @Temp1       
1646 C3            10795             clr     C
1647 9401          10796             subb    A, #1                                   ; Is re-armed start enabled?
1649 4002          10797             jc      jmp_wait_for_power_on           ; No - do like tail and start immediately
                   10798     
164B 41A6          10799             jmp     validate_rcp_start                      ; Yes - go back to validate RC pulse
                   10800     
164D               10801     jmp_wait_for_power_on:
164D 61E6          10802             jmp     wait_for_power_on                       ; Go back to wait for power on
                   10803     ENDIF
                   10804     IF MODE >= 1    ; Tail or multi
                                     jnb     Flags2.RCP_PPM, jmp_wait_for_power_on   ; If flag is not set (PWM) - branch
                             
                                     clr     C
                                     mov     A, Stall_Cnt
                                     subb    A, #4
                                     jc      jmp_wait_for_power_on
                                     jmp     init_no_signal
                             
                             jmp_wait_for_power_on:
                                     jmp     wait_for_power_on                       ; Go back to wait for power on
                             ENDIF
                   10816     
                   10817     
                   10818     ;$include (BLHeliTxPgm.inc) ; Include source code for programming the ESC with the TX
                +1 10819     ;**** **** **** **** ****
                +1 10820     ;
                +1 10821     ; BLHeli program for controlling brushless motors in helicopters and multirotors
                +1 10822     ;
                +1 10823     ; Copyright 2011, 2012 Steffen Skaug
                +1 10824     ; This program is distributed under the terms of the GNU General Public License
                +1 10825     ;
                +1 10826     ; This file is part of BLHeli.
                +1 10827     ;
                +1 10828     ; BLHeli is free software: you can redistribute it and/or modify
                +1 10829     ; it under the terms of the GNU General Public License as published by
                +1 10830     ; the Free Software Foundation, either version 3 of the License, or
                +1 10831     ; (at your option) any later version.
                +1 10832     ;
                +1 10833     ; BLHeli is distributed in the hope that it will be useful,
                +1 10834     ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                +1 10835     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                +1 10836     ; GNU General Public License for more details.
                +1 10837     ;
                +1 10838     ; You should have received a copy of the GNU General Public License
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   173

                +1 10839     ; along with BLHeli.  If not, see <http://www.gnu.org/licenses/>.
                +1 10840     ;
                +1 10841     ;**** **** **** **** ****
                +1 10842     ;
                +1 10843     ; BLHeliTxPgm SiLabs                                      
                +1 10844     ;                                                         
                +1 10845     ; EEPROM is not available in SiLabs MCUs                  
                +1 10846     ; Therefore a segment of the flash is used as "EEPROM"    
                +1 10847     ;                                                         
                +1 10848     ;**** **** **** **** ****
                +1 10849     
                +1 10850     
                +1 10851     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                +1 10852     ;
                +1 10853     ; Read all eeprom parameters routine
                +1 10854     ;
                +1 10855     ; No assumptions
                +1 10856     ;
                +1 10857     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
164F            +1 10858     read_all_eeprom_parameters:     
                +1 10859             ; Check initialized signature
164F 901A0D     +1 10860             mov     DPTR, #Eep_Initialized_L
1652 7820       +1 10861             mov     Temp1, #Bit_Access
1654 D1CF       +1 10862             call read_eeprom_byte
1656 E520       +1 10863             mov     A, Bit_Access
                +1 10864     IF MODE == 0
1658 B4A50A     +1 10865             cjne    A, #0A5h, read_eeprom_store_defaults
                +1 10866     ENDIF
                +1 10867     IF MODE == 1
                +1                   cjne    A, #05Ah, read_eeprom_store_defaults
                +1           ENDIF
                +1 10870     IF MODE == 2
                +1                   cjne    A, #055h, read_eeprom_store_defaults
                +1           ENDIF
165B A3         +1 10873             inc     DPTR                            ; Now Eep_Initialized_H
165C D1CF       +1 10874             call read_eeprom_byte
165E E520       +1 10875             mov     A, Bit_Access
                +1 10876     IF MODE == 0
1660 B45A02     +1 10877             cjne    A, #05Ah, read_eeprom_store_defaults
                +1 10878     ENDIF
                +1 10879     IF MODE == 1
                +1                   cjne    A, #0A5h, read_eeprom_store_defaults
                +1           ENDIF
                +1 10882     IF MODE == 2
                +1                   cjne    A, #0AAh, read_eeprom_store_defaults
                +1           ENDIF
1663 8013       +1 10885             jmp     read_eeprom_read
                +1 10886     
                +1 10887     
1665            +1 10888     read_eeprom_store_defaults:
1665 757CA5     +1 10889             mov     Flash_Key_1, #0A5h
1668 757DF1     +1 10890             mov     Flash_Key_2, #0F1h
166B 120FA7     +1 10891             call set_default_parameters     
166E D196       +1 10892             call erase_and_store_all_in_eeprom      
1670 757C00     +1 10893             mov     Flash_Key_1, #0
1673 757D00     +1 10894             mov     Flash_Key_2, #0
1676 801D       +1 10895             jmp     read_eeprom_exit
                +1 10896     
1678            +1 10897     read_eeprom_read:
                +1 10898             ; Read eeprom
                +1 10899     IF MODE == 0 OR MODE == 2       ;Main or multi
1678 901A03     +1 10900             mov     DPTR, #Eep_Pgm_Gov_P_Gain
                +1 10901     ENDIF
                +1 10902     IF MODE == 1                            ; Tail
                +1                   mov     DPTR, #_Eep_Pgm_Gov_P_Gain
                +1           ENDIF
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   174

167B 7880       +1 10905             mov     Temp1, #Pgm_Gov_P_Gain  
167D 7B0A       +1 10906             mov     Temp4, #10
167F            +1 10907     read_eeprom_block1:
167F D1CF       +1 10908             call read_eeprom_byte
1681 A3         +1 10909             inc     DPTR                            
1682 08         +1 10910             inc     Temp1                   
1683 DBFA       +1 10911             djnz    Temp4, read_eeprom_block1
                +1 10912     
1685 901A0F     +1 10913             mov     DPTR, #Eep_Enable_TX_Program
1688 788C       +1 10914             mov     Temp1, #Pgm_Enable_TX_Program   
168A 7B19       +1 10915             mov     Temp4, #25      ; 25 parameters 
168C            +1 10916     read_eeprom_block2:
168C D1CF       +1 10917             call read_eeprom_byte
168E A3         +1 10918             inc     DPTR                            
168F 08         +1 10919             inc     Temp1           
1690 DBFA       +1 10920             djnz    Temp4, read_eeprom_block2
                +1 10921     
1692 901A28     +1 10922             mov     DPTR, #Eep_Dummy                        ; Set pointer to uncritical area
                +1 10923     
1695            +1 10924     read_eeprom_exit:
1695 22         +1 10925             ret
                +1 10926     
                +1 10927     
                +1 10928     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                +1 10929     ;
                +1 10930     ; Erase flash and store all parameter value in EEPROM routine
                +1 10931     ;
                +1 10932     ; No assumptions
                +1 10933     ;
                +1 10934     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
1696            +1 10935     erase_and_store_all_in_eeprom:
1696 C2AF       +1 10936             clr     EA                                              ; Disable interrupts
1698 F112       +1 10937             call    read_tags
169A D1EF       +1 10938             call    erase_flash                             ; Erase flash
                +1 10939     
169C 901A00     +1 10940             mov     DPTR, #Eep_FW_Main_Revision     ; Store firmware main revision
169F 740E       +1 10941             mov     A, #EEPROM_FW_MAIN_REVISION
16A1 D1D4       +1 10942             call write_eeprom_byte_from_acc
                +1 10943     
16A3 A3         +1 10944             inc     DPTR                                            ; Now firmware sub revision
16A4 7409       +1 10945             mov     A, #EEPROM_FW_SUB_REVISION
16A6 D1D4       +1 10946             call write_eeprom_byte_from_acc
                +1 10947     
16A8 A3         +1 10948             inc     DPTR                                            ; Now layout revision
16A9 7415       +1 10949             mov     A, #EEPROM_LAYOUT_REVISION
16AB D1D4       +1 10950             call write_eeprom_byte_from_acc
                +1 10951     
                +1 10952             ; Write eeprom
                +1 10953     IF MODE == 0 OR MODE == 2       ;Main or multi
16AD 901A03     +1 10954             mov     DPTR, #Eep_Pgm_Gov_P_Gain
                +1 10955     ENDIF
                +1 10956     IF MODE == 1                            ; Tail
                +1                   mov     DPTR, #_Eep_Pgm_Gov_P_Gain
                +1           ENDIF
16B0 7880       +1 10959             mov     Temp1, #Pgm_Gov_P_Gain
16B2 7B0A       +1 10960             mov     Temp4, #10
16B4            +1 10961     write_eeprom_block1:
16B4 D1D3       +1 10962             call write_eeprom_byte
16B6 A3         +1 10963             inc     DPTR                                            
16B7 08         +1 10964             inc     Temp1                                   
16B8 DBFA       +1 10965             djnz    Temp4, write_eeprom_block1
                +1 10966     
16BA 901A0F     +1 10967             mov     DPTR, #Eep_Enable_TX_Program
16BD 788C       +1 10968             mov     Temp1, #Pgm_Enable_TX_Program   
16BF 7B19       +1 10969             mov     Temp4, #25      ; 25 parameters 
16C1            +1 10970     write_eeprom_block2:
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   175

16C1 D1D3       +1 10971             call write_eeprom_byte
16C3 A3         +1 10972             inc     DPTR                                            
16C4 08         +1 10973             inc     Temp1                                   
16C5 DBFA       +1 10974             djnz    Temp4, write_eeprom_block2
                +1 10975     
16C7 F125       +1 10976             call    write_tags
16C9 F103       +1 10977             call write_eeprom_signature
16CB 901A28     +1 10978             mov     DPTR, #Eep_Dummy                        ; Set pointer to uncritical area
16CE 22         +1 10979             ret     
                +1 10980     
                +1 10981     
                +1 10982     
                +1 10983     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                +1 10984     ;
                +1 10985     ; Read eeprom byte routine
                +1 10986     ;
                +1 10987     ; Gives data in A and in address given by Temp1. Assumes address in DPTR 
                +1 10988     ; Also assumes address high byte to be zero
                +1 10989     ;
                +1 10990     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
16CF            +1 10991     read_eeprom_byte:
16CF E4         +1 10992             clr     A
16D0 93         +1 10993             movc    A, @A+DPTR                      ; Read from flash
16D1 F6         +1 10994             mov     @Temp1, A
16D2 22         +1 10995             ret
                +1 10996     
                +1 10997     
                +1 10998     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                +1 10999     ;
                +1 11000     ; Write eeprom byte routine
                +1 11001     ;
                +1 11002     ; Assumes data in address given by Temp1, or in accumulator. Assumes address in DPTR 
                +1 11003     ; Also assumes address high byte to be zero
                +1 11004     ;
                +1 11005     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
16D3            +1 11006     write_eeprom_byte:
16D3 E6         +1 11007             mov     A, @Temp1
16D4            +1 11008     write_eeprom_byte_from_acc:
16D4 438F01     +1 11009             orl     PSCTL, #01h                     ; Set the PSWE bit
16D7 538FFD     +1 11010             anl     PSCTL, #0FDh                    ; Clear the PSEE bit
16DA FF         +1 11011             mov     Temp8, A
16DB C3         +1 11012             clr     C
16DC E583       +1 11013             mov     A, DPH                          ; Check that address is not in bootloader a
                             rea
16DE 941C       +1 11014             subb    A, #1Ch
16E0 4001       +1 11015             jc      ($+3)
                +1 11016     
16E2 22         +1 11017             ret
                +1 11018     
16E3 EF         +1 11019             mov     A, Temp8
16E4 857CB7     +1 11020             mov     FLKEY, Flash_Key_1              ; First key code
16E7 857DB7     +1 11021             mov     FLKEY, Flash_Key_2              ; Second key code
16EA F0         +1 11022             movx    @DPTR, A                                ; Write to flash
16EB 538FFE     +1 11023             anl     PSCTL, #0FEh                    ; Clear the PSWE bit
16EE 22         +1 11024             ret
                +1 11025     
                +1 11026     
                +1 11027     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                +1 11028     ;
                +1 11029     ; Erase flash routine (erases the flash segment used for "eeprom" variables)
                +1 11030     ;
                +1 11031     ; No assumptions
                +1 11032     ;
                +1 11033     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
16EF            +1 11034     erase_flash:    
16EF 438F02     +1 11035             orl     PSCTL, #02h                     ; Set the PSEE bit
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   176

16F2 438F01     +1 11036             orl     PSCTL, #01h                     ; Set the PSWE bit
16F5 857CB7     +1 11037             mov     FLKEY, Flash_Key_1              ; First key code
16F8 857DB7     +1 11038             mov     FLKEY, Flash_Key_2              ; Second key code
16FB 901A0D     +1 11039             mov     DPTR, #Eep_Initialized_L        
16FE F0         +1 11040             movx    @DPTR, A
16FF 538FFC     +1 11041             anl     PSCTL, #0FCh                    ; Clear the PSEE and PSWE bits
1702 22         +1 11042             ret
                +1 11043     
                +1 11044     
                +1 11045     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                +1 11046     ;
                +1 11047     ; Write eeprom signature routine
                +1 11048     ;
                +1 11049     ; No assumptions
                +1 11050     ;
                +1 11051     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
1703            +1 11052     write_eeprom_signature: 
                +1 11053     IF MODE == 0
1703 901A0D     +1 11054             mov     DPTR, #Eep_Initialized_L
1706 74A5       +1 11055             mov     A, #0A5h
1708 D1D4       +1 11056             call write_eeprom_byte_from_acc
                +1 11057     
170A 901A0E     +1 11058             mov     DPTR, #Eep_Initialized_H
170D 745A       +1 11059             mov     A, #05Ah
170F D1D4       +1 11060             call write_eeprom_byte_from_acc
                +1 11061     ENDIF
                +1 11062     IF MODE == 1
                +1                   mov     DPTR, #Eep_Initialized_L
                +1                   mov     A, #05Ah
                +1                   call write_eeprom_byte_from_acc
                +1           
                +1                   mov     DPTR, #Eep_Initialized_H
                +1                   mov     A, #0A5h
                +1                   call write_eeprom_byte_from_acc
                +1           ENDIF
                +1 11071     IF MODE == 2
                +1                   mov     DPTR, #Eep_Initialized_L
                +1                   mov     A, #055h
                +1                   call write_eeprom_byte_from_acc
                +1           
                +1                   mov     DPTR, #Eep_Initialized_H
                +1                   mov     A, #0AAh
                +1                   call write_eeprom_byte_from_acc
                +1           ENDIF
1711 22         +1 11080             ret
                +1 11081     
                +1 11082     
                +1 11083     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                +1 11084     ;
                +1 11085     ; Read all tags from flash and store in temporary storage
                +1 11086     ;
                +1 11087     ; No assumptions
                +1 11088     ;
                +1 11089     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
1712            +1 11090     read_tags:
1712 7A30       +1 11091             mov     Temp3, #48                              ; Number of tags
1714 79D0       +1 11092             mov     Temp2, #Tag_Temporary_Storage   ; Set RAM address
1716 7820       +1 11093             mov     Temp1, #Bit_Access
1718 901A40     +1 11094             mov     DPTR, #Eep_ESC_Layout           ; Set flash address
171B            +1 11095     read_tag:       
171B D1CF       +1 11096             call read_eeprom_byte
171D E520       +1 11097             mov     A, Bit_Access
171F F7         +1 11098             mov     @Temp2, A                       ; Write to RAM
1720 09         +1 11099             inc     Temp2
1721 A3         +1 11100             inc     DPTR
1722 DAF7       +1 11101             djnz Temp3, read_tag    
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   177

1724 22         +1 11102             ret
                +1 11103     
                +1 11104     
                +1 11105     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                +1 11106     ;
                +1 11107     ; Write all tags from temporary storage and store in flash
                +1 11108     ;
                +1 11109     ; No assumptions
                +1 11110     ;
                +1 11111     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
1725            +1 11112     write_tags:
1725 7A30       +1 11113             mov     Temp3, #48                              ; Number of tags
1727 79D0       +1 11114             mov     Temp2, #Tag_Temporary_Storage   ; Set RAM address
1729 901A40     +1 11115             mov     DPTR, #Eep_ESC_Layout           ; Set flash address
172C            +1 11116     write_tag:      
172C E7         +1 11117             mov     A, @Temp2                       ; Read from RAM
172D D1D4       +1 11118             call write_eeprom_byte_from_acc
172F 09         +1 11119             inc     Temp2
1730 A3         +1 11120             inc     DPTR
1731 DAF9       +1 11121             djnz Temp3, write_tag   
1733 22         +1 11122             ret
                +1 11123     
                +1 11124     
                +1 11125     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                +1 11126     ;
                +1 11127     ; Store new parameter value in ram routine
                +1 11128     ;
                +1 11129     ; No assumptions
                +1 11130     ;
                +1 11131     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
1734            +1 11132     store_new_value_in_ram: 
1734 AB74       +1 11133             mov     Temp4, Tx_Pgm_Func_No   ; Function no
1736 A875       +1 11134             mov     Temp1, Tx_Pgm_Paraval_No        ; Parameter value no
                +1 11135     IF MODE == 0
1738            +1 11136     store_main_func_1:
1738 BB0102     +1 11137             cjne    Temp4, #1, store_main_func_2
173B 7980       +1 11138             mov     Temp2, #Pgm_Gov_P_Gain
                +1 11139     
173D            +1 11140     store_main_func_2:
173D BB0202     +1 11141             cjne    Temp4, #2, store_main_func_3
1740 7981       +1 11142             mov     Temp2, #Pgm_Gov_I_Gain
                +1 11143     
1742            +1 11144     store_main_func_3:
1742 BB0302     +1 11145             cjne    Temp4, #3, store_main_func_4
1745 7982       +1 11146             mov     Temp2, #Pgm_Gov_Mode
                +1 11147     
1747            +1 11148     store_main_func_4:
1747 BB0402     +1 11149             cjne    Temp4, #4, store_main_func_5
174A 7994       +1 11150             mov     Temp2, #Pgm_Gov_Range
                +1 11151     
174C            +1 11152     store_main_func_5:
174C BB0502     +1 11153             cjne    Temp4, #5, store_main_func_6
174F 7983       +1 11154             mov     Temp2, #Pgm_Low_Voltage_Lim
                +1 11155     
1751            +1 11156     store_main_func_6:
1751 BB0602     +1 11157             cjne    Temp4, #6, store_main_func_7
1754 7986       +1 11158             mov     Temp2, #Pgm_Startup_Pwr
                +1 11159     
1756            +1 11160     store_main_func_7:
1756 BB0702     +1 11161             cjne    Temp4, #7, store_main_func_8
1759 7992       +1 11162             mov     Temp2, #Pgm_Comm_Timing
                +1 11163     
175B            +1 11164     store_main_func_8:
175B BB0802     +1 11165             cjne    Temp4, #8, store_main_func_9
175E 7987       +1 11166             mov     Temp2, #Pgm_Pwm_Freq
                +1 11167     
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   178

1760            +1 11168     store_main_func_9:
1760 BB0902     +1 11169             cjne    Temp4, #9, store_main_func_10
1763 799C       +1 11170             mov     Temp2, #Pgm_Demag_Comp
                +1 11171     
1765            +1 11172     store_main_func_10:
1765 BB0A02     +1 11173             cjne    Temp4, #10, store_main_func_11
1768 7988       +1 11174             mov     Temp2, #Pgm_Direction
                +1 11175     
176A            +1 11176     store_main_func_11:
176A BB0B02     +1 11177             cjne    Temp4, #11, store_in_ram_exit
176D 7989       +1 11178             mov     Temp2, #Pgm_Input_Pol
                +1 11179     ENDIF
                +1 11180     IF MODE == 1
                +1           store_tail_func_1:
                +1                   cjne    Temp4, #1, store_tail_func_2
                +1                   mov     Temp2, #Pgm_Motor_Gain
                +1           
                +1           store_tail_func_2:
                +1                   cjne    Temp4, #2, store_tail_func_3
                +1                   mov     Temp2, #Pgm_Motor_Idle
                +1           
                +1           store_tail_func_3:
                +1                   cjne    Temp4, #3, store_tail_func_4
                +1                   mov     Temp2, #Pgm_Startup_Pwr
                +1           
                +1           store_tail_func_4:
                +1                   cjne    Temp4, #4, store_tail_func_5
                +1                   mov     Temp2, #Pgm_Comm_Timing
                +1           
                +1           store_tail_func_5:
                +1                   cjne    Temp4, #5, store_tail_func_6
                +1                   mov     Temp2, #Pgm_Pwm_Freq
                +1           
                +1           store_tail_func_6:
                +1                   cjne    Temp4, #6, store_tail_func_7
                +1                   mov     Temp2, #Pgm_Pwm_Dither
                +1           
                +1           store_tail_func_7:
                +1                   cjne    Temp4, #7, store_tail_func_8
                +1                   mov     Temp2, #Pgm_Demag_Comp
                +1           
                +1           store_tail_func_8:
                +1                   cjne    Temp4, #8, store_tail_func_9
                +1                   mov     Temp2, #Pgm_Direction
                +1           
                +1           store_tail_func_9:
                +1                   cjne    Temp4, #9, store_in_ram_exit
                +1                   mov     Temp2, #Pgm_Input_Pol
                +1           ENDIF
                +1 11217     IF MODE == 2 
                +1           store_multi_func_1:
                +1                   cjne    Temp4, #1, store_multi_func_2
                +1                   mov     Temp2, #Pgm_Gov_P_Gain
                +1           
                +1           store_multi_func_2:
                +1                   cjne    Temp4, #2, store_multi_func_3
                +1                   mov     Temp2, #Pgm_Gov_I_Gain
                +1           
                +1           store_multi_func_3:
                +1                   cjne    Temp4, #3, store_multi_func_4
                +1                   mov     Temp2, #Pgm_Gov_Mode
                +1           
                +1           store_multi_func_4:
                +1                   cjne    Temp4, #4, store_multi_func_5
                +1                   mov     Temp2, #Pgm_Motor_Gain
                +1           
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   179

                +1           store_multi_func_5:
                +1                   cjne    Temp4, #5, store_multi_func_6
                +1                   mov     Temp2, #Pgm_Startup_Pwr
                +1           
                +1           store_multi_func_6:
                +1                   cjne    Temp4, #6, store_multi_func_7
                +1                   mov     Temp2, #Pgm_Comm_Timing
                +1           
                +1           store_multi_func_7:
                +1                   cjne    Temp4, #7, store_multi_func_8
                +1                   mov     Temp2, #Pgm_Pwm_Freq
                +1           
                +1           store_multi_func_8:
                +1                   cjne    Temp4, #8, store_multi_func_9
                +1                   mov     Temp2, #Pgm_Pwm_Dither
                +1           
                +1           store_multi_func_9:
                +1                   cjne    Temp4, #9, store_multi_func_10
                +1                   mov     Temp2, #Pgm_Demag_Comp
                +1           
                +1           store_multi_func_10:
                +1                   cjne    Temp4, #10, store_multi_func_11
                +1                   mov     Temp2, #Pgm_Direction
                +1           
                +1           store_multi_func_11:
                +1                   cjne    Temp4, #11, store_in_ram_exit
                +1                   mov     Temp2, #Pgm_Input_Pol
                +1           ENDIF
                +1 11262     
176F            +1 11263     store_in_ram_exit:
176F E8         +1 11264             mov     A, Temp1
1770 F7         +1 11265             mov     @Temp2, A
1771 22         +1 11266             ret
                +1 11267     
                +1 11268     
                +1 11269     ;**;**** **** **** **** **** **** **** **** **** **** **** **** ****
                +1 11270     ;
                +1 11271     ; Wait 1 second routine
                +1 11272     ;
                +1 11273     ; No assumptions
                +1 11274     ;
                +1 11275     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
1772            +1 11276     wait1s:
1772 7C05       +1 11277             mov     Temp5, #5
1774            +1 11278     wait1s_loop:
1774 12055D     +1 11279             call wait200ms
1777 DCFB       +1 11280             djnz    Temp5, wait1s_loop
1779 22         +1 11281             ret
                +1 11282     
                +1 11283     
                +1 11284     ;**;**** **** **** **** **** **** **** **** **** **** **** **** ****
                +1 11285     ;
                +1 11286     ; Success beep routine
                +1 11287     ;
                +1 11288     ; No assumptions
                +1 11289     ;
                +1 11290     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
177A            +1 11291     success_beep:
177A C2AF       +1 11292             clr     EA                                      ; Disable all interrupts
177C 12056C     +1 11293             call beep_f1
177F 120572     +1 11294             call beep_f2
1782 120578     +1 11295             call beep_f3
1785 12057E     +1 11296             call beep_f4
1788 120551     +1 11297             call wait10ms
178B 12056C     +1 11298             call beep_f1
178E 120572     +1 11299             call beep_f2
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   180

1791 120578     +1 11300             call beep_f3
1794 12057E     +1 11301             call beep_f4
1797 120551     +1 11302             call wait10ms
179A 12056C     +1 11303             call beep_f1
179D 120572     +1 11304             call beep_f2
17A0 120578     +1 11305             call beep_f3
17A3 12057E     +1 11306             call beep_f4
17A6 D2AF       +1 11307             setb    EA                                      ; Enable all interrupts
17A8 22         +1 11308             ret
                +1 11309     
                +1 11310     
                +1 11311     ;**;**** **** **** **** **** **** **** **** **** **** **** **** ****
                +1 11312     ;
                +1 11313     ; Success beep inverted routine
                +1 11314     ;
                +1 11315     ; No assumptions
                +1 11316     ;
                +1 11317     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
17A9            +1 11318     success_beep_inverted:
17A9 C2AF       +1 11319             clr     EA                                      ; Disable all interrupts
17AB 12057E     +1 11320             call beep_f4
17AE 120578     +1 11321             call beep_f3
17B1 120572     +1 11322             call beep_f2
17B4 12056C     +1 11323             call beep_f1
17B7 120551     +1 11324             call wait10ms
17BA 12057E     +1 11325             call beep_f4
17BD 120578     +1 11326             call beep_f3
17C0 120572     +1 11327             call beep_f2
17C3 12056C     +1 11328             call beep_f1
17C6 120551     +1 11329             call wait10ms
17C9 12057E     +1 11330             call beep_f4
17CC 120578     +1 11331             call beep_f3
17CF 120572     +1 11332             call beep_f2
17D2 12056C     +1 11333             call beep_f1
17D5 D2AF       +1 11334             setb    EA                                      ; Enable all interrupts
17D7 22         +1 11335             ret
                +1 11336     
                +1 11337     
                +1 11338     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                +1 11339     ;
                +1 11340     ; Function and parameter value beep routine
                +1 11341     ;
                +1 11342     ; No assumptions
                +1 11343     ;
                +1 11344     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
17D8            +1 11345     function_paraval_beep:
17D8 AE74       +1 11346             mov     Temp7, Tx_Pgm_Func_No   ; Function no
17DA AF75       +1 11347             mov     Temp8, Tx_Pgm_Paraval_No        ; Parameter value no
17DC C2AF       +1 11348             clr     EA                                      ; Disable all interrupts
17DE            +1 11349     function_beep:
17DE 12056C     +1 11350             call beep_f1                            
17E1 12056C     +1 11351             call beep_f1
17E4 12056C     +1 11352             call beep_f1
17E7 120551     +1 11353             call wait10ms
17EA DEF2       +1 11354             djnz    Temp7, function_beep
17EC            +1 11355     paraval_beep:
17EC 12057E     +1 11356             call beep_f4
17EF 120551     +1 11357             call wait10ms
17F2 DFF8       +1 11358             djnz    Temp8, paraval_beep
17F4 D2AF       +1 11359             setb    EA                                      ; Enable all interrupts
17F6 22         +1 11360             ret
                +1 11361     
                +1 11362     
                +1 11363     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                +1 11364     ;
                +1 11365     ; Program by TX routine
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   181

                +1 11366     ;
                +1 11367     ; No assumptions
                +1 11368     ;
                +1 11369     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
17F7            +1 11370     program_by_tx:  
                +1 11371             ; Programming mode entry beeps
17F7 F17A       +1 11372             call success_beep
17F9 F172       +1 11373             call wait1s
17FB F172       +1 11374             call wait1s
                +1 11375     
                +1 11376             ; Start at function 1, parameter value 1
17FD 757401     +1 11377             mov     Tx_Pgm_Func_No, #1
1800            +1 11378     paraval_no_entry:
1800 757501     +1 11379             mov     Tx_Pgm_Paraval_No, #1
1803            +1 11380     beep_no_entry:
1803 757600     +1 11381             mov     Tx_Pgm_Beep_No, #0
1806            +1 11382     func_paraval:
1806 1217D8     +1 11383             call function_paraval_beep
1809 7C05       +1 11384             mov     Temp5, #5                               ; Wait is 5x 200ms
180B            +1 11385     func_paraval_wait:
180B AD5C       +1 11386             mov     Temp6, New_Rcp                  ; Load RC pulse
180D 12055D     +1 11387             call wait200ms
1810 C3         +1 11388             clr     C
1811 ED         +1 11389             mov     A, Temp6
1812 955C       +1 11390             subb    A, New_Rcp                      ; Is RC pulse stable? (Avoid issues from 3i
                             n1 interference)
1814 70F5       +1 11391             jnz     func_paraval_wait               ; No - branch
1816 C3         +1 11392             clr     C
1817 E55C       +1 11393             mov     A, New_Rcp                      ; Load new RC pulse value
1819 9401       +1 11394             subb    A, #RCP_STOP                    ; Below stop?
181B 400A       +1 11395             jc      func_paraval_store              ; Yes - branch
                +1 11396     
181D C3         +1 11397             clr     C
181E E55C       +1 11398             mov     A, New_Rcp                      ; Load new RC pulse value
1820 94FF       +1 11399             subb    A, #RCP_MAX                     ; Below max?
1822 4037       +1 11400             jc      function_next                   ; Yes - branch
                +1 11401     
1824 021838     +1 11402             ljmp    func_paraval_cont_wait  ; No - branch
                +1 11403     
1827            +1 11404     func_paraval_store:
1827 121734     +1 11405             call    store_new_value_in_ram          ; Yes - store new value in RAM
182A 121696     +1 11406             call    erase_and_store_all_in_eeprom   ; Store all values in EEPROM
182D 12177A     +1 11407             call success_beep                       ; Beep success
1830 C2AF       +1 11408             clr     EA                                      ; Disable all interrupts
                +1 11409     IF ONE_S_CAPABLE == 0           
1832 75EF16     +1 11410             mov     RSTSRC, #16h                    ; Generate hardware reset and set missing c
                             lock and VDD monitor
                +1 11411     ELSE
                +1                   mov     RSTSRC, #14h                    ; Generate hardware reset and disable VDD m
                             onitor
                +1           ENDIF
1835 121772     +1 11414             call wait1s
                +1 11415     
1838            +1 11416     func_paraval_cont_wait:
1838 DCD1       +1 11417             djnz    Temp5, func_paraval_wait
183A 0576       +1 11418             inc     Tx_Pgm_Beep_No                  ; Check number of beeps
183C C3         +1 11419             clr     C
183D E576       +1 11420             mov     A, Tx_Pgm_Beep_No               
183F 9403       +1 11421             subb    A, #3                           ; Three beeps done?
1841 5002       +1 11422             jnc     paraval_next                    ; Yes - Next parameter value
                +1 11423     
1843 80C1       +1 11424             jmp     func_paraval                    ; No - go back
                +1 11425     
1845            +1 11426     paraval_next:                                   
1845 121772     +1 11427             call wait1s
1848 0575       +1 11428             inc     Tx_Pgm_Paraval_No               ; Parameter value no
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   182

                +1 11429     IF MODE == 0
184A E574       +1 11430             mov     A, Tx_Pgm_Func_No               ; Decode number of parameters
184C 14         +1 11431             dec     A       
184D 90009F     +1 11432             mov     DPTR, #TX_PGM_PARAMS_MAIN
1850 93         +1 11433             movc A, @A+DPTR 
1851 F8         +1 11434             mov     Temp1, A
                +1 11435     ENDIF
                +1 11436     IF MODE == 1
                +1                   mov     A, Tx_Pgm_Func_No               ; Decode number of parameters
                +1                   dec     A       
                +1                   mov     DPTR, #TX_PGM_PARAMS_TAIL
                +1                   movc A, @A+DPTR 
                +1                   mov     Temp1, A
                +1           ENDIF
                +1 11443     IF MODE == 2
                +1                   mov     A, Tx_Pgm_Func_No               ; Decode number of parameters
                +1                   dec     A       
                +1                   mov     DPTR, #TX_PGM_PARAMS_MULTI
                +1                   movc A, @A+DPTR 
                +1                   mov     Temp1, A
                +1           ENDIF
1852 08         +1 11450             inc     Temp1
1853 C3         +1 11451             clr     C
1854 E575       +1 11452             mov     A, Tx_Pgm_Paraval_No            
1856 98         +1 11453             subb    A, Temp1                                
1857 5002       +1 11454             jnc     function_next                   ; Last parameter value?
1859 80A8       +1 11455             jmp     beep_no_entry                   ; No - go back
                +1 11456     
185B            +1 11457     function_next:                                  ; Yes - Next function value
185B 121772     +1 11458             call wait1s
185E 121772     +1 11459             call wait1s
1861 0574       +1 11460             inc     Tx_Pgm_Func_No                  ; Function value no
                +1 11461     IF MODE == 0
1863 C3         +1 11462             clr     C
1864 E574       +1 11463             mov     A, Tx_Pgm_Func_No               
1866 940C       +1 11464             subb    A, #12                          ; Main has 11 functions 
                +1 11465     ENDIF
                +1 11466     IF MODE == 1
                +1                   clr     C
                +1                   mov     A, Tx_Pgm_Func_No               
                +1                   subb    A, #10                          ; Tail has 9 functions  
                +1           ENDIF
                +1 11471     IF MODE == 2 
                +1                   clr     C
                +1                   mov     A, Tx_Pgm_Func_No               
                +1                   subb    A, #12                          ; Multi has 11 functions        
                +1           ENDIF
1868 5002       +1 11476             jnc     program_by_tx_exit              ; Last function value?
186A 8094       +1 11477             jmp     paraval_no_entry                ; No - go back
                +1 11478     
186C            +1 11479     program_by_tx_exit:
186C 120FA7     +1 11480             call set_default_parameters             ; Load all defaults
186F 121696     +1 11481             call erase_and_store_all_in_eeprom      ; Erase flash and program
1872 C2AF       +1 11482             clr     EA                                      ; Disable all interrupts
                +1 11483     IF ONE_S_CAPABLE == 0           
1874 75EF16     +1 11484             mov     RSTSRC, #16h                    ; Generate hardware reset and set missing c
                             lock and VDD monitor
                +1 11485     ELSE
                +1                   mov     RSTSRC, #14h                    ; Generate hardware reset and disable VDD m
                             onitor
                +1           ENDIF
1877 121772     +1 11488             call wait1s
                   11489     ;$include (BLHeliBootLoad.inc) ; Include source code for bootloader
                +1 11490     ; BLHeli bootloader for SiLabs MCUs. Based upon AVRootloader (copyright HR)
                +1 11491     
  7840          +1 11492     XTAL                                    EQU     25000000        
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   183

                +1 11493     
  1C00          +1 11494     BOOT_START                      EQU     1C00h   ; Bootloader segment address
  1E10          +1 11495     BOOT_DELAY                      EQU     XTAL/4  ; About 250ms (don't set to fast to avoid c
                             onnection problems)
  4B00          +1 11496     BOOT_BAUDRATE                   EQU     19200   ; Only used if no baudrate detection activa
                             ted, XTAL is than important
  0006          +1 11497     BOOT_VERSION                    EQU     6               ; Version 6 (must be not changed)
  0001          +1 11498     BOOT_PAGES                      EQU     1               ; Number of flash segments for boot
                             loader
                +1 11499     
  001A          +1 11500     UART_LOOP                               EQU     26              ; Depends upon timing of pu
                             tc, getc 
  FFE6          +1 11501     BAUDTIME                                EQU     ((XTAL/BOOT_BAUDRATE)/3)-UART_LOOP
                +1 11502     
  0030          +1 11503     SUCCESS                         EQU     030h
  00C0          +1 11504     ERRORVERIFY                     EQU     0C0h
  00C1          +1 11505     ERRORCOMMAND                    EQU     0C1h
  00C2          +1 11506     ERRORCRC                                EQU     0C2h
  00C5          +1 11507     ERRORPROG                               EQU     0C5h
                +1 11508     
  A001          +1 11509     POLYNOM                         EQU     0A001h          ; CRC Polynom
                +1 11510     
  REG           +1 11511     Xl                                      EQU     R0                      ; Temporary X
  REG           +1 11512     Xh                                      EQU     R1
  REG           +1 11513     Paral                           EQU     R2                      ; Params for UART
  REG           +1 11514     Parah                           EQU     R3      
  REG           +1 11515     Cmdl                                    EQU     R4                      ; Commands
  REG           +1 11516     Cmdh                                    EQU     R5      
  REG           +1 11517     Cntl                                    EQU     R6                      ; Baudtime
  REG           +1 11518     Cnth                                    EQU     R7
                +1 11519     
----            +1 11520     DSEG AT 20h                                     
0020            +1 11521     Bit_Reg:                                DS      1                       ; Bit storage regis
                             ter
0021            +1 11522     Byte_Reg:                               DS      1                       ; Byte storage regi
                             ster
0022            +1 11523     Crcl:                           DS      1                       ; CRC 16Bit
0023            +1 11524     Crch:                           DS      1
0024            +1 11525     Baudl:                          DS      1                       ; Baudtime
0025            +1 11526     Baudh:                          DS      1
0026            +1 11527     Bit_Cnt:                                DS      1                       ; Counter in UART l
                             oops
0027            +1 11528     Byte_Cntl:                      DS      1                       ; Generic counter
0028            +1 11529     Byte_Cnth:                      DS      1                       
0029            +1 11530     BL_Flash_Key_1:         DS      1                       ; Flash keys
002A            +1 11531     BL_Flash_Key_2:         DS      1
                +1 11532     
----            +1 11533     CSEG AT BOOT_START              ; Bootloader start
1C00 C2AF       +1 11534     init:clr        EA
                +1 11535             ; Select register bank 0 for main program routines
1C02 C2D3       +1 11536             clr     PSW.3                           ; Select register bank 0 for main program r
                             outines      
                +1 11537             ; Disable the WDT.
                +1 11538     IF SIGNATURE_001 == 0f3h                
                +1                   anl     PCA0MD, #NOT(40h)               ; Clear watchdog enable bit
                +1           ENDIF
                +1 11541     IF SIGNATURE_001 == 0f8h                
1C04 7597DE     +1 11542             mov     WDTCN, #0DEh                    ; Disable watchdog
1C07 7597AD     +1 11543             mov     WDTCN, #0ADh            
                +1 11544     ENDIF
                +1 11545             ; Initialize stack
1C0A 7581C0     +1 11546             mov     SP, #0c0h                               ; Stack = 64 upper bytes of RAM
                +1 11547             ; Initialize clock
                +1 11548     IF SIGNATURE_001 == 0f3h                
                +1                   orl     OSCICN, #03h                    ; Set clock divider to 1 (not supported on 
                             'f850)
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   184

                +1           ENDIF
                +1 11551     IF SIGNATURE_001 == 0f8h                
1C0D 75A900     +1 11552             mov     CLKSEL, #00h                    ; Set clock divider to 1 (not supported on 
                             'f3xx)
                +1 11553     ENDIF
                +1 11554             ; Initialize VDD monitor
1C10 43FF80     +1 11555             orl     VDM0CN, #080h                   ; Enable the VDD monitor
1C13 752438     +1 11556             mov     Baudl, #38h                     ; Wait 100us
1C16 752503     +1 11557             mov     Baudh, #03h
1C19 B1DB       +1 11558             acall waitf
                +1 11559             ; Initialize flash keys
1C1B 7529A5     +1 11560             mov     BL_Flash_Key_1, #0A5h   ; First key code
1C1E 752AF1     +1 11561             mov     BL_Flash_Key_2, #0F1h   ; Second key code
                +1 11562             ; Initialize ports
                +1 11563     IF SIGNATURE_001 == 0f3h                
                +1                   mov     XBR1, #40h;                     ; Enable crossbar
                +1           ENDIF
                +1 11566     IF SIGNATURE_001 == 0f8h                
1C21 75E340     +1 11567             mov     XBR2, #40h;                     ; Enable crossbar
                +1 11568     ENDIF
1C24 43F120     +1 11569             orl     RTX_MDIN, #(1 SHL RTX_PIN)              ; Set digital
1C27 53A4DF     +1 11570             anl     RTX_MDOUT, #NOT(1 SHL RTX_PIN)  ; Disable pushpull
1C2A 75D4FF     +1 11571             mov     RTX_SKIP, #0FFh
1C2D D285       +1 11572             setb    RTX_PORT.RTX_PIN                ; Set data high
                +1 11573             ; Set number of connect attempts before exiting bootloader
1C2F 7DFA       +1 11574             mov     Cmdh, #250
                +1 11575     
                +1 11576             ; Identifier scanning
1C31 7803       +1 11577     abd:    mov     Xl, #(low(BOOT_DELAY / 6)+1)
1C33 7906       +1 11578             mov     Xh, #(high(BOOT_DELAY / 6)+1)
1C35 7C01       +1 11579             mov     Cmdl, #(high((BOOT_DELAY / 6) SHR 8)+1)
1C37 752200     +1 11580             mov     Crcl, #0
1C3A 752300     +1 11581             mov     Crch, #0
1C3D 901DE8     +1 11582             mov     DPTR, #BOOT_SIGN
1C40 7B06       +1 11583             mov     Parah, #(BOOT_MSG - BOOT_SIGN)
1C42 7524E6     +1 11584             mov     Baudl, #low(BAUDTIME)
1C45 7525FF     +1 11585             mov     Baudh, #high(BAUDTIME)
                +1 11586     
1C48            +1 11587     wait_for_low:
1C48 308502     +1 11588             jnb     RTX_PORT.RTX_PIN, ($+5)
1C4B 8148       +1 11589             ajmp wait_for_low
                +1 11590     
                +1 11591             ; Identifier (BOOT_SIGN) scanning with timeout and checksum
1C4D 208508     +1 11592     id1:    jb      RTX_PORT.RTX_PIN, id3   ; Look for high
1C50 D8FB       +1 11593             djnz    Xl, id1                         ; Subtract 1 from X (BOOT_DELAY)
1C52 D9F9       +1 11594             djnz    Xh, id1
1C54 DCF7       +1 11595             djnz    Cmdl, id1 
                +1 11596     
1C56 81BA       +1 11597             ajmp    exit
                +1 11598     
1C58 308508     +1 11599     id3:    jnb     RTX_PORT.RTX_PIN, id4   ; Look for low
1C5B D8FB       +1 11600             djnz    Xl, id3                         ; Subtract 1 from X (BOOT_DELAY)
1C5D D9F9       +1 11601             djnz    Xh, id3
1C5F DCF7       +1 11602             djnz    Cmdl, id3
                +1 11603     
1C61 81BA       +1 11604             ajmp    exit
                +1 11605     
1C63 B19B       +1 11606     id4:    acall getx                              ; Read character
1C65 E4         +1 11607             clr     A                       
1C66 93         +1 11608             movc A, @A+DPTR                 ; Load BOOT_SIGN character
1C67 A3         +1 11609             inc     DPTR
1C68 C3         +1 11610             clr     C
1C69 9A         +1 11611             subb    A, Paral                                ; Compare with read character
1C6A 6004       +1 11612             jz      id5
1C6C DDC3       +1 11613             djnz    Cmdh, abd                               ; Retry if not last connect attempt
1C6E 81BA       +1 11614             ajmp    exit
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   185

                +1 11615     
1C70            +1 11616     id5:
1C70 DBDB       +1 11617             djnz    Parah, id1
                +1 11618     
1C72 B18D       +1 11619             acall getw                              ; Read CRC
1C74 6002       +1 11620             jz      ($+4)                           ; Check CRC
1C76 8131       +1 11621             ajmp    abd
                +1 11622             
                +1 11623             ; Send info about chip/bootloader (BOOT_MSG + BOOT_INFO)
1C78 7B08       +1 11624             mov     Parah, #((BOOT_INFO - BOOT_MSG) + 4)
1C7A E4         +1 11625     in1:    clr     A                       
1C7B 93         +1 11626             movc A, @A+DPTR                 ; Load character
1C7C FA         +1 11627             mov     Paral, A
1C7D A3         +1 11628             inc     DPTR
1C7E B16E       +1 11629             acall putc
1C80 DBF8       +1 11630             djnz    Parah, in1
                +1 11631     
                +1 11632     
                +1 11633             ; Main commandloop
                +1 11634             ; 0=Run/restart 
                +1 11635             ; 1=Program flash, 2=Erase flash, 3=Read flash
                +1 11636             ; 0xFF=Set address, 0xFE=Set buffer, 0xFD=Keep alive 
1C82 7A30       +1 11637     main:mov        Paral, #SUCCESS
1C84 B16E       +1 11638     mai1:acall putc
1C86 752200     +1 11639             mov     Crcl, #0                                ; Reset CRC
1C89 752300     +1 11640             mov     Crch, #0
1C8C B18D       +1 11641             acall getw                              ; Get command
1C8E EA         +1 11642             mov     A, Paral
1C8F FC         +1 11643             mov     Cmdl, A
1C90 EB         +1 11644             mov     A, Parah
1C91 FD         +1 11645             mov     Cmdh, A
1C92 C3         +1 11646             clr     C
1C93 ED         +1 11647             mov     A, Cmdh
1C94 94FE       +1 11648             subb    A, #0FEh
1C96 400E       +1 11649             jc      mai2                                    ; Jump if not set address or set bu
                             ffer 
                +1 11650     
1C98 B18D       +1 11651             acall getw                              ; Address or number of bytes
1C9A 8A27       +1 11652             mov     Byte_Cntl, Paral                ; Store number of bytes for set buffer
1C9C 8B28       +1 11653             mov     Byte_Cnth, Parah        
1C9E ED         +1 11654             mov     A, Cmdh
1C9F 30E004     +1 11655             jnb     ACC.0, mai2                     ; Jump if set buffer
                +1 11656     
1CA2 8A82       +1 11657             mov     DPL, Paral                      ; Store flash address (for set address)
1CA4 8B83       +1 11658             mov     DPH, Parah
                +1 11659     
1CA6 B18D       +1 11660     mai2:acall getw                         ; Get CRC
1CA8 7AC2       +1 11661             mov     Paral, #ERRORCRC
1CAA 70D8       +1 11662             jnz     mai1
1CAC C3         +1 11663             clr     C
1CAD ED         +1 11664             mov     A, Cmdh
1CAE 94FE       +1 11665             subb    A, #0FEh
1CB0 6019       +1 11666             jz      setbuf                          ; If command is set buffer, receive data
1CB2 50CE       +1 11667             jnc     main
                +1 11668     
1CB4 BD0029     +1 11669             cjne    Cmdh, #0, mai4                  ; Jump if command != 0 (and not set buffer)
                +1 11670     
                +1 11671             ; Run application/restart bootloader
1CB7 EC         +1 11672             mov     A, Cmdl
1CB8 600F       +1 11673             jz      rst
1CBA 752000     +1 11674     exit:mov        Bit_Access, #0                  ; Clear variable used by flash lock detect
1CBD 7521FF     +1 11675             mov     Bit_Access_Int, #0FFh   ; Set variable to indicate that program execution c
                             ame from bootloader
1CC0 752900     +1 11676             mov     BL_Flash_Key_1, #0              ; Set flash keys to invalid values
1CC3 752A00     +1 11677             mov     BL_Flash_Key_2, #0
1CC6 020000     +1 11678             ljmp    0000h
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   186

1CC9 8100       +1 11679     rst:    ajmp    init
                +1 11680     
                +1 11681             ; Set buffer
1CCB A827       +1 11682     setbuf:mov Xl, Byte_Cntl                        ; Set number of bytes 
1CCD A928       +1 11683             mov     Xh, Byte_Cnth
1CCF 08         +1 11684             inc     Xl      
1CD0 09         +1 11685             inc     Xh      
1CD1 D804       +1 11686     set4:djnz       Xl, set5
1CD3 D902       +1 11687             djnz    Xh, set5
1CD5 81DD       +1 11688             ajmp    set6
                +1 11689     
1CD7 B191       +1 11690     set5:acall getc                         ; Receive data
1CD9 EA         +1 11691             mov     A, Paral
                +1 11692     IF SIGNATURE_001 == 0f3h                
                +1                   mov     EMI0CN, Xh
                +1           ENDIF
1CDA F2         +1 11695             movx    @Xl, A                          ; Store data in XRAM
1CDB 81D1       +1 11696             ajmp    set4
                +1 11697     
1CDD 0D         +1 11698     set6:inc        Cmdh    
1CDE 81A6       +1 11699             ajmp    mai2
                +1 11700     
1CE0 C3         +1 11701     mai4:clr        C
1CE1 ED         +1 11702             mov     A, Cmdh
1CE2 9403       +1 11703             subb    A, #3
1CE4 5051       +1 11704             jnc     mai5                                    ; Jump if command >= 3
                +1 11705     
                +1 11706             ; Program/erase
1CE6 ED         +1 11707             mov     A, Cmdh
1CE7 A2E0       +1 11708             mov     C, ACC.0
1CE9 9200       +1 11709             mov     Bit_Reg.0, C    
1CEB 7AC5       +1 11710             mov     Paral, #ERRORPROG
1CED C3         +1 11711             clr     C
1CEE E582       +1 11712             mov     A, DPL
1CF0 9400       +1 11713             subb    A, #low(BOOT_START)
1CF2 E583       +1 11714             mov     A, DPH
1CF4 941C       +1 11715             subb    A, #high(BOOT_START)
1CF6 508C       +1 11716             jnc     mai1                                    ; Jump if in bootloader segment
1CF8 200010     +1 11717             jb      Bit_Reg.0, pro3         ; Jump if program command
                +1 11718     
                +1 11719             ; Erase flash
1CFB 438F02     +1 11720             orl     PSCTL, #02h                     ; Set the PSEE bit
1CFE 438F01     +1 11721             orl     PSCTL, #01h                     ; Set the PSWE bit
1D01 8529B7     +1 11722             mov     FLKEY, BL_Flash_Key_1   ; First key code
1D04 852AB7     +1 11723             mov     FLKEY, BL_Flash_Key_2   ; Second key code
1D07 F0         +1 11724             movx    @DPTR, A
1D08 300027     +1 11725             jnb     Bit_Reg.0, pro6         ; Jump if erase command
                +1 11726     
                +1 11727             ; Program flash
1D0B A827       +1 11728     pro3:mov        Xl, Byte_Cntl                   ; Set number of bytes 
1D0D A928       +1 11729             mov     Xh, Byte_Cnth
1D0F 08         +1 11730             inc     Xl      
1D10 09         +1 11731             inc     Xh      
1D11 438F01     +1 11732             orl     PSCTL, #01h                     ; Set the PSWE bit
1D14 538FFD     +1 11733             anl     PSCTL, #0FDh                    ; Clear the PSEE bit
1D17 D804       +1 11734     pro4:djnz       Xl, pro5
1D19 D902       +1 11735             djnz    Xh, pro5
1D1B A132       +1 11736             ajmp    pro6
                +1 11737     
1D1D            +1 11738     pro5:
1D1D C3         +1 11739             clr     C
1D1E E583       +1 11740             mov     A, DPH                          ; Check that address is not in bootloader a
                             rea
1D20 941C       +1 11741             subb    A, #1Ch
1D22 4003       +1 11742             jc      ($+5)
                +1 11743     
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   187

1D24 A3         +1 11744             inc     DPTR                                    ; Increment flash address
1D25 A117       +1 11745             ajmp    pro4
                +1 11746     
                +1 11747     IF SIGNATURE_001 == 0f3h                
                +1                   mov     EMI0CN, Xh
                +1           ENDIF
1D27 E2         +1 11750             movx    A, @Xl                          ; Read from XRAM                
1D28 8529B7     +1 11751             mov     FLKEY, BL_Flash_Key_1   ; First key code
1D2B 852AB7     +1 11752             mov     FLKEY, BL_Flash_Key_2   ; Second key code
1D2E F0         +1 11753             movx    @DPTR, A                                ; Write to flash
1D2F A3         +1 11754             inc     DPTR                                    ; Increment flash address
1D30 A117       +1 11755             ajmp    pro4
                +1 11756     
1D32 538FFC     +1 11757     pro6:anl        PSCTL, #0FCh                    ; Clear the PSEE and PSWE bits
1D35 8182       +1 11758             ajmp    main                                    ; Successfully done erase or program
                +1 11759     
                +1 11760             ; Read flash
1D37 7AC1       +1 11761     mai5:mov        Paral, #ERRORCOMMAND    ; Illegal command
1D39 BD030C     +1 11762             cjne    Cmdh, #3, mai6                  ; Jump if not read flash command
                +1 11763     
1D3C E4         +1 11764     rd1:    clr     A
1D3D 93         +1 11765             movc    A, @A+DPTR                      ; Read from flash
1D3E A3         +1 11766             inc     DPTR                                    ; Increment flash address
1D3F FA         +1 11767             mov     Paral, A
1D40 B152       +1 11768             acall putp
1D42 DCF8       +1 11769             djnz    Cmdl, rd1                       ; Decrement bytes to read       
                +1 11770     
1D44 B14A       +1 11771             acall putw                              ; CRC
1D46 8182       +1 11772             ajmp    main
                +1 11773     
1D48 8184       +1 11774     mai6:ajmp       mai1
                +1 11775     
                +1 11776     
                +1 11777     
                +1 11778     
                +1 11779             ; Send char with crc
1D4A AA22       +1 11780     putw:mov        Paral, Crcl
1D4C AB23       +1 11781             mov     Parah, Crch
1D4E B16E       +1 11782             acall putc
1D50 EB         +1 11783             mov     A, Parah
1D51 FA         +1 11784             mov     Paral, A
1D52 EA         +1 11785     putp:mov        A, Paral
1D53 6222       +1 11786             xrl     Crcl, A
1D55 752608     +1 11787             mov     Bit_Cnt, #8
1D58 C3         +1 11788     put1:clr        C
1D59 E523       +1 11789             mov     A, Crch
1D5B 13         +1 11790             rrc     A
1D5C F523       +1 11791             mov     Crch, A
1D5E E522       +1 11792             mov     A, Crcl
1D60 13         +1 11793             rrc     A
1D61 F522       +1 11794             mov     Crcl, A
1D63 5006       +1 11795             jnc     put2
                +1 11796     
1D65 6323A0     +1 11797             xrl     Crch, #high(POLYNOM)
1D68 632201     +1 11798             xrl     Crcl, #low(POLYNOM)
                +1 11799     
1D6B D526EA     +1 11800     put2:djnz       Bit_Cnt, put1
                +1 11801     
                +1 11802     
                +1 11803             ; Send char
1D6E B1DB       +1 11804     putc:acall waitf
1D70 B1DB       +1 11805             acall waitf
1D72 75260A     +1 11806             mov     Bit_Cnt, #10
1D75 EA         +1 11807             mov     A, Paral
1D76 F4         +1 11808             cpl     A
1D77 200102     +1 11809     put3:jb Bit_Reg.1, ($+5)
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   188

1D7A D285       +1 11810             setb    RTX_PORT.RTX_PIN                ; Set pin high
1D7C 300102     +1 11811             jnb     Bit_Reg.1, ($+5)
1D7F C285       +1 11812             clr     RTX_PORT.RTX_PIN                ; Set pin low
1D81 B1DB       +1 11813             acall waitf                                                     
1D83 C3         +1 11814             clr     C
1D84 13         +1 11815             rrc     A
1D85 4002       +1 11816             jc      put4            
                +1 11817                                                     
1D87 C201       +1 11818             clr     Bit_Reg.1
                +1 11819     
1D89 D526EB     +1 11820     put4:djnz       Bit_Cnt, put3
                +1 11821     
1D8C 22         +1 11822             ret
                +1 11823     
                +1 11824     
                +1 11825             ; Receive char/word
1D8D B191       +1 11826     getw:acall getc
1D8F EA         +1 11827             mov     A, Paral
1D90 FB         +1 11828             mov     Parah, A
1D91 208502     +1 11829     getc:jb RTX_PORT.RTX_PIN, ($+5) ; Wait for high
1D94 A191       +1 11830             ajmp    getc
                +1 11831     
1D96 308502     +1 11832     get1:jnb        RTX_PORT.RTX_PIN, ($+5) ; Wait for low
1D99 A196       +1 11833             ajmp    get1
                +1 11834     
1D9B 752608     +1 11835     getx:mov        Bit_Cnt, #8
1D9E AE24       +1 11836             mov     Cntl, Baudl
1DA0 AF25       +1 11837             mov     Cnth, Baudh
1DA2 C3         +1 11838             clr     C
1DA3 EF         +1 11839             mov     A, Cnth                         ; Wait half a baud
1DA4 13         +1 11840             rrc     A
1DA5 FF         +1 11841             mov     Cnth, A
1DA6 EE         +1 11842             mov     A, Cntl
1DA7 13         +1 11843             rrc     A
1DA8 FE         +1 11844             mov     Cntl, A
1DA9 B1DF       +1 11845             acall waith
1DAB B1DB       +1 11846     get2:acall waitf                                ; Wait one baud                            
                                                  
1DAD C3         +1 11847             clr     C
1DAE EA         +1 11848             mov     A, Paral
1DAF 13         +1 11849             rrc     A
1DB0 308502     +1 11850             jnb     RTX_PORT.RTX_PIN, ($+5)                 
1DB3 4480       +1 11851             orl     A, #080h
                +1 11852     
1DB5 FA         +1 11853             mov     Paral, A
1DB6 30E703     +1 11854             jnb     ACC.7, ($+6) 
1DB9 632201     +1 11855             xrl     Crcl, #low(POLYNOM)
                +1 11856     
1DBC C3         +1 11857             clr     C
1DBD E523       +1 11858             mov     A, Crch
1DBF 13         +1 11859             rrc     A
1DC0 F523       +1 11860             mov     Crch, A
1DC2 E522       +1 11861             mov     A, Crcl
1DC4 13         +1 11862             rrc     A
1DC5 F522       +1 11863             mov     Crcl, A
1DC7 5006       +1 11864             jnc     get3                            
                +1 11865     
1DC9 6323A0     +1 11866             xrl     Crch, #high(POLYNOM)
1DCC 632201     +1 11867             xrl     Crcl, #low(POLYNOM)
                +1 11868     
1DCF D526D9     +1 11869     get3:djnz       Bit_Cnt, get2
                +1 11870     
1DD2 E522       +1 11871             mov     A, Crcl 
1DD4 6523       +1 11872             xrl     A, Crch 
1DD6 6523       +1 11873             xrl     A, Crch 
1DD8 F522       +1 11874             mov     Crcl, A
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   189

1DDA 22         +1 11875             ret
                +1 11876     
                +1 11877     
                +1 11878             ; UART delays                                                                      
                                  
1DDB AE24       +1 11879     waitf:mov       Cntl, Baudl     
1DDD AF25       +1 11880             mov     Cnth, Baudh
1DDF 0E         +1 11881     waith:inc Cntl
1DE0 0F         +1 11882             inc     Cnth
1DE1 DEFE       +1 11883     wait1:djnz Cntl, wait1
1DE3 DFFC       +1 11884             djnz Cnth, wait1
                +1 11885     
1DE5 D201       +1 11886             setb    Bit_Reg.1
1DE7 22         +1 11887             ret                                                                     
                +1 11888     
                +1 11889     
1DE8 424C4865   +1 11890     BOOT_SIGN:      DB      "BLHeli"        
1DEC 6C69                    
                +1 11891     
1DEE 34373164   +1 11892     BOOT_MSG:               DB      "471d"          ; Interface-MCU_BootlaoderRevision
                +1 11893     
1DF2 F8500601   +1 11894     BOOT_INFO:      DB      SIGNATURE_001, SIGNATURE_002, BOOT_VERSION, BOOT_PAGES
                +1 11895     
                   11896     
                   11897     ;**** **** **** **** **** **** **** **** **** **** **** **** ****
                   11898     
                   11899     
                   11900     
----               11901     CSEG AT 19FDh
19FD               11902     reset:
19FD 02111E        11903     ljmp    pgm_start
                   11904     
                   11905     
                   11906     
                   11907     
                   11908     END
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   190

SYMBOL TABLE LISTING
------ ----- -------


N A M E                              T Y P E  V A L U E   ATTRIBUTES

ABD . . . . . . . . . . . . . . . .  C ADDR   1C31H   A   
AC. . . . . . . . . . . . . . . . .  B ADDR   00D0H.6 A   
ACC . . . . . . . . . . . . . . . .  D ADDR   00E0H   A   
ACK0. . . . . . . . . . . . . . . .  B ADDR   00C0H.1 A   
ACKRQ0. . . . . . . . . . . . . . .  B ADDR   00C0H.3 A   
ACTIVE_PAGE . . . . . . . . . . . .  N NUMB   0000H   A   
AD0BUSY . . . . . . . . . . . . . .  B ADDR   00E8H.4 A   
AD0EN . . . . . . . . . . . . . . .  B ADDR   00E8H.7 A   
AD0INT. . . . . . . . . . . . . . .  B ADDR   00E8H.5 A   
AD0WINT . . . . . . . . . . . . . .  B ADDR   00E8H.3 A   
ADC0AC. . . . . . . . . . . . . . .  D ADDR   00B3H   A   
ADC0CF. . . . . . . . . . . . . . .  D ADDR   00BCH   A   
ADC0CN0 . . . . . . . . . . . . . .  D ADDR   00E8H   A   
ADC0CN1 . . . . . . . . . . . . . .  D ADDR   00B2H   A   
ADC0GTH . . . . . . . . . . . . . .  D ADDR   00C4H   A   
ADC0GTL . . . . . . . . . . . . . .  D ADDR   00C3H   A   
ADC0H . . . . . . . . . . . . . . .  D ADDR   00BEH   A   
ADC0L . . . . . . . . . . . . . . .  D ADDR   00BDH   A   
ADC0LTH . . . . . . . . . . . . . .  D ADDR   00C6H   A   
ADC0LTL . . . . . . . . . . . . . .  D ADDR   00C5H   A   
ADC0M0. . . . . . . . . . . . . . .  B ADDR   00E8H.0 A   
ADC0M1. . . . . . . . . . . . . . .  B ADDR   00E8H.1 A   
ADC0M2. . . . . . . . . . . . . . .  B ADDR   00E8H.2 A   
ADC0MX. . . . . . . . . . . . . . .  D ADDR   00BBH   A   
ADC0PWR . . . . . . . . . . . . . .  D ADDR   00DFH   A   
ADC0TK. . . . . . . . . . . . . . .  D ADDR   00B9H   A   
ADC_CONVERSION_CNT. . . . . . . . .  D ADDR   0070H   A   
ADC_IP. . . . . . . . . . . . . . .  N NUMB   0006H   A   
ADC_LIMIT_H . . . . . . . . . . . .  N NUMB   0000H   A   
ADC_LIMIT_L . . . . . . . . . . . .  N NUMB   0055H   A   
ADJUST_TIMING_TWO_STEPS . . . . . .  C ADDR   0B8DH   A   
ADJUST_TIMING_TWO_STEPS_FAST. . . .  C ADDR   0BF0H   A   
ANFET . . . . . . . . . . . . . . .  N NUMB   0001H   A   
APFET . . . . . . . . . . . . . . .  N NUMB   0000H   A   
ARBLOST0. . . . . . . . . . . . . .  B ADDR   00C0H.2 A   
ARMING_INITIAL_ARM_CHECK. . . . . .  C ADDR   12D6H   A   
ARMING_PPM_CHECK. . . . . . . . . .  C ADDR   12DFH   A   
ARMING_START. . . . . . . . . . . .  C ADDR   12C9H   A   
ARM_END_BEEP. . . . . . . . . . . .  C ADDR   13D3H   A   
ARM_TARGET_UPDATED. . . . . . . . .  C ADDR   13BEH   A   
AUTO_BAILOUT_ARMED. . . . . . . . .  D ADDR   0060H   A   
AVERAGE_THROTTLE. . . . . . . . . .  C ADDR   10F0H   A   
AVERAGE_THROTTLE_DIV. . . . . . . .  C ADDR   110FH   A   
AVERAGE_THROTTLE_MEAS . . . . . . .  C ADDR   1100H   A   
B . . . . . . . . . . . . . . . . .  D ADDR   00F0H   A   
BAUDH . . . . . . . . . . . . . . .  D ADDR   0025H   A   
BAUDL . . . . . . . . . . . . . . .  D ADDR   0024H   A   
BAUDTIME. . . . . . . . . . . . . .  N NUMB   FFE6H   A   
BEEP. . . . . . . . . . . . . . . .  C ADDR   0584H   A   
BEEP_ANFET_OFF. . . . . . . . . . .  C ADDR   05B7H   A   
BEEP_ANFET_ON . . . . . . . . . . .  C ADDR   05A7H   A   
BEEP_CNFET_OFF. . . . . . . . . . .  C ADDR   05BCH   A   
BEEP_CNFET_ON . . . . . . . . . . .  C ADDR   05ACH   A   
BEEP_DELAY_SET. . . . . . . . . . .  C ADDR   140EH   A   
BEEP_F1 . . . . . . . . . . . . . .  C ADDR   056CH   A   
BEEP_F2 . . . . . . . . . . . . . .  C ADDR   0572H   A   
BEEP_F3 . . . . . . . . . . . . . .  C ADDR   0578H   A   
BEEP_F4 . . . . . . . . . . . . . .  C ADDR   057EH   A   
BEEP_NO_ENTRY . . . . . . . . . . .  C ADDR   1803H   A   
BEEP_OFF. . . . . . . . . . . . . .  C ADDR   05C5H   A   
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   191

BEEP_ONOFF. . . . . . . . . . . . .  C ADDR   058CH   A   
BEEP_START. . . . . . . . . . . . .  C ADDR   058AH   A   
BEEP_STRENGTH . . . . . . . . . . .  D ADDR   0073H   A   
BESCNO. . . . . . . . . . . . . . .  N NUMB   00CDH   A   
BIT_ACCESS. . . . . . . . . . . . .  D ADDR   0020H   A   
BIT_ACCESS_INT. . . . . . . . . . .  D ADDR   0021H   A   
BIT_CNT . . . . . . . . . . . . . .  D ADDR   0026H   A   
BIT_REG . . . . . . . . . . . . . .  D ADDR   0020H   A   
BL_FLASH_KEY_1. . . . . . . . . . .  D ADDR   0029H   A   
BL_FLASH_KEY_2. . . . . . . . . . .  D ADDR   002AH   A   
BNFET . . . . . . . . . . . . . . .  N NUMB   0003H   A   
BOOTLOADER_DONE . . . . . . . . . .  C ADDR   11DFH   A   
BOOT_BAUDRATE . . . . . . . . . . .  N NUMB   4B00H   A   
BOOT_DELAY. . . . . . . . . . . . .  N NUMB   1E10H   A   
BOOT_INFO . . . . . . . . . . . . .  C ADDR   1DF2H   A   
BOOT_MSG. . . . . . . . . . . . . .  C ADDR   1DEEH   A   
BOOT_PAGES. . . . . . . . . . . . .  N NUMB   0001H   A   
BOOT_SIGN . . . . . . . . . . . . .  C ADDR   1DE8H   A   
BOOT_START. . . . . . . . . . . . .  N NUMB   1C00H   A   
BOOT_VERSION. . . . . . . . . . . .  N NUMB   0006H   A   
BPFET . . . . . . . . . . . . . . .  N NUMB   0002H   A   
BURSTEN . . . . . . . . . . . . . .  B ADDR   00E8H.6 A   
BYTE_CNTH . . . . . . . . . . . . .  D ADDR   0028H   A   
BYTE_CNTL . . . . . . . . . . . . .  D ADDR   0027H   A   
BYTE_REG. . . . . . . . . . . . . .  D ADDR   0021H   A   
CALC_GOVERNOR_INT_CORRECTION. . . .  C ADDR   07E6H   A   
CALC_GOVERNOR_INT_CORR_EXIT . . . .  C ADDR   083AH   A   
CALC_GOVERNOR_INT_ERROR . . . . . .  C ADDR   0733H   A   
CALC_GOVERNOR_INT_ERROR_EXIT. . . .  C ADDR   078BH   A   
CALC_GOVERNOR_PROP_CORRECTION . . .  C ADDR   078CH   A   
CALC_GOVERNOR_PROP_CORR_EXIT. . . .  C ADDR   07E5H   A   
CALC_GOVERNOR_PROP_ERROR. . . . . .  C ADDR   06FAH   A   
CALC_GOVERNOR_PROP_ERROR_EXIT . . .  C ADDR   0732H   A   
CALC_GOVERNOR_STORE_TARGET. . . . .  C ADDR   06F5H   A   
CALC_GOVERNOR_SUBTRACT_025. . . . .  C ADDR   06EDH   A   
CALC_GOVERNOR_TARGET. . . . . . . .  C ADDR   065EH   A   
CALC_GOVERNOR_TARGET_EXIT . . . . .  C ADDR   06F9H   A   
CALC_GOVERNOR_TARGET_LOW. . . . . .  C ADDR   06DAH   A   
CALC_GOVERNOR_TARGET_MIDDLE . . . .  C ADDR   06C2H   A   
CALC_NEW_WAIT_PER_DEMAG_DONE. . . .  C ADDR   0AD2H   A   
CALC_NEW_WAIT_PER_STARTUP_DONE. . .  C ADDR   0AB6H   A   
CALC_NEW_WAIT_TIMES . . . . . . . .  C ADDR   0B5CH   A   
CALC_NEW_WAIT_TIMES_EXIT. . . . . .  C ADDR   0AFEH   A   
CALC_NEW_WAIT_TIMES_FAST. . . . . .  C ADDR   0BD7H   A   
CALC_NEW_WAIT_TIMES_FAST_DONE . . .  C ADDR   0B48H   A   
CALC_NEW_WAIT_TIMES_SETUP . . . . .  C ADDR   0AA7H   A   
CALC_NEXT_COMM_AVG_PERIOD_DIV . . .  C ADDR   0A79H   A   
CALC_NEXT_COMM_NEW_PERIOD_DIV . . .  C ADDR   0A8CH   A   
CALC_NEXT_COMM_NEW_PERIOD_DIV_DONE.  C ADDR   0A95H   A   
CALC_NEXT_COMM_NORMAL . . . . . . .  C ADDR   0A5AH   A   
CALC_NEXT_COMM_STARTUP. . . . . . .  C ADDR   0A1CH   A   
CALC_NEXT_COMM_STARTUP_AVERAGE. . .  C ADDR   0A3FH   A   
CALC_NEXT_COMM_STARTUP_NO_X . . . .  C ADDR   0A2CH   A   
CALC_NEXT_COMM_TIMING . . . . . . .  C ADDR   09EFH   A   
CALC_NEXT_COMM_TIMING_FAST. . . . .  C ADDR   0B00H   A   
CCF0. . . . . . . . . . . . . . . .  B ADDR   00D8H.0 A   
CCF1. . . . . . . . . . . . . . . .  B ADDR   00D8H.1 A   
CCF2. . . . . . . . . . . . . . . .  B ADDR   00D8H.2 A   
CF. . . . . . . . . . . . . . . . .  B ADDR   00D8H.7 A   
CHECK_TEMP_VOLTAGE_AND_LIMIT_POWER.  C ADDR   0913H   A   
CHECK_VOLTAGE_EXIT. . . . . . . . .  C ADDR   09BBH   A   
CHECK_VOLTAGE_GOOD. . . . . . . . .  C ADDR   099AH   A   
CHECK_VOLTAGE_LIM . . . . . . . . .  C ADDR   09A1H   A   
CHECK_VOLTAGE_RET . . . . . . . . .  C ADDR   09C7H   A   
CHECK_VOLTAGE_SPOOLUP_LIM . . . . .  C ADDR   09ABH   A   
CHECK_VOLTAGE_START . . . . . . . .  C ADDR   0976H   A   
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   192

CKCON . . . . . . . . . . . . . . .  D ADDR   008EH   A   
CLEAR_RAM . . . . . . . . . . . . .  C ADDR   1195H   A   
CLKSEL. . . . . . . . . . . . . . .  D ADDR   00A9H   A   
CLOCK_SET_AT_48MHZ. . . . . . . . .  D ADDR   007AH   A   
CMDH. . . . . . . . . . . . . . . .    REG    R5          
CMDL. . . . . . . . . . . . . . . .    REG    R4          
CNFET . . . . . . . . . . . . . . .  N NUMB   0005H   A   
CNTH. . . . . . . . . . . . . . . .    REG    R7          
CNTL. . . . . . . . . . . . . . . .    REG    R6          
COMM12_NFET_DONE. . . . . . . . . .  C ADDR   0DB9H   A   
COMM12_NFET_DONE_REV. . . . . . . .  C ADDR   0DCEH   A   
COMM12_REV. . . . . . . . . . . . .  C ADDR   0DC0H   A   
COMM1COMM2. . . . . . . . . . . . .  C ADDR   0DA8H   A   
COMM23_DAMP_REV . . . . . . . . . .  C ADDR   0DFBH   A   
COMM23_FETS_DONE. . . . . . . . . .  C ADDR   0DF3H   A   
COMM23_FETS_DONE_REV. . . . . . . .  C ADDR   0E13H   A   
COMM23_NFET_DONE. . . . . . . . . .  C ADDR   0E2DH   A   
COMM23_NFET_DONE_REV. . . . . . . .  C ADDR   0E44H   A   
COMM23_NFET_OFF . . . . . . . . . .  C ADDR   0DF1H   A   
COMM23_NFET_OFF_REV . . . . . . . .  C ADDR   0E11H   A   
COMM23_NONDAMP. . . . . . . . . . .  C ADDR   0E1BH   A   
COMM23_NONDAMP_REV. . . . . . . . .  C ADDR   0E35H   A   
COMM2COMM3. . . . . . . . . . . . .  C ADDR   0DD5H   A   
COMM34_NFET_DONE. . . . . . . . . .  C ADDR   0E5DH   A   
COMM34_NFET_DONE_REV. . . . . . . .  C ADDR   0E72H   A   
COMM34_REV. . . . . . . . . . . . .  C ADDR   0E64H   A   
COMM3COMM4. . . . . . . . . . . . .  C ADDR   0E4CH   A   
COMM45_DAMP_REV . . . . . . . . . .  C ADDR   0E9FH   A   
COMM45_FETS_DONE. . . . . . . . . .  C ADDR   0E97H   A   
COMM45_FETS_DONE_REV. . . . . . . .  C ADDR   0EB7H   A   
COMM45_NFET_DONE. . . . . . . . . .  C ADDR   0ED1H   A   
COMM45_NFET_OFF . . . . . . . . . .  C ADDR   0E95H   A   
COMM45_NFET_OFF_REV . . . . . . . .  C ADDR   0EB5H   A   
COMM45_NONDAMP. . . . . . . . . . .  C ADDR   0EBFH   A   
COMM45_NONDAMP_REV. . . . . . . . .  C ADDR   0ED9H   A   
COMM4COMM5. . . . . . . . . . . . .  C ADDR   0E79H   A   
COMM56_NFET_DONE. . . . . . . . . .  C ADDR   0F01H   A   
COMM56_NFET_DONE_REV. . . . . . . .  C ADDR   0F16H   A   
COMM56_REV. . . . . . . . . . . . .  C ADDR   0F08H   A   
COMM5COMM6. . . . . . . . . . . . .  C ADDR   0EF0H   A   
COMM61_DAMP_REV . . . . . . . . . .  C ADDR   0F43H   A   
COMM61_FETS_DONE. . . . . . . . . .  C ADDR   0F3BH   A   
COMM61_FETS_DONE_REV. . . . . . . .  C ADDR   0F5BH   A   
COMM61_NFET_DONE. . . . . . . . . .  C ADDR   0F74H   A   
COMM61_NFET_DONE_REV. . . . . . . .  C ADDR   0F8AH   A   
COMM61_NFET_OFF . . . . . . . . . .  C ADDR   0F39H   A   
COMM61_NFET_OFF_REV . . . . . . . .  C ADDR   0F59H   A   
COMM61_NONDAMP. . . . . . . . . . .  C ADDR   0F62H   A   
COMM61_NONDAMP_REV. . . . . . . . .  C ADDR   0F7BH   A   
COMM6COMM1. . . . . . . . . . . . .  C ADDR   0F1DH   A   
COMM_EXIT . . . . . . . . . . . . .  C ADDR   0F8FH   A   
COMM_PERIOD4X_H . . . . . . . . . .  D ADDR   0041H   A   
COMM_PERIOD4X_L . . . . . . . . . .  D ADDR   0040H   A   
COMM_PHASE. . . . . . . . . . . . .  D ADDR   0042H   A   
COMM_TIME_MIN . . . . . . . . . . .  N NUMB   0001H   A   
COMP1_USED. . . . . . . . . . . . .  N NUMB   0000H   A   
COMPARATOR_READ_CNT . . . . . . . .  D ADDR   0043H   A   
COMP_CHECK_TIMEOUT. . . . . . . . .  C ADDR   0CA2H   A   
COMP_CHECK_TIMEOUT_EXTEND_TIMEOUT .  C ADDR   0CB3H   A   
COMP_CHECK_TIMEOUT_NOT_TIMED_OUT. .  C ADDR   0CB5H   A   
COMP_CHECK_TIMEOUT_TIMEOUT_EXTENDED  C ADDR   0CAFH   A   
COMP_COM. . . . . . . . . . . . . .  N NUMB   0000H   A   
COMP_READ_OK. . . . . . . . . . . .  C ADDR   0D0FH   A   
COMP_READ_OK_JMP. . . . . . . . . .  C ADDR   0D21H   A   
COMP_READ_WRONG . . . . . . . . . .  C ADDR   0CC0H   A   
COMP_READ_WRONG_EXTEND_TIMEOUT. . .  C ADDR   0CD9H   A   
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   193

COMP_READ_WRONG_LOAD_TIMEOUT. . . .  C ADDR   0D05H   A   
COMP_READ_WRONG_LOW_RPM . . . . . .  C ADDR   0CF8H   A   
COMP_READ_WRONG_NOT_STARTUP . . . .  C ADDR   0CCCH   A   
COMP_READ_WRONG_TIMEOUT_SET . . . .  C ADDR   0CECH   A   
COMP_SCALE_SAMPLES. . . . . . . . .  C ADDR   0CA2H   A   
COMP_TIMED_OUT. . . . . . . . . . .  N NUMB   0005H   A   
CPFET . . . . . . . . . . . . . . .  N NUMB   0004H   A   
CPT0CN. . . . . . . . . . . . . . .  D ADDR   009BH   A   
CPT0MD. . . . . . . . . . . . . . .  D ADDR   009DH   A   
CPT0MX. . . . . . . . . . . . . . .  D ADDR   009FH   A   
CPT1CN. . . . . . . . . . . . . . .  D ADDR   00BFH   A   
CPT1MD. . . . . . . . . . . . . . .  D ADDR   00ABH   A   
CPT1MX. . . . . . . . . . . . . . .  D ADDR   00AAH   A   
CR. . . . . . . . . . . . . . . . .  B ADDR   00D8H.6 A   
CRC0AUTO. . . . . . . . . . . . . .  D ADDR   00D2H   A   
CRC0CN. . . . . . . . . . . . . . .  D ADDR   00CEH   A   
CRC0CNT . . . . . . . . . . . . . .  D ADDR   00D3H   A   
CRC0DAT . . . . . . . . . . . . . .  D ADDR   00DEH   A   
CRC0FLIP. . . . . . . . . . . . . .  D ADDR   00CFH   A   
CRC0IN. . . . . . . . . . . . . . .  D ADDR   00DDH   A   
CRCH. . . . . . . . . . . . . . . .  D ADDR   0023H   A   
CRCL. . . . . . . . . . . . . . . .  D ADDR   0022H   A   
CURRENT_AVERAGE_TEMP. . . . . . . .  D ADDR   0071H   A   
CURRENT_PWM . . . . . . . . . . . .  D ADDR   0024H   A   
CURRENT_PWM_LIMITED . . . . . . . .  D ADDR   0025H   A   
CURRENT_PWM_LIM_DITH. . . . . . . .  D ADDR   0026H   A   
CURR_RCP_PWM_FREQ . . . . . . . . .  D ADDR   005EH   A   
CY. . . . . . . . . . . . . . . . .  B ADDR   00D0H.7 A   
DAMPED_MODE_ENABLE. . . . . . . . .  N NUMB   0001H   A   
DAMPINGFET. . . . . . . . . . . . .  D ADDR   007BH   A   
DEBUGPIN. . . . . . . . . . . . . .  N NUMB   0000H   A   
DEBUG_PAGE. . . . . . . . . . . . .  N NUMB   0001H   A   
DECODE_DEMAG_DONE . . . . . . . . .  C ADDR   10AAH   A   
DECODE_DEMAG_HIGH . . . . . . . . .  C ADDR   10A4H   A   
DECODE_MAIN_SPOOLUP_DONE. . . . . .  C ADDR   108BH   A   
DECODE_MAIN_SPOOLUP_NONZERO . . . .  C ADDR   1071H   A   
DECODE_PARAMETERS . . . . . . . . .  C ADDR   1013H   A   
DECODE_PARAMS_DIR_SET . . . . . . .  C ADDR   1028H   A   
DECODE_PWM_FREQ_END . . . . . . . .  C ADDR   1044H   A   
DECODE_PWM_FREQ_LOW . . . . . . . .  C ADDR   103FH   A   
DECODE_SETTINGS . . . . . . . . . .  C ADDR   1045H   A   
DEFAULT_PGM_BEC_VOLTAGE_HIGH. . . .  N NUMB   0000H   A   
DEFAULT_PGM_BRAKE_ON_STOP . . . . .  N NUMB   0000H   A   
DEFAULT_PGM_ENABLE_POWER_PROT . . .  N NUMB   0001H   A   
DEFAULT_PGM_ENABLE_PWM_INPUT. . . .  N NUMB   0000H   A   
DEFAULT_PGM_ENABLE_TEMP_PROT. . . .  N NUMB   0001H   A   
DEFAULT_PGM_ENABLE_TX_PROGRAM . . .  N NUMB   0001H   A   
DEFAULT_PGM_MAIN_BEACON_DELAY . . .  N NUMB   0004H   A   
DEFAULT_PGM_MAIN_BEACON_STRENGTH. .  N NUMB   00C8H   A   
DEFAULT_PGM_MAIN_BEEP_STRENGTH. . .  N NUMB   0078H   A   
DEFAULT_PGM_MAIN_COMM_TIMING. . . .  N NUMB   0003H   A   
DEFAULT_PGM_MAIN_DEMAG_COMP . . . .  N NUMB   0001H   A   
DEFAULT_PGM_MAIN_DIRECTION. . . . .  N NUMB   0001H   A   
DEFAULT_PGM_MAIN_GOVERNOR_MODE. . .  N NUMB   0001H   A   
DEFAULT_PGM_MAIN_GOVERNOR_RANGE . .  N NUMB   0001H   A   
DEFAULT_PGM_MAIN_GOV_SETUP_TARGET .  N NUMB   00B4H   A   
DEFAULT_PGM_MAIN_I_GAIN . . . . . .  N NUMB   0007H   A   
DEFAULT_PGM_MAIN_LOW_VOLTAGE_LIM. .  N NUMB   0004H   A   
DEFAULT_PGM_MAIN_PWM_FREQ . . . . .  N NUMB   0002H   A   
DEFAULT_PGM_MAIN_P_GAIN . . . . . .  N NUMB   0007H   A   
DEFAULT_PGM_MAIN_RCP_PWM_POL. . . .  N NUMB   0001H   A   
DEFAULT_PGM_MAIN_REARM_START. . . .  N NUMB   0000H   A   
DEFAULT_PGM_MAIN_SPOOLUP_TIME . . .  N NUMB   000AH   A   
DEFAULT_PGM_MAIN_STARTUP_PWR. . . .  N NUMB   0009H   A   
DEFAULT_PGM_MULTI_BEACON_DELAY. . .  N NUMB   0004H   A   
DEFAULT_PGM_MULTI_BEACON_STRENGTH .  N NUMB   0050H   A   
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   194

DEFAULT_PGM_MULTI_BEEP_STRENGTH . .  N NUMB   0028H   A   
DEFAULT_PGM_MULTI_COMM_TIMING . . .  N NUMB   0003H   A   
DEFAULT_PGM_MULTI_DEMAG_COMP. . . .  N NUMB   0002H   A   
DEFAULT_PGM_MULTI_DIRECTION . . . .  N NUMB   0001H   A   
DEFAULT_PGM_MULTI_GAIN. . . . . . .  N NUMB   0003H   A   
DEFAULT_PGM_MULTI_GOVERNOR_MODE . .  N NUMB   0004H   A   
DEFAULT_PGM_MULTI_I_GAIN. . . . . .  N NUMB   0009H   A   
DEFAULT_PGM_MULTI_PWM_DITHER. . . .  N NUMB   0003H   A   
DEFAULT_PGM_MULTI_PWM_FREQ. . . . .  N NUMB   0003H   A   
DEFAULT_PGM_MULTI_P_GAIN. . . . . .  N NUMB   0009H   A   
DEFAULT_PGM_MULTI_RCP_PWM_POL . . .  N NUMB   0001H   A   
DEFAULT_PGM_MULTI_STARTUP_PWR . . .  N NUMB   0009H   A   
DEFAULT_PGM_PPM_CENTER_THROTTLE . .  N NUMB   007AH   A   
DEFAULT_PGM_PPM_MAX_THROTTLE. . . .  N NUMB   00D0H   A   
DEFAULT_PGM_PPM_MIN_THROTTLE. . . .  N NUMB   0025H   A   
DEFAULT_PGM_TAIL_BEACON_DELAY . . .  N NUMB   0004H   A   
DEFAULT_PGM_TAIL_BEACON_STRENGTH. .  N NUMB   00FAH   A   
DEFAULT_PGM_TAIL_BEEP_STRENGTH. . .  N NUMB   00FAH   A   
DEFAULT_PGM_TAIL_COMM_TIMING. . . .  N NUMB   0003H   A   
DEFAULT_PGM_TAIL_DEMAG_COMP . . . .  N NUMB   0001H   A   
DEFAULT_PGM_TAIL_DIRECTION. . . . .  N NUMB   0001H   A   
DEFAULT_PGM_TAIL_GAIN . . . . . . .  N NUMB   0003H   A   
DEFAULT_PGM_TAIL_IDLE_SPEED . . . .  N NUMB   0004H   A   
DEFAULT_PGM_TAIL_PWM_DITHER . . . .  N NUMB   0003H   A   
DEFAULT_PGM_TAIL_PWM_FREQ . . . . .  N NUMB   0003H   A   
DEFAULT_PGM_TAIL_RCP_PWM_POL. . . .  N NUMB   0001H   A   
DEFAULT_PGM_TAIL_STARTUP_PWR. . . .  N NUMB   0009H   A   
DEMAG_CUT_POWER . . . . . . . . . .  N NUMB   0005H   A   
DEMAG_DETECTED. . . . . . . . . . .  N NUMB   0004H   A   
DEMAG_DETECTED_METRIC . . . . . . .  D ADDR   0037H   A   
DEMAG_PWR_OFF_THRESH. . . . . . . .  D ADDR   0038H   A   
DERIVID . . . . . . . . . . . . . .  D ADDR   00ADH   A   
DEVICEID. . . . . . . . . . . . . .  D ADDR   00B5H   A   
DIRECT_START_CHECK_RCP. . . . . . .  C ADDR   158AH   A   
DIR_CHANGE_BRAKE. . . . . . . . . .  N NUMB   0004H   A   
DIV_U16_BY_U16. . . . . . . . . . .  C ADDR   05CFH   A   
DIV_U16_BY_U16_DIV1 . . . . . . . .  C ADDR   05D7H   A   
DIV_U16_BY_U16_DIV2 . . . . . . . .  C ADDR   05E1H   A   
DIV_U16_BY_U16_DIV3 . . . . . . . .  C ADDR   05F8H   A   
DPH . . . . . . . . . . . . . . . .  D ADDR   0083H   A   
DPL . . . . . . . . . . . . . . . .  D ADDR   0082H   A   
EA. . . . . . . . . . . . . . . . .  B ADDR   00A8H.7 A   
EEPROM_FW_MAIN_REVISION . . . . . .  N NUMB   000EH   A   
EEPROM_FW_SUB_REVISION. . . . . . .  N NUMB   0009H   A   
EEPROM_LAYOUT_REVISION. . . . . . .  N NUMB   0015H   A   
EEP_DUMMY . . . . . . . . . . . . .  C ADDR   1A28H   A   
EEP_ENABLE_TX_PROGRAM . . . . . . .  C ADDR   1A0FH   A   
EEP_ESC_LAYOUT. . . . . . . . . . .  C ADDR   1A40H   A   
EEP_ESC_MCU . . . . . . . . . . . .  C ADDR   1A50H   A   
EEP_FW_MAIN_REVISION. . . . . . . .  C ADDR   1A00H   A   
EEP_FW_SUB_REVISION . . . . . . . .  C ADDR   1A01H   A   
EEP_INITIALIZED_H . . . . . . . . .  C ADDR   1A0EH   A   
EEP_INITIALIZED_L . . . . . . . . .  C ADDR   1A0DH   A   
EEP_LAYOUT_REVISION . . . . . . . .  C ADDR   1A02H   A   
EEP_MAIN_REARM_START. . . . . . . .  C ADDR   1A10H   A   
EEP_NAME. . . . . . . . . . . . . .  C ADDR   1A60H   A   
EEP_PGM_BEACON_DELAY. . . . . . . .  C ADDR   1A1DH   A   
EEP_PGM_BEACON_STRENGTH . . . . . .  C ADDR   1A1CH   A   
EEP_PGM_BEC_VOLTAGE_HIGH. . . . . .  C ADDR   1A20H   A   
EEP_PGM_BEEP_STRENGTH . . . . . . .  C ADDR   1A1BH   A   
EEP_PGM_BRAKE_ON_STOP . . . . . . .  C ADDR   1A27H   A   
EEP_PGM_COMM_TIMING . . . . . . . .  C ADDR   1A15H   A   
EEP_PGM_DEMAG_COMP. . . . . . . . .  C ADDR   1A1FH   A   
EEP_PGM_DIRECTION . . . . . . . . .  C ADDR   1A0BH   A   
EEP_PGM_ENABLE_POWER_PROT . . . . .  C ADDR   1A24H   A   
EEP_PGM_ENABLE_PWM_INPUT. . . . . .  C ADDR   1A25H   A   
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   195

EEP_PGM_GOV_I_GAIN. . . . . . . . .  C ADDR   1A04H   A   
EEP_PGM_GOV_MODE. . . . . . . . . .  C ADDR   1A05H   A   
EEP_PGM_GOV_P_GAIN. . . . . . . . .  C ADDR   1A03H   A   
EEP_PGM_GOV_RANGE . . . . . . . . .  C ADDR   1A17H   A   
EEP_PGM_GOV_SETUP_TARGET. . . . . .  C ADDR   1A11H   A   
EEP_PGM_INPUT_POL . . . . . . . . .  C ADDR   1A0CH   A   
EEP_PGM_LOW_VOLTAGE_LIM . . . . . .  C ADDR   1A06H   A   
EEP_PGM_MAIN_SPOOLUP_TIME . . . . .  C ADDR   1A22H   A   
EEP_PGM_PPM_MAX_THROTTLE. . . . . .  C ADDR   1A1AH   A   
EEP_PGM_PPM_MIN_THROTTLE. . . . . .  C ADDR   1A19H   A   
EEP_PGM_PWM_FREQ. . . . . . . . . .  C ADDR   1A0AH   A   
EEP_PGM_STARTUP_PWR . . . . . . . .  C ADDR   1A09H   A   
EEP_PGM_TEMP_PROT_ENABLE. . . . . .  C ADDR   1A23H   A   
EIE1. . . . . . . . . . . . . . . .  D ADDR   00E6H   A   
EIP1. . . . . . . . . . . . . . . .  D ADDR   00F3H   A   
ERASE_AND_STORE_ALL_IN_EEPROM . . .  C ADDR   1696H   A   
ERASE_FLASH . . . . . . . . . . . .  C ADDR   16EFH   A   
ERRORCOMMAND. . . . . . . . . . . .  N NUMB   00C1H   A   
ERRORCRC. . . . . . . . . . . . . .  N NUMB   00C2H   A   
ERRORPROG . . . . . . . . . . . . .  N NUMB   00C5H   A   
ERRORVERIFY . . . . . . . . . . . .  N NUMB   00C0H   A   
ES0 . . . . . . . . . . . . . . . .  B ADDR   00A8H.4 A   
ESPI0 . . . . . . . . . . . . . . .  B ADDR   00A8H.6 A   
ET0 . . . . . . . . . . . . . . . .  B ADDR   00A8H.1 A   
ET1 . . . . . . . . . . . . . . . .  B ADDR   00A8H.3 A   
ET2 . . . . . . . . . . . . . . . .  B ADDR   00A8H.5 A   
EVALUATE_COMPARATOR_INTEGRITY . . .  C ADDR   0D43H   A   
EVAL_COMP_CHECK_TIMEOUT . . . . . .  C ADDR   0D50H   A   
EVAL_COMP_EXIT. . . . . . . . . . .  C ADDR   0D60H   A   
EX0 . . . . . . . . . . . . . . . .  B ADDR   00A8H.0 A   
EX1 . . . . . . . . . . . . . . . .  B ADDR   00A8H.2 A   
EXIT. . . . . . . . . . . . . . . .  C ADDR   1CBAH   A   
F0. . . . . . . . . . . . . . . . .  B ADDR   00D0H.5 A   
F1. . . . . . . . . . . . . . . . .  B ADDR   00D0H.1 A   
FIND_THROTTLE_GAIN. . . . . . . . .  C ADDR   10B9H   A   
FIND_THROTTLE_GAIN_CALCULATE. . . .  C ADDR   10D3H   A   
FIND_THROTTLE_GAIN_CHECK_FULL . . .  C ADDR   10CCH   A   
FLAGS0. . . . . . . . . . . . . . .  D ADDR   002CH   A   
FLAGS1. . . . . . . . . . . . . . .  D ADDR   002DH   A   
FLAGS2. . . . . . . . . . . . . . .  D ADDR   002EH   A   
FLAGS3. . . . . . . . . . . . . . .  D ADDR   002FH   A   
FLASH_KEY_1 . . . . . . . . . . . .  D ADDR   007CH   A   
FLASH_KEY_2 . . . . . . . . . . . .  D ADDR   007DH   A   
FLKEY . . . . . . . . . . . . . . .  D ADDR   00B7H   A   
FLSCL . . . . . . . . . . . . . . .  D ADDR   009AH   A   
FLYCOLOR_FAIRY_30A_MAIN . . . . . .  N NUMB   00CDH   A   
FLYCOLOR_FAIRY_30A_MULTI. . . . . .  N NUMB   00CFH   A   
FLYCOLOR_FAIRY_30A_TAIL . . . . . .  N NUMB   00CEH   A   
FLYCOLOR_FAIRY_6A_MAIN. . . . . . .  N NUMB   00CAH   A   
FLYCOLOR_FAIRY_6A_MULTI . . . . . .  N NUMB   00CCH   A   
FLYCOLOR_FAIRY_6A_TAIL. . . . . . .  N NUMB   00CBH   A   
FLYCOLOR_FAIRY_V2_30A_MAIN. . . . .  N NUMB   00D0H   A   
FLYCOLOR_FAIRY_V2_30A_MULTI . . . .  N NUMB   00D2H   A   
FLYCOLOR_FAIRY_V2_30A_TAIL. . . . .  N NUMB   00D1H   A   
FULL_THROTTLE_RANGE . . . . . . . .  N NUMB   0007H   A   
FUNCTION_BEEP . . . . . . . . . . .  C ADDR   17DEH   A   
FUNCTION_NEXT . . . . . . . . . . .  C ADDR   185BH   A   
FUNCTION_PARAVAL_BEEP . . . . . . .  C ADDR   17D8H   A   
FUNC_PARAVAL. . . . . . . . . . . .  C ADDR   1806H   A   
FUNC_PARAVAL_CONT_WAIT. . . . . . .  C ADDR   1838H   A   
FUNC_PARAVAL_STORE. . . . . . . . .  C ADDR   1827H   A   
FUNC_PARAVAL_WAIT . . . . . . . . .  C ADDR   180BH   A   
GET1. . . . . . . . . . . . . . . .  C ADDR   1D96H   A   
GET2. . . . . . . . . . . . . . . .  C ADDR   1DABH   A   
GET3. . . . . . . . . . . . . . . .  C ADDR   1DCFH   A   
GETC. . . . . . . . . . . . . . . .  C ADDR   1D91H   A   
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   196

GETW. . . . . . . . . . . . . . . .  C ADDR   1D8DH   A   
GETX. . . . . . . . . . . . . . . .  C ADDR   1D9BH   A   
GOVERNOR_ACTIVATE . . . . . . . . .  C ADDR   06A8H   A   
GOVERNOR_ACT_LIM_SET. . . . . . . .  C ADDR   0684H   A   
GOVERNOR_APPLY_INT_CORR . . . . . .  C ADDR   0814H   A   
GOVERNOR_APPLY_PROP_CORR. . . . . .  C ADDR   07BFH   A   
GOVERNOR_CHECK_INT_CORR_LIMIT_POS .  C ADDR   07FFH   A   
GOVERNOR_CHECK_INT_LIMIT_POS. . . .  C ADDR   0753H   A   
GOVERNOR_CHECK_PROP_CORR_LIMIT_POS.  C ADDR   07AAH   A   
GOVERNOR_CHECK_PROP_LIMIT_POS . . .  C ADDR   0719H   A   
GOVERNOR_CHECK_PWM. . . . . . . . .  C ADDR   0769H   A   
GOVERNOR_CORR_INT_MAX_PWM . . . . .  C ADDR   0836H   A   
GOVERNOR_CORR_INT_MIN_PWM . . . . .  C ADDR   0827H   A   
GOVERNOR_CORR_NEG_INT . . . . . . .  C ADDR   082BH   A   
GOVERNOR_CORR_NEG_PROP. . . . . . .  C ADDR   07D6H   A   
GOVERNOR_CORR_PROP_MAX_PWM. . . . .  C ADDR   07E1H   A   
GOVERNOR_CORR_PROP_MIN_PWM. . . . .  C ADDR   07D2H   A   
GOVERNOR_DEACTIVATE . . . . . . . .  C ADDR   068AH   A   
GOVERNOR_FIRST_DEACTIVATE_DONE. . .  C ADDR   0696H   A   
GOVERNOR_INT_MAX_PWM. . . . . . . .  C ADDR   0779H   A   
GOVERNOR_INT_MIN_PWM. . . . . . . .  C ADDR   0780H   A   
GOVERNOR_LIMIT_INT_CORR_NEG . . . .  C ADDR   0810H   A   
GOVERNOR_LIMIT_INT_CORR_POS . . . .  C ADDR   080AH   A   
GOVERNOR_LIMIT_INT_ERROR_NEG. . . .  C ADDR   0763H   A   
GOVERNOR_LIMIT_INT_ERROR_POS. . . .  C ADDR   075BH   A   
GOVERNOR_LIMIT_PROP_CORR_NEG. . . .  C ADDR   07BBH   A   
GOVERNOR_LIMIT_PROP_CORR_POS. . . .  C ADDR   07B5H   A   
GOVERNOR_LIMIT_PROP_ERROR_NEG . . .  C ADDR   072AH   A   
GOVERNOR_LIMIT_PROP_ERROR_POS . . .  C ADDR   0724H   A   
GOVERNOR_REQ_PWM. . . . . . . . . .  D ADDR   0023H   A   
GOVERNOR_SPEED_CHECK. . . . . . . .  C ADDR   0665H   A   
GOVERNOR_STORE_INT_CORR . . . . . .  C ADDR   0838H   A   
GOVERNOR_STORE_INT_ERROR. . . . . .  C ADDR   0785H   A   
GOVERNOR_STORE_PROP_CORR. . . . . .  C ADDR   07E3H   A   
GOVERNOR_STORE_PROP_ERROR . . . . .  C ADDR   072EH   A   
GOVERNOR_TARGET_CALC. . . . . . . .  C ADDR   06AAH   A   
GOV_ACTIVE. . . . . . . . . . . . .  N NUMB   0006H   A   
GOV_ARM_TARGET. . . . . . . . . . .  D ADDR   004CH   A   
GOV_GAIN_TABLE. . . . . . . . . . .  C ADDR   0080H   A   
GOV_INTEGRAL_H. . . . . . . . . . .  D ADDR   0047H   A   
GOV_INTEGRAL_L. . . . . . . . . . .  D ADDR   0046H   A   
GOV_INTEGRAL_X. . . . . . . . . . .  D ADDR   0048H   A   
GOV_PROPORTIONAL_H. . . . . . . . .  D ADDR   004AH   A   
GOV_PROPORTIONAL_L. . . . . . . . .  D ADDR   0049H   A   
GOV_PROP_PWM. . . . . . . . . . . .  D ADDR   004BH   A   
GOV_SPOOLRATE . . . . . . . . . . .  N NUMB   0002H   A   
GOV_TARGET_H. . . . . . . . . . . .  D ADDR   0045H   A   
GOV_TARGET_L. . . . . . . . . . . .  D ADDR   0044H   A   
HIGH_BEC_VOLTAGE. . . . . . . . . .  N NUMB   0000H   A   
HIGH_RPM. . . . . . . . . . . . . .  N NUMB   0006H   A   
ID1 . . . . . . . . . . . . . . . .  C ADDR   1C4DH   A   
ID3 . . . . . . . . . . . . . . . .  C ADDR   1C58H   A   
ID4 . . . . . . . . . . . . . . . .  C ADDR   1C63H   A   
ID5 . . . . . . . . . . . . . . . .  C ADDR   1C70H   A   
IE. . . . . . . . . . . . . . . . .  D ADDR   00A8H   A   
IE0 . . . . . . . . . . . . . . . .  B ADDR   0088H.1 A   
IE1 . . . . . . . . . . . . . . . .  B ADDR   0088H.3 A   
IN1 . . . . . . . . . . . . . . . .  C ADDR   1C7AH   A   
INIT. . . . . . . . . . . . . . . .  C ADDR   1C00H   A   
INITIALIZED_H_DUMMY . . . . . . . .  I ADDR   008BH   A   
INITIALIZED_L_DUMMY . . . . . . . .  I ADDR   008AH   A   
INITIALIZE_TIMING . . . . . . . . .  C ADDR   09E8H   A   
INITIAL_ARM . . . . . . . . . . . .  D ADDR   0030H   A   
INITIAL_RUN_PHASE . . . . . . . . .  N NUMB   0002H   A   
INITIAL_RUN_PHASE_DONE. . . . . . .  C ADDR   15BDH   A   
INITIAL_RUN_ROT_CNTD. . . . . . . .  D ADDR   0035H   A   
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   197

INIT_NO_SIGNAL. . . . . . . . . . .  C ADDR   11C9H   A   
INIT_START. . . . . . . . . . . . .  C ADDR   1454H   A   
INIT_START_BIDIR_DONE . . . . . . .  C ADDR   14D8H   A   
INPUT_HIGH_CHECK_1. . . . . . . . .  C ADDR   11D3H   A   
INPUT_HIGH_CHECK_2. . . . . . . . .  C ADDR   11D5H   A   
IP. . . . . . . . . . . . . . . . .  D ADDR   00B8H   A   
IT0 . . . . . . . . . . . . . . . .  B ADDR   0088H.0 A   
IT01CF. . . . . . . . . . . . . . .  D ADDR   00E4H   A   
IT1 . . . . . . . . . . . . . . . .  B ADDR   0088H.2 A   
JMP_WAIT_FOR_POWER_ON . . . . . . .  C ADDR   164DH   A   
LIPO_ADC_LIMIT_H. . . . . . . . . .  D ADDR   006FH   A   
LIPO_ADC_LIMIT_L. . . . . . . . . .  D ADDR   006EH   A   
LOAD_MIN_TIME . . . . . . . . . . .  C ADDR   0AFAH   A   
LOAD_MIN_TIME_FAST. . . . . . . . .  C ADDR   0B46H   A   
LOCK_BYTE_ADDRESS_16K . . . . . . .  N NUMB   3FFFH   A   
LOCK_BYTE_ADDRESS_8K. . . . . . . .  N NUMB   1FFFH   A   
LOCK_BYTE_OK. . . . . . . . . . . .  C ADDR   1143H   A   
LOCK_BYTE_TEST. . . . . . . . . . .  C ADDR   113CH   A   
LOW_RPM_PWR_SLOPE . . . . . . . . .  D ADDR   0039H   A   
MAI1. . . . . . . . . . . . . . . .  C ADDR   1C84H   A   
MAI2. . . . . . . . . . . . . . . .  C ADDR   1CA6H   A   
MAI4. . . . . . . . . . . . . . . .  C ADDR   1CE0H   A   
MAI5. . . . . . . . . . . . . . . .  C ADDR   1D37H   A   
MAI6. . . . . . . . . . . . . . . .  C ADDR   1D48H   A   
MAIN. . . . . . . . . . . . . . . .  C ADDR   1C82H   A   
MAIN_SPOOLUP_TIME_10X . . . . . . .  D ADDR   006CH   A   
MAIN_SPOOLUP_TIME_15X . . . . . . .  D ADDR   006DH   A   
MAIN_SPOOLUP_TIME_3X. . . . . . . .  D ADDR   006BH   A   
MASTER0 . . . . . . . . . . . . . .  B ADDR   00C0H.7 A   
MCE0. . . . . . . . . . . . . . . .  B ADDR   0098H.5 A   
MCU_48MHZ . . . . . . . . . . . . .  N NUMB   0000H   A   
MEASURE_LIPO_ADD_LOOP . . . . . . .  C ADDR   0902H   A   
MEASURE_LIPO_ADJUST . . . . . . . .  C ADDR   08D2H   A   
MEASURE_LIPO_CELLS. . . . . . . . .  C ADDR   0881H   A   
MEASURE_LIPO_CELL_LOOP. . . . . . .  C ADDR   08B7H   A   
MEASURE_LIPO_DIVIDE_LOOP. . . . . .  C ADDR   08E8H   A   
MEASURE_LIPO_EXIT . . . . . . . . .  C ADDR   090EH   A   
MEASURE_LIPO_LIMIT_ON . . . . . . .  C ADDR   08FEH   A   
MEASURE_LIPO_UPDATE . . . . . . . .  C ADDR   090AH   A   
MEASURE_LIPO_WAIT_ADC . . . . . . .  C ADDR   0891H   A   
MEASURE_PWM_FREQ_INIT . . . . . . .  C ADDR   123FH   A   
MEASURE_PWM_FREQ_LOOP . . . . . . .  C ADDR   1245H   A   
MEASURE_PWM_FREQ_START. . . . . . .  C ADDR   1243H   A   
MEASURE_PWM_FREQ_WAIT . . . . . . .  C ADDR   1250H   A   
MODE. . . . . . . . . . . . . . . .  N NUMB   0000H   A   
MODF. . . . . . . . . . . . . . . .  B ADDR   00F8H.5 A   
MOTOR_SPINNING. . . . . . . . . . .  N NUMB   0000H   A   
MOTOR_STARTED . . . . . . . . . . .  N NUMB   0003H   A   
MULT_S16_BY_U8_DIV_16 . . . . . . .  C ADDR   0607H   A   
MULT_S16_BY_U8_DIV_LOOP . . . . . .  C ADDR   063AH   A   
MULT_S16_BY_U8_EXIT . . . . . . . .  C ADDR   0655H   A   
MULT_S16_BY_U8_POSITIVE . . . . . .  C ADDR   0621H   A   
MUX_A . . . . . . . . . . . . . . .  N NUMB   0001H   A   
MUX_B . . . . . . . . . . . . . . .  N NUMB   0002H   A   
MUX_C . . . . . . . . . . . . . . .  N NUMB   0003H   A   
NEW_RCP . . . . . . . . . . . . . .  D ADDR   005CH   A   
NFETON_DELAY. . . . . . . . . . . .  N NUMB   0006H   A   
NORMAL_RUN_CHECKS . . . . . . . . .  C ADDR   1596H   A   
NORMAL_RUN_CHECK_STARTUP_ROT. . . .  C ADDR   15A7H   A   
NSSMD0. . . . . . . . . . . . . . .  B ADDR   00F8H.2 A   
NSSMD1. . . . . . . . . . . . . . .  B ADDR   00F8H.3 A   
ONE_S_CAPABLE . . . . . . . . . . .  N NUMB   0000H   A   
OSCICL. . . . . . . . . . . . . . .  D ADDR   00C7H   A   
OSCLCN. . . . . . . . . . . . . . .  D ADDR   00B1H   A   
OV. . . . . . . . . . . . . . . . .  B ADDR   00D0H.2 A   
P . . . . . . . . . . . . . . . . .  B ADDR   00D0H.0 A   
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   198

P0. . . . . . . . . . . . . . . . .  D ADDR   0080H   A   
P0MASK. . . . . . . . . . . . . . .  D ADDR   00FEH   A   
P0MAT . . . . . . . . . . . . . . .  D ADDR   00FDH   A   
P0MDIN. . . . . . . . . . . . . . .  D ADDR   00F1H   A   
P0MDOUT . . . . . . . . . . . . . .  D ADDR   00A4H   A   
P0SKIP. . . . . . . . . . . . . . .  D ADDR   00D4H   A   
P0_DIGITAL. . . . . . . . . . . . .  N NUMB   FFB0H   A   
P0_INIT . . . . . . . . . . . . . .  N NUMB   00FFH   A   
P0_PUSHPULL . . . . . . . . . . . .  N NUMB   0000H   A   
P0_SKIP . . . . . . . . . . . . . .  N NUMB   00DFH   A   
P1. . . . . . . . . . . . . . . . .  D ADDR   0090H   A   
P1MASK. . . . . . . . . . . . . . .  D ADDR   00EEH   A   
P1MAT . . . . . . . . . . . . . . .  D ADDR   00EDH   A   
P1MDIN. . . . . . . . . . . . . . .  D ADDR   00F2H   A   
P1MDOUT . . . . . . . . . . . . . .  D ADDR   00A5H   A   
P1SKIP. . . . . . . . . . . . . . .  D ADDR   00D5H   A   
P1_DIGITAL. . . . . . . . . . . . .  N NUMB   003FH   A   
P1_INIT . . . . . . . . . . . . . .  N NUMB   0015H   A   
P1_PUSHPULL . . . . . . . . . . . .  N NUMB   003FH   A   
P1_SKIP . . . . . . . . . . . . . .  N NUMB   0000H   A   
P2. . . . . . . . . . . . . . . . .  D ADDR   00A0H   A   
P2MDOUT . . . . . . . . . . . . . .  D ADDR   00A6H   A   
P2_PUSHPULL . . . . . . . . . . . .  N NUMB   0001H   A   
PARAH . . . . . . . . . . . . . . .    REG    R3          
PARAL . . . . . . . . . . . . . . .    REG    R2          
PARAVAL_BEEP. . . . . . . . . . . .  C ADDR   17ECH   A   
PARAVAL_NEXT. . . . . . . . . . . .  C ADDR   1845H   A   
PARAVAL_NO_ENTRY. . . . . . . . . .  C ADDR   1800H   A   
PCA0CENT. . . . . . . . . . . . . .  D ADDR   009EH   A   
PCA0CLR . . . . . . . . . . . . . .  D ADDR   009CH   A   
PCA0CN. . . . . . . . . . . . . . .  D ADDR   00D8H   A   
PCA0CPH0. . . . . . . . . . . . . .  D ADDR   00FCH   A   
PCA0CPH1. . . . . . . . . . . . . .  D ADDR   00EAH   A   
PCA0CPH2. . . . . . . . . . . . . .  D ADDR   00ECH   A   
PCA0CPL0. . . . . . . . . . . . . .  D ADDR   00FBH   A   
PCA0CPL1. . . . . . . . . . . . . .  D ADDR   00E9H   A   
PCA0CPL2. . . . . . . . . . . . . .  D ADDR   00EBH   A   
PCA0CPM0. . . . . . . . . . . . . .  D ADDR   00DAH   A   
PCA0CPM1. . . . . . . . . . . . . .  D ADDR   00DBH   A   
PCA0CPM2. . . . . . . . . . . . . .  D ADDR   00DCH   A   
PCA0H . . . . . . . . . . . . . . .  D ADDR   00FAH   A   
PCA0L . . . . . . . . . . . . . . .  D ADDR   00F9H   A   
PCA0MD. . . . . . . . . . . . . . .  D ADDR   00D9H   A   
PCA0POL . . . . . . . . . . . . . .  D ADDR   0096H   A   
PCA0PWM . . . . . . . . . . . . . .  D ADDR   00F7H   A   
PCA_INT . . . . . . . . . . . . . .  C ADDR   02EDH   A   
PCA_INT_CHECK_12KHZ . . . . . . . .  C ADDR   039EH   A   
PCA_INT_CHECK_1KHZ. . . . . . . . .  C ADDR   03EBH   A   
PCA_INT_CHECK_2KHZ. . . . . . . . .  C ADDR   03DAH   A   
PCA_INT_CHECK_4KHZ. . . . . . . . .  C ADDR   03C9H   A   
PCA_INT_CHECK_8KHZ. . . . . . . . .  C ADDR   03B8H   A   
PCA_INT_CHECK_DIFF. . . . . . . . .  C ADDR   0412H   A   
PCA_INT_CHECK_LEGAL_RANGE . . . . .  C ADDR   0500H   A   
PCA_INT_EXIT. . . . . . . . . . . .  C ADDR   0537H   A   
PCA_INT_FAIL_MINIMUM. . . . . . . .  C ADDR   032BH   A   
PCA_INT_FALL. . . . . . . . . . . .  C ADDR   042DH   A   
PCA_INT_FALL_CHECK_RANGE. . . . . .  C ADDR   046FH   A   
PCA_INT_FALL_NOT_ONESHOT. . . . . .  C ADDR   0450H   A   
PCA_INT_LIMITED . . . . . . . . . .  C ADDR   050BH   A   
PCA_INT_PPM_BELOW_FULL_RANGE. . . .  C ADDR   047DH   A   
PCA_INT_PPM_CALCULATE . . . . . . .  C ADDR   04ACH   A   
PCA_INT_PPM_CHECK_FULL_RANGE. . . .  C ADDR   049EH   A   
PCA_INT_PPM_LIMIT_AFTER_MULT. . . .  C ADDR   04E2H   A   
PCA_INT_PPM_MAX_CHECKED . . . . . .  C ADDR   04D1H   A   
PCA_INT_PPM_NEG_CHECKED . . . . . .  C ADDR   04C2H   A   
PCA_INT_PPM_OUTSIDE_RANGE . . . . .  C ADDR   0486H   A   
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   199

PCA_INT_PPM_TIMEOUT_SET . . . . . .  C ADDR   052CH   A   
PCA_INT_PWM_DIVIDE. . . . . . . . .  C ADDR   04E8H   A   
PCA_INT_PWM_DIVIDE_DONE . . . . . .  C ADDR   04EFH   A   
PCA_INT_RESTORE_EDGE. . . . . . . .  C ADDR   03FCH   A   
PCA_INT_RESTORE_EDGE_SET_MSB. . . .  C ADDR   03FAH   A   
PCA_INT_SECOND_MEAS_PWM_FREQ. . . .  C ADDR   0354H   A   
PCA_INT_SET_TIMEOUT . . . . . . . .  C ADDR   0523H   A   
PCA_INT_STORE_DATA. . . . . . . . .  C ADDR   041FH   A   
PCON. . . . . . . . . . . . . . . .  D ADDR   0087H   A   
PFETON_DELAY. . . . . . . . . . . .  N NUMB   0001H   A   
PGM_BEACON_DELAY. . . . . . . . . .  I ADDR   009AH   A   
PGM_BEACON_STRENGTH . . . . . . . .  I ADDR   0099H   A   
PGM_BEC_VOLTAGE_HIGH. . . . . . . .  I ADDR   009DH   A   
PGM_BEEP_STRENGTH . . . . . . . . .  I ADDR   0098H   A   
PGM_BRAKE_ON_STOP . . . . . . . . .  I ADDR   00A4H   A   
PGM_COMM_TIMING . . . . . . . . . .  I ADDR   0092H   A   
PGM_DEMAG_COMP. . . . . . . . . . .  I ADDR   009CH   A   
PGM_DIRECTION . . . . . . . . . . .  I ADDR   0088H   A   
PGM_DIR_REV . . . . . . . . . . . .  N NUMB   0005H   A   
PGM_ENABLE_POWER_PROT . . . . . . .  I ADDR   00A1H   A   
PGM_ENABLE_PWM_INPUT. . . . . . . .  I ADDR   00A2H   A   
PGM_ENABLE_TEMP_PROT. . . . . . . .  I ADDR   00A0H   A   
PGM_ENABLE_TX_PROGRAM . . . . . . .  I ADDR   008CH   A   
PGM_GOV_I_GAIN. . . . . . . . . . .  I ADDR   0081H   A   
PGM_GOV_I_GAIN_DECODED. . . . . . .  I ADDR   00A6H   A   
PGM_GOV_MODE. . . . . . . . . . . .  I ADDR   0082H   A   
PGM_GOV_P_GAIN. . . . . . . . . . .  I ADDR   0080H   A   
PGM_GOV_P_GAIN_DECODED. . . . . . .  I ADDR   00A5H   A   
PGM_GOV_RANGE . . . . . . . . . . .  I ADDR   0094H   A   
PGM_GOV_SETUP_TARGET. . . . . . . .  I ADDR   008EH   A   
PGM_INPUT_POL . . . . . . . . . . .  I ADDR   0089H   A   
PGM_LOW_VOLTAGE_LIM . . . . . . . .  I ADDR   0083H   A   
PGM_MAIN_REARM_START. . . . . . . .  I ADDR   008DH   A   
PGM_MAIN_SPOOLUP_TIME . . . . . . .  I ADDR   009FH   A   
PGM_MOTOR_GAIN. . . . . . . . . . .  I ADDR   0084H   A   
PGM_MOTOR_IDLE. . . . . . . . . . .  I ADDR   0085H   A   
PGM_PPM_CENTER_THROTTLE . . . . . .  I ADDR   009EH   A   
PGM_PPM_MAX_THROTTLE. . . . . . . .  I ADDR   0097H   A   
PGM_PPM_MIN_THROTTLE. . . . . . . .  I ADDR   0096H   A   
PGM_PWMOFF_DAMPED . . . . . . . . .  N NUMB   0002H   A   
PGM_PWM_DITHER. . . . . . . . . . .  I ADDR   00A3H   A   
PGM_PWM_FREQ. . . . . . . . . . . .  I ADDR   0087H   A   
PGM_PWM_HIGH_FREQ . . . . . . . . .  N NUMB   0003H   A   
PGM_RCP_PWM_POL . . . . . . . . . .  N NUMB   0006H   A   
PGM_START . . . . . . . . . . . . .  C ADDR   111EH   A   
PGM_STARTUP_PWR . . . . . . . . . .  I ADDR   0086H   A   
PGM_STARTUP_PWR_DECODED . . . . . .  I ADDR   00A7H   A   
POLYNOM . . . . . . . . . . . . . .  N NUMB   A001H   A   
PORT3_EXIST . . . . . . . . . . . .  N NUMB   0000H   A   
POWER_ON_WAIT_CNT_H . . . . . . . .  D ADDR   0032H   A   
POWER_ON_WAIT_CNT_L . . . . . . . .  D ADDR   0031H   A   
PPM_THROTTLE_GAIN . . . . . . . . .  D ADDR   0072H   A   
PREV_COMM_H . . . . . . . . . . . .  D ADDR   003CH   A   
PREV_COMM_L . . . . . . . . . . . .  D ADDR   003BH   A   
PREV_COMM_X . . . . . . . . . . . .  D ADDR   003DH   A   
PREV_PREV_COMM_H. . . . . . . . . .  D ADDR   003FH   A   
PREV_PREV_COMM_L. . . . . . . . . .  D ADDR   003EH   A   
PREV_RCP_PWM_FREQ . . . . . . . . .  D ADDR   005DH   A   
PRO3. . . . . . . . . . . . . . . .  C ADDR   1D0BH   A   
PRO4. . . . . . . . . . . . . . . .  C ADDR   1D17H   A   
PRO5. . . . . . . . . . . . . . . .  C ADDR   1D1DH   A   
PRO6. . . . . . . . . . . . . . . .  C ADDR   1D32H   A   
PROGRAM_BY_TX . . . . . . . . . . .  C ADDR   17F7H   A   
PROGRAM_BY_TX_CHECKED . . . . . . .  C ADDR   13AEH   A   
PROGRAM_BY_TX_ENTRY_LIMIT . . . . .  C ADDR   1391H   A   
PROGRAM_BY_TX_ENTRY_PWM . . . . . .  C ADDR   12F1H   A   
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   200

PROGRAM_BY_TX_ENTRY_STORE . . . . .  C ADDR   1397H   A   
PROGRAM_BY_TX_ENTRY_WAIT_PPM. . . .  C ADDR   139EH   A   
PROGRAM_BY_TX_ENTRY_WAIT_PWM. . . .  C ADDR   1302H   A   
PROGRAM_BY_TX_EXIT. . . . . . . . .  C ADDR   186CH   A   
PRTDRV. . . . . . . . . . . . . . .  D ADDR   00F6H   A   
PS0 . . . . . . . . . . . . . . . .  B ADDR   00B8H.4 A   
PSCTL . . . . . . . . . . . . . . .  D ADDR   008FH   A   
PSPI0 . . . . . . . . . . . . . . .  B ADDR   00B8H.6 A   
PSW . . . . . . . . . . . . . . . .  D ADDR   00D0H   A   
PT0 . . . . . . . . . . . . . . . .  B ADDR   00B8H.1 A   
PT1 . . . . . . . . . . . . . . . .  B ADDR   00B8H.3 A   
PT2 . . . . . . . . . . . . . . . .  B ADDR   00B8H.5 A   
PUT1. . . . . . . . . . . . . . . .  C ADDR   1D58H   A   
PUT2. . . . . . . . . . . . . . . .  C ADDR   1D6BH   A   
PUT3. . . . . . . . . . . . . . . .  C ADDR   1D77H   A   
PUT4. . . . . . . . . . . . . . . .  C ADDR   1D89H   A   
PUTC. . . . . . . . . . . . . . . .  C ADDR   1D6EH   A   
PUTP. . . . . . . . . . . . . . . .  C ADDR   1D52H   A   
PUTW. . . . . . . . . . . . . . . .  C ADDR   1D4AH   A   
PWM_AFET. . . . . . . . . . . . . .  C ADDR   010CH   A   
PWM_AFET_DAMPED . . . . . . . . . .  C ADDR   012AH   A   
PWM_AFET_DAMPED_DONE. . . . . . . .  C ADDR   0137H   A   
PWM_AFET_DAMPED_EXIT. . . . . . . .  C ADDR   0139H   A   
PWM_AFET_EXIT . . . . . . . . . . .  C ADDR   0114H   A   
PWM_BFET. . . . . . . . . . . . . .  C ADDR   0116H   A   
PWM_BFET_DAMPED . . . . . . . . . .  C ADDR   013BH   A   
PWM_BFET_DAMPED_DONE. . . . . . . .  C ADDR   0148H   A   
PWM_BFET_DAMPED_EXIT. . . . . . . .  C ADDR   014AH   A   
PWM_BFET_EXIT . . . . . . . . . . .  C ADDR   011EH   A   
PWM_CFET. . . . . . . . . . . . . .  C ADDR   0120H   A   
PWM_CFET_DAMPED . . . . . . . . . .  C ADDR   014CH   A   
PWM_CFET_DAMPED_DONE. . . . . . . .  C ADDR   0159H   A   
PWM_CFET_DAMPED_EXIT. . . . . . . .  C ADDR   015BH   A   
PWM_CFET_EXIT . . . . . . . . . . .  C ADDR   0128H   A   
PWM_DITHER_DECODED. . . . . . . . .  D ADDR   0066H   A   
PWM_DITHER_EXCESS_POWER . . . . . .  D ADDR   0067H   A   
PWM_DITHER_TABLE. . . . . . . . . .  C ADDR   009AH   A   
PWM_LIMIT . . . . . . . . . . . . .  D ADDR   0061H   A   
PWM_LIMIT_BY_RPM. . . . . . . . . .  D ADDR   0063H   A   
PWM_LIMIT_SPOOLUP . . . . . . . . .  D ADDR   0062H   A   
PWM_MOTOR_IDLE. . . . . . . . . . .  D ADDR   0065H   A   
PWM_NOFET . . . . . . . . . . . . .  C ADDR   010AH   A   
PWM_ON. . . . . . . . . . . . . . .  N NUMB   0002H   A   
PWM_SPOOLUP_BEG . . . . . . . . . .  D ADDR   0064H   A   
PWM_START . . . . . . . . . . . . .  N NUMB   0032H   A   
PWM_TIMER0_OVERFLOW . . . . . . . .  N NUMB   0003H   A   
PX0 . . . . . . . . . . . . . . . .  B ADDR   00B8H.0 A   
PX1 . . . . . . . . . . . . . . . .  B ADDR   00B8H.2 A   
RANDOM. . . . . . . . . . . . . . .  D ADDR   0068H   A   
RB80. . . . . . . . . . . . . . . .  B ADDR   0098H.2 A   
RCP_DIR_REV . . . . . . . . . . . .  N NUMB   0006H   A   
RCP_EDGE_H. . . . . . . . . . . . .  D ADDR   0058H   A   
RCP_EDGE_L. . . . . . . . . . . . .  D ADDR   0057H   A   
RCP_EDGE_NO . . . . . . . . . . . .  N NUMB   0001H   A   
RCP_IN. . . . . . . . . . . . . . .  N NUMB   0005H   A   
RCP_MAX . . . . . . . . . . . . . .  N NUMB   00FFH   A   
RCP_MEAS_PWM_FREQ . . . . . . . . .  N NUMB   0001H   A   
RCP_MIN . . . . . . . . . . . . . .  N NUMB   0000H   A   
RCP_OUTSIDE_RANGE_CNT . . . . . . .  D ADDR   0029H   A   
RCP_PERIOD_DIFF_ACCEPTED. . . . . .  D ADDR   005BH   A   
RCP_PPM . . . . . . . . . . . . . .  N NUMB   0004H   A   
RCP_PPM_ONESHOT125. . . . . . . . .  N NUMB   0005H   A   
RCP_PREPREV_EDGE_H. . . . . . . . .  D ADDR   0056H   A   
RCP_PREPREV_EDGE_L. . . . . . . . .  D ADDR   0055H   A   
RCP_PREV_EDGE_H . . . . . . . . . .  D ADDR   0028H   A   
RCP_PREV_EDGE_L . . . . . . . . . .  D ADDR   0027H   A   
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   201

RCP_PREV_PERIOD_H . . . . . . . . .  D ADDR   005AH   A   
RCP_PREV_PERIOD_L . . . . . . . . .  D ADDR   0059H   A   
RCP_PWM_FREQ_12KHZ. . . . . . . . .  N NUMB   0004H   A   
RCP_PWM_FREQ_1KHZ . . . . . . . . .  N NUMB   0000H   A   
RCP_PWM_FREQ_2KHZ . . . . . . . . .  N NUMB   0001H   A   
RCP_PWM_FREQ_4KHZ . . . . . . . . .  N NUMB   0002H   A   
RCP_PWM_FREQ_8KHZ . . . . . . . . .  N NUMB   0003H   A   
RCP_SKIP_CNTD . . . . . . . . . . .  D ADDR   002BH   A   
RCP_SKIP_RATE . . . . . . . . . . .  N NUMB   0020H   A   
RCP_STOP. . . . . . . . . . . . . .  N NUMB   0001H   A   
RCP_STOP_CNT. . . . . . . . . . . .  D ADDR   005FH   A   
RCP_STOP_LIMIT. . . . . . . . . . .  N NUMB   00FAH   A   
RCP_TIMEOUT . . . . . . . . . . . .  N NUMB   0040H   A   
RCP_TIMEOUT_CNTD. . . . . . . . . .  D ADDR   002AH   A   
RCP_TIMEOUT_PPM . . . . . . . . . .  N NUMB   000AH   A   
RCP_UPDATED . . . . . . . . . . . .  N NUMB   0000H   A   
RCP_VALIDATE. . . . . . . . . . . .  N NUMB   0002H   A   
RD1 . . . . . . . . . . . . . . . .  C ADDR   1D3CH   A   
READ_ALL_EEPROM_PARAMETERS. . . . .  C ADDR   164FH   A   
READ_EEPROM_BLOCK1. . . . . . . . .  C ADDR   167FH   A   
READ_EEPROM_BLOCK2. . . . . . . . .  C ADDR   168CH   A   
READ_EEPROM_BYTE. . . . . . . . . .  C ADDR   16CFH   A   
READ_EEPROM_EXIT. . . . . . . . . .  C ADDR   1695H   A   
READ_EEPROM_READ. . . . . . . . . .  C ADDR   1678H   A   
READ_EEPROM_STORE_DEFAULTS. . . . .  C ADDR   1665H   A   
READ_INITIAL_TEMP . . . . . . . . .  C ADDR   148EH   A   
READ_TAG. . . . . . . . . . . . . .  C ADDR   171BH   A   
READ_TAGS . . . . . . . . . . . . .  C ADDR   1712H   A   
REF0CN. . . . . . . . . . . . . . .  D ADDR   00D1H   A   
REG0CN. . . . . . . . . . . . . . .  D ADDR   00C9H   A   
REN0. . . . . . . . . . . . . . . .  B ADDR   0098H.4 A   
REQUESTED_PWM . . . . . . . . . . .  D ADDR   0022H   A   
RESET . . . . . . . . . . . . . . .  C ADDR   19FDH   A   
RESET_CAL_DONE. . . . . . . . . . .  C ADDR   116CH   A   
REVID . . . . . . . . . . . . . . .  D ADDR   00B6H   A   
RI0 . . . . . . . . . . . . . . . .  B ADDR   0098H.0 A   
RS0 . . . . . . . . . . . . . . . .  B ADDR   00D0H.3 A   
RS1 . . . . . . . . . . . . . . . .  B ADDR   00D0H.4 A   
RST . . . . . . . . . . . . . . . .  C ADDR   1CC9H   A   
RSTSRC. . . . . . . . . . . . . . .  D ADDR   00EFH   A   
RTX_MDIN. . . . . . . . . . . . . .  D ADDR   00F1H   A   
RTX_MDOUT . . . . . . . . . . . . .  D ADDR   00A4H   A   
RTX_PIN . . . . . . . . . . . . . .  N NUMB   0005H   A   
RTX_PORT. . . . . . . . . . . . . .  D ADDR   0080H   A   
RTX_SKIP. . . . . . . . . . . . . .  D ADDR   00D4H   A   
RUN1. . . . . . . . . . . . . . . .  C ADDR   14F4H   A   
RUN2. . . . . . . . . . . . . . . .  C ADDR   1503H   A   
RUN3. . . . . . . . . . . . . . . .  C ADDR   1521H   A   
RUN4. . . . . . . . . . . . . . . .  C ADDR   1533H   A   
RUN5. . . . . . . . . . . . . . . .  C ADDR   1545H   A   
RUN6. . . . . . . . . . . . . . . .  C ADDR   1557H   A   
RUN6_BRAKE_DONE . . . . . . . . . .  C ADDR   15F0H   A   
RUN6_CHECK_DIR. . . . . . . . . . .  C ADDR   15E6H   A   
RUN6_CHECK_RCP_STOP_COUNT . . . . .  C ADDR   15D0H   A   
RUN_TO_NEXT_STATE_MAIN. . . . . . .  C ADDR   1643H   A   
RUN_TO_WAIT_FOR_POWER_ON. . . . . .  C ADDR   1600H   A   
RUN_TO_WAIT_FOR_POWER_ON_BRAKE_DONE  C ADDR   163AH   A   
RUN_TO_WAIT_FOR_POWER_ON_FAIL . . .  C ADDR   15F8H   A   
RUN_TO_WAIT_FOR_POWER_ON_STALL_DONE  C ADDR   1603H   A   
RXOVRN. . . . . . . . . . . . . . .  B ADDR   00F8H.4 A   
S0MODE. . . . . . . . . . . . . . .  B ADDR   0098H.7 A   
SBUF0 . . . . . . . . . . . . . . .  D ADDR   0099H   A   
SCON0 . . . . . . . . . . . . . . .  D ADDR   0098H   A   
SET4. . . . . . . . . . . . . . . .  C ADDR   1CD1H   A   
SET5. . . . . . . . . . . . . . . .  C ADDR   1CD7H   A   
SET6. . . . . . . . . . . . . . . .  C ADDR   1CDDH   A   
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   202

SETBUF. . . . . . . . . . . . . . .  C ADDR   1CCBH   A   
SETUP_COMM_WAIT . . . . . . . . . .  C ADDR   0D25H   A   
SETUP_ZC_SCAN_TIMEOUT . . . . . . .  C ADDR   0C1DH   A   
SETUP_ZC_SCAN_TIMEOUT_STARTUP_DONE.  C ADDR   0C41H   A   
SET_BEC_VOLTAGE . . . . . . . . . .  C ADDR   10B8H   A   
SET_DEFAULT_PARAMETERS. . . . . . .  C ADDR   0FA7H   A   
SET_PWM_LIMIT_HIGH_RPM. . . . . . .  C ADDR   086BH   A   
SET_PWM_LIMIT_HIGH_RPM_INC_LIMIT. .  C ADDR   087BH   A   
SET_PWM_LIMIT_HIGH_RPM_STORE. . . .  C ADDR   087CH   A   
SET_PWM_LIMIT_LOW_RPM . . . . . . .  C ADDR   083BH   A   
SET_PWM_LIMIT_LOW_RPM_EXIT. . . . .  C ADDR   0868H   A   
SET_STARTUP_PWM . . . . . . . . . .  C ADDR   09C8H   A   
SI0 . . . . . . . . . . . . . . . .  B ADDR   00C0H.0 A   
SIGNATURE_001 . . . . . . . . . . .  N NUMB   00F8H   A   
SIGNATURE_002 . . . . . . . . . . .  N NUMB   0050H   A   
SKIP_DAMP_ON. . . . . . . . . . . .  N NUMB   0007H   A   
SKIP_T2H_INT. . . . . . . . . . . .  D ADDR   0078H   A   
SKIP_T2_INT . . . . . . . . . . . .  D ADDR   0077H   A   
SMB0ADM . . . . . . . . . . . . . .  D ADDR   00D6H   A   
SMB0ADR . . . . . . . . . . . . . .  D ADDR   00D7H   A   
SMB0CF. . . . . . . . . . . . . . .  D ADDR   00C1H   A   
SMB0CN. . . . . . . . . . . . . . .  D ADDR   00C0H   A   
SMB0DAT . . . . . . . . . . . . . .  D ADDR   00C2H   A   
SMB0TC. . . . . . . . . . . . . . .  D ADDR   00ACH   A   
SP. . . . . . . . . . . . . . . . .  D ADDR   0081H   A   
SPI0CFG . . . . . . . . . . . . . .  D ADDR   00A1H   A   
SPI0CKR . . . . . . . . . . . . . .  D ADDR   00A2H   A   
SPI0CN. . . . . . . . . . . . . . .  D ADDR   00F8H   A   
SPI0DAT . . . . . . . . . . . . . .  D ADDR   00A3H   A   
SPIEN . . . . . . . . . . . . . . .  B ADDR   00F8H.0 A   
SPIF. . . . . . . . . . . . . . . .  B ADDR   00F8H.7 A   
SPOOLUP_LIMIT_CNT . . . . . . . . .  D ADDR   0069H   A   
SPOOLUP_LIMIT_SKIP. . . . . . . . .  D ADDR   006AH   A   
STA0. . . . . . . . . . . . . . . .  B ADDR   00C0H.5 A   
STALL_CNT . . . . . . . . . . . . .  D ADDR   0036H   A   
STARTUP_CNT . . . . . . . . . . . .  D ADDR   0033H   A   
STARTUP_PHASE . . . . . . . . . . .  N NUMB   0001H   A   
STARTUP_POWER_TABLE . . . . . . . .  C ADDR   008DH   A   
STARTUP_PWM_SET_PWM . . . . . . . .  C ADDR   09DDH   A   
STARTUP_ZC_TIMEOUT_CNTD . . . . . .  D ADDR   0034H   A   
START_ADC_CONVERSION. . . . . . . .  C ADDR   090FH   A   
STO0. . . . . . . . . . . . . . . .  B ADDR   00C0H.4 A   
STORE_IN_RAM_EXIT . . . . . . . . .  C ADDR   176FH   A   
STORE_MAIN_FUNC_1 . . . . . . . . .  C ADDR   1738H   A   
STORE_MAIN_FUNC_10. . . . . . . . .  C ADDR   1765H   A   
STORE_MAIN_FUNC_11. . . . . . . . .  C ADDR   176AH   A   
STORE_MAIN_FUNC_2 . . . . . . . . .  C ADDR   173DH   A   
STORE_MAIN_FUNC_3 . . . . . . . . .  C ADDR   1742H   A   
STORE_MAIN_FUNC_4 . . . . . . . . .  C ADDR   1747H   A   
STORE_MAIN_FUNC_5 . . . . . . . . .  C ADDR   174CH   A   
STORE_MAIN_FUNC_6 . . . . . . . . .  C ADDR   1751H   A   
STORE_MAIN_FUNC_7 . . . . . . . . .  C ADDR   1756H   A   
STORE_MAIN_FUNC_8 . . . . . . . . .  C ADDR   175BH   A   
STORE_MAIN_FUNC_9 . . . . . . . . .  C ADDR   1760H   A   
STORE_NEW_VALUE_IN_RAM. . . . . . .  C ADDR   1734H   A   
STORE_TIMES_DECREASE. . . . . . . .  C ADDR   0BB4H   A   
STORE_TIMES_DECREASE_FAST . . . . .  C ADDR   0C05H   A   
STORE_TIMES_EXIT. . . . . . . . . .  C ADDR   0BD5H   A   
STORE_TIMES_INCREASE. . . . . . . .  C ADDR   0BA6H   A   
STORE_TIMES_INCREASE_FAST . . . . .  C ADDR   0BFDH   A   
STORE_TIMES_UP_OR_DOWN. . . . . . .  C ADDR   0BA0H   A   
STORE_TIMES_UP_OR_DOWN_FAST . . . .  C ADDR   0BF7H   A   
SUCCESS . . . . . . . . . . . . . .  N NUMB   0030H   A   
SUCCESS_BEEP. . . . . . . . . . . .  C ADDR   177AH   A   
SUCCESS_BEEP_INVERTED . . . . . . .  C ADDR   17A9H   A   
SWITCH_POWER_OFF. . . . . . . . . .  C ADDR   0F92H   A   
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   203

T0_INT. . . . . . . . . . . . . . .  C ADDR   00AAH   A   
T0_INT_PWM_OFF. . . . . . . . . . .  C ADDR   00C7H   A   
T0_INT_PWM_OFF_DAMPED . . . . . . .  C ADDR   00E4H   A   
T0_INT_PWM_OFF_DAMP_DONE. . . . . .  C ADDR   00FAH   A   
T0_INT_PWM_OFF_EXIT . . . . . . . .  C ADDR   00FAH   A   
T0_INT_PWM_OFF_EXIT_NFETS_OFF . . .  C ADDR   00D7H   A   
T0_INT_PWM_OFF_FULLPOWER_EXIT . . .  C ADDR   0101H   A   
T0_INT_PWM_ON_EXIT. . . . . . . . .  C ADDR   00B9H   A   
T0_INT_PWM_ON_RET . . . . . . . . .  C ADDR   00C0H   A   
T2H_INT . . . . . . . . . . . . . .  C ADDR   01FCH   A   
T2H_INT_EXIT. . . . . . . . . . . .  C ADDR   02D0H   A   
T2H_INT_RCP_BAILOUT_ARM . . . . . .  C ADDR   02C5H   A   
T2H_INT_RCP_GOV_BY_SETUP. . . . . .  C ADDR   023AH   A   
T2H_INT_RCP_GOV_BY_TX . . . . . . .  C ADDR   024DH   A   
T2H_INT_RCP_GOV_PWM . . . . . . . .  C ADDR   0228H   A   
T2H_INT_RCP_GOV_PWM_DONE. . . . . .  C ADDR   025CH   A   
T2H_INT_RCP_GOV_PWM_INC . . . . . .  C ADDR   025AH   A   
T2H_INT_RCP_INC_LIMIT . . . . . . .  C ADDR   02B9H   A   
T2H_INT_RCP_LIMIT_MIDDLE_RAMP . . .  C ADDR   0289H   A   
T2H_INT_RCP_NO_LIMIT. . . . . . . .  C ADDR   02C3H   A   
T2H_INT_RCP_SET_LIMIT . . . . . . .  C ADDR   0295H   A   
T2H_INT_RCP_STOP. . . . . . . . . .  C ADDR   0217H   A   
T2H_INT_RCP_STOP_CHECK. . . . . . .  C ADDR   020BH   A   
T2SPLIT . . . . . . . . . . . . . .  B ADDR   00C8H.3 A   
T2XCLK. . . . . . . . . . . . . . .  B ADDR   00C8H.0 A   
T2_INT. . . . . . . . . . . . . . .  C ADDR   015DH   A   
T2_INT_CURRENT_PWM_UPDATE . . . . .  C ADDR   01E7H   A   
T2_INT_EXIT . . . . . . . . . . . .  C ADDR   01EFH   A   
T2_INT_PPM_TIMEOUT_SET. . . . . . .  C ADDR   01BAH   A   
T2_INT_PULSES_ABSENT. . . . . . . .  C ADDR   0179H   A   
T2_INT_PULSES_ABSENT_NO_MAX . . . .  C ADDR   01AEH   A   
T2_INT_PWM_MIN_RUN. . . . . . . . .  C ADDR   01E5H   A   
T2_INT_PWM_UPDATE . . . . . . . . .  C ADDR   01E5H   A   
T2_INT_RCP_UPDATE_START . . . . . .  C ADDR   01D4H   A   
T2_INT_SKIP_END . . . . . . . . . .  C ADDR   01CFH   A   
T2_INT_SKIP_START . . . . . . . . .  C ADDR   01C4H   A   
T3_INT. . . . . . . . . . . . . . .  C ADDR   02DAH   A   
T3_PENDING. . . . . . . . . . . . .  N NUMB   0000H   A   
TAG_TEMPORARY_STORAGE . . . . . . .  I ADDR   00D0H   A   
TB80. . . . . . . . . . . . . . . .  B ADDR   0098H.3 A   
TCON. . . . . . . . . . . . . . . .  D ADDR   0088H   A   
TEMP1 . . . . . . . . . . . . . . .    REG    R0          
TEMP2 . . . . . . . . . . . . . . .    REG    R1          
TEMP3 . . . . . . . . . . . . . . .    REG    R2          
TEMP4 . . . . . . . . . . . . . . .    REG    R3          
TEMP5 . . . . . . . . . . . . . . .    REG    R4          
TEMP6 . . . . . . . . . . . . . . .    REG    R5          
TEMP7 . . . . . . . . . . . . . . .    REG    R6          
TEMP8 . . . . . . . . . . . . . . .    REG    R7          
TEMP_AVERAGE_DEC. . . . . . . . . .  C ADDR   0946H   A   
TEMP_AVERAGE_INC. . . . . . . . . .  C ADDR   0949H   A   
TEMP_AVERAGE_INC_DEC. . . . . . . .  C ADDR   093AH   A   
TEMP_AVERAGE_UPDATED. . . . . . . .  C ADDR   0950H   A   
TEMP_AVERAGE_UPDATED_LOAD_ACC . . .  C ADDR   094EH   A   
TEMP_CHECK_EXIT . . . . . . . . . .  C ADDR   0972H   A   
TEMP_CHECK_RATE . . . . . . . . . .  N NUMB   0008H   A   
TEMP_LIMIT. . . . . . . . . . . . .  N NUMB   0067H   A   
TEMP_LIMIT_STEP . . . . . . . . . .  N NUMB   0004H   A   
TEST_FOR_ONESHOT. . . . . . . . . .  C ADDR   1292H   A   
TEST_THROTTLE_GAIN. . . . . . . . .  C ADDR   10E1H   A   
TF0 . . . . . . . . . . . . . . . .  B ADDR   0088H.5 A   
TF1 . . . . . . . . . . . . . . . .  B ADDR   0088H.7 A   
TF2CEN. . . . . . . . . . . . . . .  B ADDR   00C8H.4 A   
TF2H. . . . . . . . . . . . . . . .  B ADDR   00C8H.7 A   
TF2L. . . . . . . . . . . . . . . .  B ADDR   00C8H.6 A   
TF2LEN. . . . . . . . . . . . . . .  B ADDR   00C8H.5 A   
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   204

TH0 . . . . . . . . . . . . . . . .  D ADDR   008CH   A   
TH1 . . . . . . . . . . . . . . . .  D ADDR   008DH   A   
THROTTLE_HIGH_CAL . . . . . . . . .  C ADDR   131DH   A   
THROTTLE_HIGH_CAL_START . . . . . .  C ADDR   131BH   A   
THROTTLE_LOW_CAL. . . . . . . . . .  C ADDR   1353H   A   
THROTTLE_LOW_CAL_START. . . . . . .  C ADDR   1351H   A   
TI0 . . . . . . . . . . . . . . . .  B ADDR   0098H.1 A   
TIMER0_OVERFLOW_VALUE . . . . . . .  D ADDR   0079H   A   
TIMER2_X. . . . . . . . . . . . . .  D ADDR   003AH   A   
TL0 . . . . . . . . . . . . . . . .  D ADDR   008AH   A   
TL1 . . . . . . . . . . . . . . . .  D ADDR   008BH   A   
TMOD. . . . . . . . . . . . . . . .  D ADDR   0089H   A   
TMR2CN. . . . . . . . . . . . . . .  D ADDR   00C8H   A   
TMR2H . . . . . . . . . . . . . . .  D ADDR   00CDH   A   
TMR2L . . . . . . . . . . . . . . .  D ADDR   00CCH   A   
TMR2RLH . . . . . . . . . . . . . .  D ADDR   00CBH   A   
TMR2RLL . . . . . . . . . . . . . .  D ADDR   00CAH   A   
TMR3CN. . . . . . . . . . . . . . .  D ADDR   0091H   A   
TMR3H . . . . . . . . . . . . . . .  D ADDR   0095H   A   
TMR3L . . . . . . . . . . . . . . .  D ADDR   0094H   A   
TMR3RLH . . . . . . . . . . . . . .  D ADDR   0093H   A   
TMR3RLL . . . . . . . . . . . . . .  D ADDR   0092H   A   
TR0 . . . . . . . . . . . . . . . .  B ADDR   0088H.4 A   
TR1 . . . . . . . . . . . . . . . .  B ADDR   0088H.6 A   
TR2 . . . . . . . . . . . . . . . .  B ADDR   00C8H.2 A   
TXBMT . . . . . . . . . . . . . . .  B ADDR   00F8H.1 A   
TXMODE0 . . . . . . . . . . . . . .  B ADDR   00C0H.6 A   
TX_PGM_BEEP_NO. . . . . . . . . . .  D ADDR   0076H   A   
TX_PGM_FUNC_NO. . . . . . . . . . .  D ADDR   0074H   A   
TX_PGM_PARAMS_MAIN. . . . . . . . .  C ADDR   009FH   A   
TX_PGM_PARAVAL_NO . . . . . . . . .  D ADDR   0075H   A   
UART_LOOP . . . . . . . . . . . . .  N NUMB   001AH   A   
VALIDATE_RCP_START. . . . . . . . .  C ADDR   12A6H   A   
VDM0CN. . . . . . . . . . . . . . .  D ADDR   00FFH   A   
WAIT1 . . . . . . . . . . . . . . .  C ADDR   1DE1H   A   
WAIT100MS . . . . . . . . . . . . .  C ADDR   0559H   A   
WAIT10MS. . . . . . . . . . . . . .  C ADDR   0551H   A   
WAIT1MS . . . . . . . . . . . . . .  C ADDR   0549H   A   
WAIT1S. . . . . . . . . . . . . . .  C ADDR   1772H   A   
WAIT1S_LOOP . . . . . . . . . . . .  C ADDR   1774H   A   
WAIT200MS . . . . . . . . . . . . .  C ADDR   055DH   A   
WAIT30MS. . . . . . . . . . . . . .  C ADDR   0555H   A   
WAIT3MS . . . . . . . . . . . . . .  C ADDR   054DH   A   
WAITF . . . . . . . . . . . . . . .  C ADDR   1DDBH   A   
WAITH . . . . . . . . . . . . . . .  C ADDR   1DDFH   A   
WAITXMS_M . . . . . . . . . . . . .  C ADDR   0563H   A   
WAITXMS_O . . . . . . . . . . . . .  C ADDR   0561H   A   
WAIT_ADVANCE_TIMING . . . . . . . .  C ADDR   0B4CH   A   
WAIT_BEFORE_ZC_SCAN . . . . . . . .  C ADDR   0C0BH   A   
WAIT_BEFORE_ZC_SCAN_EXIT. . . . . .  C ADDR   0C5CH   A   
WAIT_BEFORE_ZC_SCAN_RAND. . . . . .  C ADDR   0C13H   A   
WAIT_BEFORE_ZC_SCAN_WAIT. . . . . .  C ADDR   0C15H   A   
WAIT_FOR_COMM . . . . . . . . . . .  C ADDR   0D61H   A   
WAIT_FOR_COMM_WAIT. . . . . . . . .  C ADDR   0D97H   A   
WAIT_FOR_COMP_OUT_HIGH. . . . . . .  C ADDR   0C6DH   A   
WAIT_FOR_COMP_OUT_LOW . . . . . . .  C ADDR   0C5DH   A   
WAIT_FOR_COMP_OUT_START . . . . . .  C ADDR   0C7BH   A   
WAIT_FOR_LOW. . . . . . . . . . . .  C ADDR   1C48H   A   
WAIT_FOR_POWER_ON . . . . . . . . .  C ADDR   13E6H   A   
WAIT_FOR_POWER_ON_CHECK_TIMEOUT . .  C ADDR   144DH   A   
WAIT_FOR_POWER_ON_LOOP. . . . . . .  C ADDR   13EBH   A   
WAIT_FOR_POWER_ON_NO_BEEP . . . . .  C ADDR   1431H   A   
WAIT_FOR_POWER_ON_PPM_NOT_MISSING .  C ADDR   143DH   A   
WCOL. . . . . . . . . . . . . . . .  B ADDR   00F8H.6 A   
WDTCN . . . . . . . . . . . . . . .  D ADDR   0097H   A   
WRITE_EEPROM_BLOCK1 . . . . . . . .  C ADDR   16B4H   A   
A51 MACRO ASSEMBLER  BLHELI                                                               10/13/2019 13:05:15 PAGE   205

WRITE_EEPROM_BLOCK2 . . . . . . . .  C ADDR   16C1H   A   
WRITE_EEPROM_BYTE . . . . . . . . .  C ADDR   16D3H   A   
WRITE_EEPROM_BYTE_FROM_ACC. . . . .  C ADDR   16D4H   A   
WRITE_EEPROM_SIGNATURE. . . . . . .  C ADDR   1703H   A   
WRITE_TAG . . . . . . . . . . . . .  C ADDR   172CH   A   
WRITE_TAGS. . . . . . . . . . . . .  C ADDR   1725H   A   
WT_ADV_START_H. . . . . . . . . . .  D ADDR   004EH   A   
WT_ADV_START_L. . . . . . . . . . .  D ADDR   004DH   A   
WT_COMM_START_H . . . . . . . . . .  D ADDR   0054H   A   
WT_COMM_START_L . . . . . . . . . .  D ADDR   0053H   A   
WT_ZC_SCAN_START_H. . . . . . . . .  D ADDR   0050H   A   
WT_ZC_SCAN_START_L. . . . . . . . .  D ADDR   004FH   A   
WT_ZC_TOUT_START_H. . . . . . . . .  D ADDR   0052H   A   
WT_ZC_TOUT_START_L. . . . . . . . .  D ADDR   0051H   A   
XBR0. . . . . . . . . . . . . . . .  D ADDR   00E1H   A   
XBR1. . . . . . . . . . . . . . . .  D ADDR   00E2H   A   
XBR2. . . . . . . . . . . . . . . .  D ADDR   00E3H   A   
XH. . . . . . . . . . . . . . . . .    REG    R1          
XL. . . . . . . . . . . . . . . . .    REG    R0          
XTAL. . . . . . . . . . . . . . . .  N NUMB   7840H   A   
_EEP_PGM_DAMPING_FORCE. . . . . . .  C ADDR   1A16H   A   
_EEP_PGM_MOTOR_GAIN . . . . . . . .  C ADDR   1A07H   A   
_EEP_PGM_MOTOR_IDLE . . . . . . . .  C ADDR   1A08H   A   
_EEP_PGM_PPM_CENTER_THROTTLE. . . .  C ADDR   1A21H   A   
_EEP_PGM_PWM_DITHER . . . . . . . .  C ADDR   1A26H   A   
_EEP_PGM_STARTUP_ACCEL. . . . . . .  C ADDR   1A13H   A   
_EEP_PGM_STARTUP_METHOD . . . . . .  C ADDR   1A18H   A   
_EEP_PGM_STARTUP_RPM. . . . . . . .  C ADDR   1A12H   A   
_EEP_PGM_THROTTLE_RATE. . . . . . .  C ADDR   1A1EH   A   
_EEP_PGM_VOLT_COMP. . . . . . . . .  C ADDR   1A14H   A   
_PGM_DAMPING_FORCE. . . . . . . . .  I ADDR   0093H   A   
_PGM_STARTUP_ACCEL. . . . . . . . .  I ADDR   0090H   A   
_PGM_STARTUP_METHOD . . . . . . . .  I ADDR   0095H   A   
_PGM_STARTUP_RPM. . . . . . . . . .  I ADDR   008FH   A   
_PGM_THROTTLE_RATE. . . . . . . . .  I ADDR   009BH   A   
_PGM_VOLT_COMP. . . . . . . . . . .  I ADDR   0091H   A   


REGISTER BANK(S) USED: 0 


ASSEMBLY COMPLETE.  0 WARNING(S), 0 ERROR(S)
